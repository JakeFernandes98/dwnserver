(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all2) => {
    for (var name6 in all2)
      __defProp(target, name6, { get: all2[name6], enumerable: true });
  };
  var __copyProps = (to, from12, except, desc) => {
    if (from12 && typeof from12 === "object" || typeof from12 === "function") {
      for (let key of __getOwnPropNames(from12))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from12[key], enumerable: !(desc = __getOwnPropDesc(from12, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e2) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e3) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e2) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e3) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function binding(name6) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance2) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance2, performanceNow, startTime, process, defines;
  var init_virtual_process_polyfill = __esm({
    "node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js"() {
      cachedSetTimeout = defaultSetTimout;
      cachedClearTimeout = defaultClearTimeout;
      if (typeof globalThis.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof globalThis.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      platform = "browser";
      browser = true;
      env = {};
      argv = [];
      version = "";
      versions = {};
      release = {};
      config = {};
      on = noop;
      addListener = noop;
      once = noop;
      off = noop;
      removeListener = noop;
      removeAllListeners = noop;
      emit = noop;
      performance2 = globalThis.performance || {};
      performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
        return new Date().getTime();
      };
      startTime = new Date();
      process = {
        nextTick,
        title,
        browser,
        env,
        argv,
        version,
        versions,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        binding,
        cwd,
        chdir,
        umask,
        hrtime,
        platform,
        release,
        config,
        uptime
      };
      defines = {};
      Object.keys(defines).forEach((key) => {
        const segs = key.split(".");
        let target = process;
        for (let i2 = 0; i2 < segs.length; i2++) {
          const seg = segs[i2];
          if (i2 === segs.length - 1) {
            target[seg] = defines[key];
          } else {
            target = target[seg] || (target[seg] = {});
          }
        }
      });
    }
  });

  // node_modules/level-supports/index.js
  var require_level_supports = __commonJS({
    "node_modules/level-supports/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      exports2.supports = function supports(...manifests) {
        const manifest = manifests.reduce((acc, m2) => Object.assign(acc, m2), {});
        return Object.assign(manifest, {
          snapshots: manifest.snapshots || false,
          permanence: manifest.permanence || false,
          seek: manifest.seek || false,
          clear: manifest.clear || false,
          getMany: manifest.getMany || false,
          keyIterator: manifest.keyIterator || false,
          valueIterator: manifest.valueIterator || false,
          iteratorNextv: manifest.iteratorNextv || false,
          iteratorAll: manifest.iteratorAll || false,
          status: manifest.status || false,
          createIfMissing: manifest.createIfMissing || false,
          errorIfExists: manifest.errorIfExists || false,
          deferredOpen: manifest.deferredOpen || false,
          promises: manifest.promises || false,
          streams: manifest.streams || false,
          encodings: Object.assign({}, manifest.encodings),
          events: Object.assign({}, manifest.events),
          additionalMethods: Object.assign({}, manifest.additionalMethods)
        });
      };
    }
  });

  // node_modules/module-error/index.js
  var require_module_error = __commonJS({
    "node_modules/module-error/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = class ModuleError extends Error {
        constructor(message, options) {
          super(message || "");
          if (typeof options === "object" && options !== null) {
            if (options.code)
              this.code = String(options.code);
            if (options.expected)
              this.expected = true;
            if (options.transient)
              this.transient = true;
            if (options.cause)
              this.cause = options.cause;
          }
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
      };
    }
  });

  // node-modules-polyfills:buffer
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer2,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    SlowBuffer: () => SlowBuffer,
    isBuffer: () => isBuffer,
    kMaxLength: () => _kMaxLength
  });
  function init() {
    inited = true;
    var code8 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code8.length; i2 < len; ++i2) {
      lookup[i2] = code8[i2];
      revLookup[code8.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i2, j2, l2, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l2 = placeHolders > 0 ? len - 4 : len;
    var L2 = 0;
    for (i2 = 0, j2 = 0; i2 < l2; i2 += 4, j2 += 3) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[L2++] = tmp >> 16 & 255;
      arr[L2++] = tmp >> 8 & 255;
      arr[L2++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[L2++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[L2++] = tmp >> 8 & 255;
      arr[L2++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function read(buffer2, offset, isLE, mLen, nBytes) {
    var e2, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s2 = buffer2[offset + i2];
    i2 += d2;
    e2 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
    }
    m2 = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
    }
    if (e2 === 0) {
      e2 = 1 - eBias;
    } else if (e2 === eMax) {
      return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
  }
  function write(buffer2, value, offset, isLE, mLen, nBytes) {
    var e2, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e2)) < 1) {
        e2--;
        c2 *= 2;
      }
      if (e2 + eBias >= 1) {
        value += rt2 / c2;
      } else {
        value += rt2 * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e2++;
        c2 /= 2;
      }
      if (e2 + eBias >= eMax) {
        m2 = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
    }
    e2 = e2 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
    }
    buffer2[offset + i2 - d2] |= s2 * 128;
  }
  function kMaxLength() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length7) {
    if (kMaxLength() < length7) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length7);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) {
        that = new Buffer2(length7);
      }
      that.length = length7;
    }
    return that;
  }
  function Buffer2(arg, encodingOrOffset, length7) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, encodingOrOffset, length7);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from2(this, arg, encodingOrOffset, length7);
  }
  function from2(that, value, encodingOrOffset, length7) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length7);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill2, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
    }
    return createBuffer(that, size);
  }
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i2 = 0; i2 < size; ++i2) {
        that[i2] = 0;
      }
    }
    return that;
  }
  function fromString(that, string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length7 = byteLength(string2, encoding) | 0;
    that = createBuffer(that, length7);
    var actual = that.write(string2, encoding);
    if (actual !== length7) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length7 = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length7);
    for (var i2 = 0; i2 < length7; i2 += 1) {
      that[i2] = array[i2] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array, byteOffset, length7) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length7 || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length7 === void 0) {
      array = new Uint8Array(array);
    } else if (length7 === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length7);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer2.prototype;
    } else {
      that = fromArrayLike(that, array);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length7) {
    if (length7 >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length7 | 0;
  }
  function SlowBuffer(length7) {
    if (+length7 != length7) {
      length7 = 0;
    }
    return Buffer2.alloc(+length7);
  }
  function internalIsBuffer(b2) {
    return !!(b2 != null && b2._isBuffer);
  }
  function byteLength(string2, encoding) {
    if (internalIsBuffer(string2)) {
      return string2.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      string2 = "" + string2;
    }
    var len = string2.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string2).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap(b2, n2, m2) {
    var i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read8(buf2, i3) {
      if (indexSize === 1) {
        return buf2[i3];
      } else {
        return buf2.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read8(arr, i2) === read8(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read8(arr, i2 + j2) !== read8(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  function hexWrite(buf2, string2, offset, length7) {
    offset = Number(offset) || 0;
    var remaining = buf2.length - offset;
    if (!length7) {
      length7 = remaining;
    } else {
      length7 = Number(length7);
      if (length7 > remaining) {
        length7 = remaining;
      }
    }
    var strLen = string2.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length7 > strLen / 2) {
      length7 = strLen / 2;
    }
    for (var i2 = 0; i2 < length7; ++i2) {
      var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (isNaN(parsed))
        return i2;
      buf2[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf2, string2, offset, length7) {
    return blitBuffer(utf8ToBytes(string2, buf2.length - offset), buf2, offset, length7);
  }
  function asciiWrite(buf2, string2, offset, length7) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length7);
  }
  function latin1Write(buf2, string2, offset, length7) {
    return asciiWrite(buf2, string2, offset, length7);
  }
  function base64Write(buf2, string2, offset, length7) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length7);
  }
  function ucs2Write(buf2, string2, offset, length7) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length7);
  }
  function base64Slice(buf2, start, end) {
    if (start === 0 && end === buf2.length) {
      return fromByteArray(buf2);
    } else {
      return fromByteArray(buf2.slice(start, end));
    }
  }
  function utf8Slice(buf2, start, end) {
    end = Math.min(buf2.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf2[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            fourthByte = buf2[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end) {
    var ret = "";
    end = Math.min(buf2.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf2[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end) {
    var ret = "";
    end = Math.min(buf2.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf2[i2]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end) {
    var len = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += toHex(buf2[i2]);
    }
    return out;
  }
  function utf16leSlice(buf2, start, end) {
    var bytes = buf2.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  function checkOffset(offset, ext, length7) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length7)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(buf2, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  function objectWriteUInt16(buf2, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i2 = 0, j2 = Math.min(buf2.length - offset, 2); i2 < j2; ++i2) {
      buf2[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
    }
  }
  function objectWriteUInt32(buf2, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i2 = 0, j2 = Math.min(buf2.length - offset, 4); i2 < j2; ++i2) {
      buf2[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
    }
  }
  function checkIEEE754(buf2, value, offset, ext, max, min) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n2) {
    if (n2 < 16)
      return "0" + n2.toString(16);
    return n2.toString(16);
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length7 = string2.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length7; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length7) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }
  function blitBuffer(src7, dst, offset, length7) {
    for (var i2 = 0; i2 < length7; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src7.length)
        break;
      dst[i2 + offset] = src7[i2];
    }
    return i2;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  var lookup, revLookup, Arr, inited, toString, isArray, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
  var init_buffer = __esm({
    "node-modules-polyfills:buffer"() {
      init_virtual_process_polyfill();
      lookup = [];
      revLookup = [];
      Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited = false;
      toString = {}.toString;
      isArray = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
      INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
      _kMaxLength = kMaxLength();
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      Buffer2.from = function(value, encodingOrOffset, length7) {
        return from2(null, value, encodingOrOffset, length7);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
      }
      Buffer2.alloc = function(size, fill2, encoding) {
        return alloc(null, size, fill2, encoding);
      };
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.isBuffer = isBuffer;
      Buffer2.compare = function compare(a2, b2) {
        if (!internalIsBuffer(a2) || !internalIsBuffer(b2)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a2 === b2)
          return 0;
        var x2 = a2.length;
        var y2 = b2.length;
        for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
          if (a2[i2] !== b2[i2]) {
            x2 = a2[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length7) {
        if (!isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i2;
        if (length7 === void 0) {
          length7 = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length7 += list[i2].length;
          }
        }
        var buffer2 = Buffer2.allocUnsafe(length7);
        var pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          var buf2 = list[i2];
          if (!internalIsBuffer(buf2)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf2.copy(buffer2, pos);
          pos += buf2.length;
        }
        return buffer2;
      };
      Buffer2.byteLength = byteLength;
      Buffer2.prototype._isBuffer = true;
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        var length7 = this.length | 0;
        if (length7 === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length7);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals2(b2) {
        if (!internalIsBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer2.compare(this, b2) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x2 = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x2, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i2 = 0; i2 < len; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x2 = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      Buffer2.prototype.write = function write2(string2, offset, length7, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length7 = this.length;
          offset = 0;
        } else if (length7 === void 0 && typeof offset === "string") {
          encoding = offset;
          length7 = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length7)) {
            length7 = length7 | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length7;
            length7 = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length7 === void 0 || length7 > remaining)
          length7 = remaining;
        if (string2.length > 0 && (length7 < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset, length7);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset, length7);
            case "ascii":
              return asciiWrite(this, string2, offset, length7);
            case "latin1":
            case "binary":
              return latin1Write(this, string2, offset, length7);
            case "base64":
              return base64Write(this, string2, offset, length7);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset, length7);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH = 4096;
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i2 = 0; i2 < sliceLen; ++i2) {
            newBuf[i2] = this[i2 + start];
          }
        }
        return newBuf;
      };
      Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i2 = byteLength2;
        var mul = 1;
        var val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i2 = byteLength2 - 1;
        var mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i2 = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i2 = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i2;
        if (this === target && start < targetStart && targetStart < end) {
          for (i2 = len - 1; i2 >= 0; --i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i2 = 0; i2 < len; ++i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code8 = val.charCodeAt(0);
            if (code8 < 256) {
              val = code8;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // node-modules-polyfills-commonjs:buffer
  var require_buffer = __commonJS({
    "node-modules-polyfills-commonjs:buffer"(exports2, module2) {
      init_virtual_process_polyfill();
      var polyfill = (init_buffer(), __toCommonJS(buffer_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k2 in polyfill) {
          module2.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node_modules/level-transcoder/lib/text-endec.js
  var require_text_endec = __commonJS({
    "node_modules/level-transcoder/lib/text-endec.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var lazy = null;
      module2.exports = function() {
        if (lazy === null) {
          lazy = {
            textEncoder: new TextEncoder(),
            textDecoder: new TextDecoder()
          };
        }
        return lazy;
      };
    }
  });

  // node_modules/level-transcoder/lib/encoding.js
  var require_encoding = __commonJS({
    "node_modules/level-transcoder/lib/encoding.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var ModuleError = require_module_error();
      var formats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
      var Encoding = class {
        constructor(options) {
          this.encode = options.encode || this.encode;
          this.decode = options.decode || this.decode;
          this.name = options.name || this.name;
          this.format = options.format || this.format;
          if (typeof this.encode !== "function") {
            throw new TypeError("The 'encode' property must be a function");
          }
          if (typeof this.decode !== "function") {
            throw new TypeError("The 'decode' property must be a function");
          }
          this.encode = this.encode.bind(this);
          this.decode = this.decode.bind(this);
          if (typeof this.name !== "string" || this.name === "") {
            throw new TypeError("The 'name' property must be a string");
          }
          if (typeof this.format !== "string" || !formats.has(this.format)) {
            throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
          }
          if (options.createViewTranscoder) {
            this.createViewTranscoder = options.createViewTranscoder;
          }
          if (options.createBufferTranscoder) {
            this.createBufferTranscoder = options.createBufferTranscoder;
          }
          if (options.createUTF8Transcoder) {
            this.createUTF8Transcoder = options.createUTF8Transcoder;
          }
        }
        get commonName() {
          return this.name.split("+")[0];
        }
        createBufferTranscoder() {
          throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
            code: "LEVEL_ENCODING_NOT_SUPPORTED"
          });
        }
        createViewTranscoder() {
          throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
            code: "LEVEL_ENCODING_NOT_SUPPORTED"
          });
        }
        createUTF8Transcoder() {
          throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
            code: "LEVEL_ENCODING_NOT_SUPPORTED"
          });
        }
      };
      exports2.Encoding = Encoding;
    }
  });

  // node_modules/level-transcoder/lib/formats.js
  var require_formats = __commonJS({
    "node_modules/level-transcoder/lib/formats.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { Buffer: Buffer3 } = require_buffer() || {};
      var { Encoding } = require_encoding();
      var textEndec = require_text_endec();
      var BufferFormat = class extends Encoding {
        constructor(options) {
          super({ ...options, format: "buffer" });
        }
        createViewTranscoder() {
          return new ViewFormat({
            encode: this.encode,
            decode: (data) => this.decode(
              Buffer3.from(data.buffer, data.byteOffset, data.byteLength)
            ),
            name: `${this.name}+view`
          });
        }
        createBufferTranscoder() {
          return this;
        }
      };
      var ViewFormat = class extends Encoding {
        constructor(options) {
          super({ ...options, format: "view" });
        }
        createBufferTranscoder() {
          return new BufferFormat({
            encode: (data) => {
              const view = this.encode(data);
              return Buffer3.from(view.buffer, view.byteOffset, view.byteLength);
            },
            decode: this.decode,
            name: `${this.name}+buffer`
          });
        }
        createViewTranscoder() {
          return this;
        }
      };
      var UTF8Format = class extends Encoding {
        constructor(options) {
          super({ ...options, format: "utf8" });
        }
        createBufferTranscoder() {
          return new BufferFormat({
            encode: (data) => Buffer3.from(this.encode(data), "utf8"),
            decode: (data) => this.decode(data.toString("utf8")),
            name: `${this.name}+buffer`
          });
        }
        createViewTranscoder() {
          const { textEncoder: textEncoder6, textDecoder: textDecoder5 } = textEndec();
          return new ViewFormat({
            encode: (data) => textEncoder6.encode(this.encode(data)),
            decode: (data) => this.decode(textDecoder5.decode(data)),
            name: `${this.name}+view`
          });
        }
        createUTF8Transcoder() {
          return this;
        }
      };
      exports2.BufferFormat = BufferFormat;
      exports2.ViewFormat = ViewFormat;
      exports2.UTF8Format = UTF8Format;
    }
  });

  // node_modules/level-transcoder/lib/encodings.js
  var require_encodings = __commonJS({
    "node_modules/level-transcoder/lib/encodings.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { Buffer: Buffer3 } = require_buffer() || { Buffer: { isBuffer: () => false } };
      var { textEncoder: textEncoder6, textDecoder: textDecoder5 } = require_text_endec()();
      var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
      var identity4 = (v2) => v2;
      exports2.utf8 = new UTF8Format({
        encode: function(data) {
          return Buffer3.isBuffer(data) ? data.toString("utf8") : ArrayBuffer.isView(data) ? textDecoder5.decode(data) : String(data);
        },
        decode: identity4,
        name: "utf8",
        createViewTranscoder() {
          return new ViewFormat({
            encode: function(data) {
              return ArrayBuffer.isView(data) ? data : textEncoder6.encode(data);
            },
            decode: function(data) {
              return textDecoder5.decode(data);
            },
            name: `${this.name}+view`
          });
        },
        createBufferTranscoder() {
          return new BufferFormat({
            encode: function(data) {
              return Buffer3.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer3.from(data.buffer, data.byteOffset, data.byteLength) : Buffer3.from(String(data), "utf8");
            },
            decode: function(data) {
              return data.toString("utf8");
            },
            name: `${this.name}+buffer`
          });
        }
      });
      exports2.json = new UTF8Format({
        encode: JSON.stringify,
        decode: JSON.parse,
        name: "json"
      });
      exports2.buffer = new BufferFormat({
        encode: function(data) {
          return Buffer3.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer3.from(data.buffer, data.byteOffset, data.byteLength) : Buffer3.from(String(data), "utf8");
        },
        decode: identity4,
        name: "buffer",
        createViewTranscoder() {
          return new ViewFormat({
            encode: function(data) {
              return ArrayBuffer.isView(data) ? data : Buffer3.from(String(data), "utf8");
            },
            decode: function(data) {
              return Buffer3.from(data.buffer, data.byteOffset, data.byteLength);
            },
            name: `${this.name}+view`
          });
        }
      });
      exports2.view = new ViewFormat({
        encode: function(data) {
          return ArrayBuffer.isView(data) ? data : textEncoder6.encode(data);
        },
        decode: identity4,
        name: "view",
        createBufferTranscoder() {
          return new BufferFormat({
            encode: function(data) {
              return Buffer3.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer3.from(data.buffer, data.byteOffset, data.byteLength) : Buffer3.from(String(data), "utf8");
            },
            decode: identity4,
            name: `${this.name}+buffer`
          });
        }
      });
      exports2.hex = new BufferFormat({
        encode: function(data) {
          return Buffer3.isBuffer(data) ? data : Buffer3.from(String(data), "hex");
        },
        decode: function(buffer2) {
          return buffer2.toString("hex");
        },
        name: "hex"
      });
      exports2.base64 = new BufferFormat({
        encode: function(data) {
          return Buffer3.isBuffer(data) ? data : Buffer3.from(String(data), "base64");
        },
        decode: function(buffer2) {
          return buffer2.toString("base64");
        },
        name: "base64"
      });
    }
  });

  // node_modules/level-transcoder/index.js
  var require_level_transcoder = __commonJS({
    "node_modules/level-transcoder/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var ModuleError = require_module_error();
      var encodings = require_encodings();
      var { Encoding } = require_encoding();
      var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
      var kFormats = Symbol("formats");
      var kEncodings = Symbol("encodings");
      var validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
      var Transcoder = class {
        constructor(formats) {
          if (!Array.isArray(formats)) {
            throw new TypeError("The first argument 'formats' must be an array");
          } else if (!formats.every((f2) => validFormats.has(f2))) {
            throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
          }
          this[kEncodings] = /* @__PURE__ */ new Map();
          this[kFormats] = new Set(formats);
          for (const k2 in encodings) {
            try {
              this.encoding(k2);
            } catch (err) {
              if (err.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
                throw err;
            }
          }
        }
        encodings() {
          return Array.from(new Set(this[kEncodings].values()));
        }
        encoding(encoding) {
          let resolved = this[kEncodings].get(encoding);
          if (resolved === void 0) {
            if (typeof encoding === "string" && encoding !== "") {
              resolved = lookup2[encoding];
              if (!resolved) {
                throw new ModuleError(`Encoding '${encoding}' is not found`, {
                  code: "LEVEL_ENCODING_NOT_FOUND"
                });
              }
            } else if (typeof encoding !== "object" || encoding === null) {
              throw new TypeError("First argument 'encoding' must be a string or object");
            } else {
              resolved = from12(encoding);
            }
            const { name: name6, format: format4 } = resolved;
            if (!this[kFormats].has(format4)) {
              if (this[kFormats].has("view")) {
                resolved = resolved.createViewTranscoder();
              } else if (this[kFormats].has("buffer")) {
                resolved = resolved.createBufferTranscoder();
              } else if (this[kFormats].has("utf8")) {
                resolved = resolved.createUTF8Transcoder();
              } else {
                throw new ModuleError(`Encoding '${name6}' cannot be transcoded`, {
                  code: "LEVEL_ENCODING_NOT_SUPPORTED"
                });
              }
            }
            for (const k2 of [encoding, name6, resolved.name, resolved.commonName]) {
              this[kEncodings].set(k2, resolved);
            }
          }
          return resolved;
        }
      };
      exports2.Transcoder = Transcoder;
      function from12(options) {
        if (options instanceof Encoding) {
          return options;
        }
        const maybeType = "type" in options && typeof options.type === "string" ? options.type : void 0;
        const name6 = options.name || maybeType || `anonymous-${anonymousCount++}`;
        switch (detectFormat(options)) {
          case "view":
            return new ViewFormat({ ...options, name: name6 });
          case "utf8":
            return new UTF8Format({ ...options, name: name6 });
          case "buffer":
            return new BufferFormat({ ...options, name: name6 });
          default: {
            throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
          }
        }
      }
      function detectFormat(options) {
        if ("format" in options && options.format !== void 0) {
          return options.format;
        } else if ("buffer" in options && typeof options.buffer === "boolean") {
          return options.buffer ? "buffer" : "utf8";
        } else if ("code" in options && Number.isInteger(options.code)) {
          return "view";
        } else {
          return "buffer";
        }
      }
      var aliases = {
        binary: encodings.buffer,
        "utf-8": encodings.utf8
      };
      var lookup2 = {
        ...encodings,
        ...aliases
      };
      var anonymousCount = 0;
    }
  });

  // node-modules-polyfills:events
  var events_exports = {};
  __export(events_exports, {
    EventEmitter: () => EventEmitter,
    default: () => events_default
  });
  function EventHandlers() {
  }
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  function emitNone(handler, isFn, self2) {
    if (isFn)
      handler.call(self2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2);
    }
  }
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn)
      handler.call(self2, arg1);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2, arg1);
    }
  }
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn)
      handler.call(self2, arg1, arg2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self2, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2, arg1, arg2, arg3);
    }
  }
  function emitMany(handler, isFn, self2, args) {
    if (isFn)
      handler.apply(self2, args);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].apply(self2, args);
    }
  }
  function _addListener(target, type, listener, prepend) {
    var m2;
    var events;
    var existing;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events.newListener) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events = target._events;
      }
      existing = events[type];
    }
    if (!existing) {
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
      if (!existing.warned) {
        m2 = $getMaxListeners(target);
        if (m2 && m2 > 0 && existing.length > m2) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          emitWarning(w2);
        }
      }
    }
    return target;
  }
  function emitWarning(e2) {
    typeof console.warn === "function" ? console.warn(e2) : console.log(e2);
  }
  function _onceWrap(target, type, listener) {
    var fired = false;
    function g2() {
      target.removeListener(type, g2);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g2.listener = listener;
    return g2;
  }
  function listenerCount(type) {
    var events = this._events;
    if (events) {
      var evlistener = events[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
    return 0;
  }
  function spliceOne(list, index) {
    for (var i2 = index, k2 = i2 + 1, n2 = list.length; k2 < n2; i2 += 1, k2 += 1)
      list[i2] = list[k2];
    list.pop();
  }
  function arrayClone(arr, i2) {
    var copy2 = new Array(i2);
    while (i2--)
      copy2[i2] = arr[i2];
    return copy2;
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i2 = 0; i2 < ret.length; ++i2) {
      ret[i2] = arr[i2].listener || arr[i2];
    }
    return ret;
  }
  var domain, events_default;
  var init_events = __esm({
    "node-modules-polyfills:events"() {
      "use strict";
      init_virtual_process_polyfill();
      EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
      events_default = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain.active && !(this instanceof domain.Domain)) {
            this.domain = domain.active;
          }
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
        if (typeof n2 !== "number" || n2 < 0 || isNaN(n2))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n2;
        return this;
      };
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit2(type) {
        var er, handler, len, args, i2, events, domain2;
        var needDomainExit = false;
        var doError = type === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i2 = 1; i2 < len; i2++)
              args[i2 - 1] = arguments[i2];
            emitMany(handler, isFn, this, args);
        }
        if (needDomainExit)
          domain2.exit();
        return true;
      };
      EventEmitter.prototype.addListener = function addListener2(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      EventEmitter.prototype.once = function once2(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
        var list, events, position, i2, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type];
        if (!list)
          return this;
        if (list === listener || list.listener && list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i2 = list.length; i2-- > 0; ) {
            if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
              originalListener = list[i2].listener;
              position = i2;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type];
            }
          } else {
            spliceOne(list, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
        var listeners2, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          for (var i2 = 0, key; i2 < keys.length; ++i2) {
            key = keys[i2];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners2 = events[type];
        if (typeof listeners2 === "function") {
          this.removeListener(type, listeners2);
        } else if (listeners2) {
          do {
            this.removeListener(type, listeners2[listeners2.length - 1]);
          } while (listeners2[0]);
        }
        return this;
      };
      EventEmitter.prototype.listeners = function listeners(type) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }
  });

  // node-modules-polyfills-commonjs:events
  var require_events = __commonJS({
    "node-modules-polyfills-commonjs:events"(exports2, module2) {
      init_virtual_process_polyfill();
      var polyfill = (init_events(), __toCommonJS(events_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k2 in polyfill) {
          module2.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node_modules/catering/next-tick-browser.js
  var require_next_tick_browser = __commonJS({
    "node_modules/catering/next-tick-browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
    }
  });

  // node_modules/catering/index.js
  var require_catering = __commonJS({
    "node_modules/catering/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var nextTick3 = require_next_tick_browser();
      exports2.fromCallback = function(callback, symbol) {
        if (callback === void 0) {
          var promise = new Promise(function(resolve5, reject) {
            callback = function(err, res) {
              if (err)
                reject(err);
              else
                resolve5(res);
            };
          });
          callback[symbol !== void 0 ? symbol : "promise"] = promise;
        } else if (typeof callback !== "function") {
          throw new TypeError("Callback must be a function");
        }
        return callback;
      };
      exports2.fromPromise = function(promise, callback) {
        if (callback === void 0)
          return promise;
        promise.then(function(res) {
          nextTick3(() => callback(null, res));
        }).catch(function(err) {
          nextTick3(() => callback(err));
        });
      };
    }
  });

  // node_modules/abstract-level/lib/common.js
  var require_common = __commonJS({
    "node_modules/abstract-level/lib/common.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      exports2.getCallback = function(options, callback) {
        return typeof options === "function" ? options : callback;
      };
      exports2.getOptions = function(options, def) {
        if (typeof options === "object" && options !== null) {
          return options;
        }
        if (def !== void 0) {
          return def;
        }
        return {};
      };
    }
  });

  // node_modules/abstract-level/abstract-iterator.js
  var require_abstract_iterator = __commonJS({
    "node_modules/abstract-level/abstract-iterator.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { fromCallback } = require_catering();
      var ModuleError = require_module_error();
      var { getOptions, getCallback } = require_common();
      var kPromise = Symbol("promise");
      var kCallback = Symbol("callback");
      var kWorking = Symbol("working");
      var kHandleOne = Symbol("handleOne");
      var kHandleMany = Symbol("handleMany");
      var kAutoClose = Symbol("autoClose");
      var kFinishWork = Symbol("finishWork");
      var kReturnMany = Symbol("returnMany");
      var kClosing = Symbol("closing");
      var kHandleClose = Symbol("handleClose");
      var kClosed = Symbol("closed");
      var kCloseCallbacks = Symbol("closeCallbacks");
      var kKeyEncoding = Symbol("keyEncoding");
      var kValueEncoding = Symbol("valueEncoding");
      var kAbortOnClose = Symbol("abortOnClose");
      var kLegacy = Symbol("legacy");
      var kKeys = Symbol("keys");
      var kValues = Symbol("values");
      var kLimit = Symbol("limit");
      var kCount = Symbol("count");
      var emptyOptions = Object.freeze({});
      var noop3 = () => {
      };
      var warnedEnd = false;
      var CommonIterator = class {
        constructor(db, options, legacy) {
          if (typeof db !== "object" || db === null) {
            const hint = db === null ? "null" : typeof db;
            throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
          }
          if (typeof options !== "object" || options === null) {
            throw new TypeError("The second argument must be an options object");
          }
          this[kClosed] = false;
          this[kCloseCallbacks] = [];
          this[kWorking] = false;
          this[kClosing] = false;
          this[kAutoClose] = false;
          this[kCallback] = null;
          this[kHandleOne] = this[kHandleOne].bind(this);
          this[kHandleMany] = this[kHandleMany].bind(this);
          this[kHandleClose] = this[kHandleClose].bind(this);
          this[kKeyEncoding] = options[kKeyEncoding];
          this[kValueEncoding] = options[kValueEncoding];
          this[kLegacy] = legacy;
          this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
          this[kCount] = 0;
          this[kAbortOnClose] = !!options.abortOnClose;
          this.db = db;
          this.db.attachResource(this);
          this.nextTick = db.nextTick;
        }
        get count() {
          return this[kCount];
        }
        get limit() {
          return this[kLimit];
        }
        next(callback) {
          let promise;
          if (callback === void 0) {
            promise = new Promise((resolve5, reject) => {
              callback = (err, key, value) => {
                if (err)
                  reject(err);
                else if (!this[kLegacy])
                  resolve5(key);
                else if (key === void 0 && value === void 0)
                  resolve5();
                else
                  resolve5([key, value]);
              };
            });
          } else if (typeof callback !== "function") {
            throw new TypeError("Callback must be a function");
          }
          if (this[kClosing]) {
            this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          } else if (this[kWorking]) {
            this.nextTick(callback, new ModuleError("Iterator is busy: cannot call next() until previous call has completed", {
              code: "LEVEL_ITERATOR_BUSY"
            }));
          } else {
            this[kWorking] = true;
            this[kCallback] = callback;
            if (this[kCount] >= this[kLimit])
              this.nextTick(this[kHandleOne], null);
            else
              this._next(this[kHandleOne]);
          }
          return promise;
        }
        _next(callback) {
          this.nextTick(callback);
        }
        nextv(size, options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, emptyOptions);
          if (!Number.isInteger(size)) {
            this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
            return callback[kPromise];
          }
          if (this[kClosing]) {
            this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          } else if (this[kWorking]) {
            this.nextTick(callback, new ModuleError("Iterator is busy: cannot call nextv() until previous call has completed", {
              code: "LEVEL_ITERATOR_BUSY"
            }));
          } else {
            if (size < 1)
              size = 1;
            if (this[kLimit] < Infinity)
              size = Math.min(size, this[kLimit] - this[kCount]);
            this[kWorking] = true;
            this[kCallback] = callback;
            if (size <= 0)
              this.nextTick(this[kHandleMany], null, []);
            else
              this._nextv(size, options, this[kHandleMany]);
          }
          return callback[kPromise];
        }
        _nextv(size, options, callback) {
          const acc = [];
          const onnext = (err, key, value) => {
            if (err) {
              return callback(err);
            } else if (this[kLegacy] ? key === void 0 && value === void 0 : key === void 0) {
              return callback(null, acc);
            }
            acc.push(this[kLegacy] ? [key, value] : key);
            if (acc.length === size) {
              callback(null, acc);
            } else {
              this._next(onnext);
            }
          };
          this._next(onnext);
        }
        all(options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, emptyOptions);
          if (this[kClosing]) {
            this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          } else if (this[kWorking]) {
            this.nextTick(callback, new ModuleError("Iterator is busy: cannot call all() until previous call has completed", {
              code: "LEVEL_ITERATOR_BUSY"
            }));
          } else {
            this[kWorking] = true;
            this[kCallback] = callback;
            this[kAutoClose] = true;
            if (this[kCount] >= this[kLimit])
              this.nextTick(this[kHandleMany], null, []);
            else
              this._all(options, this[kHandleMany]);
          }
          return callback[kPromise];
        }
        _all(options, callback) {
          let count = this[kCount];
          const acc = [];
          const nextv = () => {
            const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
            if (size <= 0) {
              this.nextTick(callback, null, acc);
            } else {
              this._nextv(size, emptyOptions, onnextv);
            }
          };
          const onnextv = (err, items) => {
            if (err) {
              callback(err);
            } else if (items.length === 0) {
              callback(null, acc);
            } else {
              acc.push.apply(acc, items);
              count += items.length;
              nextv();
            }
          };
          nextv();
        }
        [kFinishWork]() {
          const cb = this[kCallback];
          if (this[kAbortOnClose] && cb === null)
            return noop3;
          this[kWorking] = false;
          this[kCallback] = null;
          if (this[kClosing])
            this._close(this[kHandleClose]);
          return cb;
        }
        [kReturnMany](cb, err, items) {
          if (this[kAutoClose]) {
            this.close(cb.bind(null, err, items));
          } else {
            cb(err, items);
          }
        }
        seek(target, options) {
          options = getOptions(options, emptyOptions);
          if (this[kClosing]) {
          } else if (this[kWorking]) {
            throw new ModuleError("Iterator is busy: cannot call seek() until next() has completed", {
              code: "LEVEL_ITERATOR_BUSY"
            });
          } else {
            const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding]);
            const keyFormat = keyEncoding.format;
            if (options.keyEncoding !== keyFormat) {
              options = { ...options, keyEncoding: keyFormat };
            }
            const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
            this._seek(mapped, options);
          }
        }
        _seek(target, options) {
          throw new ModuleError("Iterator does not support seek()", {
            code: "LEVEL_NOT_SUPPORTED"
          });
        }
        close(callback) {
          callback = fromCallback(callback, kPromise);
          if (this[kClosed]) {
            this.nextTick(callback);
          } else if (this[kClosing]) {
            this[kCloseCallbacks].push(callback);
          } else {
            this[kClosing] = true;
            this[kCloseCallbacks].push(callback);
            if (!this[kWorking]) {
              this._close(this[kHandleClose]);
            } else if (this[kAbortOnClose]) {
              const cb = this[kFinishWork]();
              cb(new ModuleError("Aborted on iterator close()", {
                code: "LEVEL_ITERATOR_NOT_OPEN"
              }));
            }
          }
          return callback[kPromise];
        }
        _close(callback) {
          this.nextTick(callback);
        }
        [kHandleClose]() {
          this[kClosed] = true;
          this.db.detachResource(this);
          const callbacks = this[kCloseCallbacks];
          this[kCloseCallbacks] = [];
          for (const cb of callbacks) {
            cb();
          }
        }
        async *[Symbol.asyncIterator]() {
          try {
            let item;
            while ((item = await this.next()) !== void 0) {
              yield item;
            }
          } finally {
            if (!this[kClosed])
              await this.close();
          }
        }
      };
      var AbstractIterator = class extends CommonIterator {
        constructor(db, options) {
          super(db, options, true);
          this[kKeys] = options.keys !== false;
          this[kValues] = options.values !== false;
        }
        [kHandleOne](err, key, value) {
          const cb = this[kFinishWork]();
          if (err)
            return cb(err);
          try {
            key = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
            value = this[kValues] && value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
          } catch (err2) {
            return cb(new IteratorDecodeError("entry", err2));
          }
          if (!(key === void 0 && value === void 0)) {
            this[kCount]++;
          }
          cb(null, key, value);
        }
        [kHandleMany](err, entries) {
          const cb = this[kFinishWork]();
          if (err)
            return this[kReturnMany](cb, err);
          try {
            for (const entry of entries) {
              const key = entry[0];
              const value = entry[1];
              entry[0] = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
              entry[1] = this[kValues] && value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
            }
          } catch (err2) {
            return this[kReturnMany](cb, new IteratorDecodeError("entries", err2));
          }
          this[kCount] += entries.length;
          this[kReturnMany](cb, null, entries);
        }
        end(callback) {
          if (!warnedEnd && typeof console !== "undefined") {
            warnedEnd = true;
            console.warn(new ModuleError(
              "The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",
              { code: "LEVEL_LEGACY" }
            ));
          }
          return this.close(callback);
        }
      };
      var AbstractKeyIterator = class extends CommonIterator {
        constructor(db, options) {
          super(db, options, false);
        }
        [kHandleOne](err, key) {
          const cb = this[kFinishWork]();
          if (err)
            return cb(err);
          try {
            key = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          } catch (err2) {
            return cb(new IteratorDecodeError("key", err2));
          }
          if (key !== void 0)
            this[kCount]++;
          cb(null, key);
        }
        [kHandleMany](err, keys) {
          const cb = this[kFinishWork]();
          if (err)
            return this[kReturnMany](cb, err);
          try {
            for (let i2 = 0; i2 < keys.length; i2++) {
              const key = keys[i2];
              keys[i2] = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
            }
          } catch (err2) {
            return this[kReturnMany](cb, new IteratorDecodeError("keys", err2));
          }
          this[kCount] += keys.length;
          this[kReturnMany](cb, null, keys);
        }
      };
      var AbstractValueIterator = class extends CommonIterator {
        constructor(db, options) {
          super(db, options, false);
        }
        [kHandleOne](err, value) {
          const cb = this[kFinishWork]();
          if (err)
            return cb(err);
          try {
            value = value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
          } catch (err2) {
            return cb(new IteratorDecodeError("value", err2));
          }
          if (value !== void 0)
            this[kCount]++;
          cb(null, value);
        }
        [kHandleMany](err, values) {
          const cb = this[kFinishWork]();
          if (err)
            return this[kReturnMany](cb, err);
          try {
            for (let i2 = 0; i2 < values.length; i2++) {
              const value = values[i2];
              values[i2] = value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
            }
          } catch (err2) {
            return this[kReturnMany](cb, new IteratorDecodeError("values", err2));
          }
          this[kCount] += values.length;
          this[kReturnMany](cb, null, values);
        }
      };
      var IteratorDecodeError = class extends ModuleError {
        constructor(subject, cause) {
          super(`Iterator could not decode ${subject}`, {
            code: "LEVEL_DECODE_ERROR",
            cause
          });
        }
      };
      for (const k2 of ["_ended property", "_nexting property", "_end method"]) {
        Object.defineProperty(AbstractIterator.prototype, k2.split(" ")[0], {
          get() {
            throw new ModuleError(`The ${k2} has been removed`, { code: "LEVEL_LEGACY" });
          },
          set() {
            throw new ModuleError(`The ${k2} has been removed`, { code: "LEVEL_LEGACY" });
          }
        });
      }
      AbstractIterator.keyEncoding = kKeyEncoding;
      AbstractIterator.valueEncoding = kValueEncoding;
      exports2.AbstractIterator = AbstractIterator;
      exports2.AbstractKeyIterator = AbstractKeyIterator;
      exports2.AbstractValueIterator = AbstractValueIterator;
    }
  });

  // node_modules/abstract-level/lib/default-kv-iterator.js
  var require_default_kv_iterator = __commonJS({
    "node_modules/abstract-level/lib/default-kv-iterator.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
      var kIterator = Symbol("iterator");
      var kCallback = Symbol("callback");
      var kHandleOne = Symbol("handleOne");
      var kHandleMany = Symbol("handleMany");
      var DefaultKeyIterator = class extends AbstractKeyIterator {
        constructor(db, options) {
          super(db, options);
          this[kIterator] = db.iterator({ ...options, keys: true, values: false });
          this[kHandleOne] = this[kHandleOne].bind(this);
          this[kHandleMany] = this[kHandleMany].bind(this);
        }
      };
      var DefaultValueIterator = class extends AbstractValueIterator {
        constructor(db, options) {
          super(db, options);
          this[kIterator] = db.iterator({ ...options, keys: false, values: true });
          this[kHandleOne] = this[kHandleOne].bind(this);
          this[kHandleMany] = this[kHandleMany].bind(this);
        }
      };
      for (const Iterator of [DefaultKeyIterator, DefaultValueIterator]) {
        const keys = Iterator === DefaultKeyIterator;
        const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];
        Iterator.prototype._next = function(callback) {
          this[kCallback] = callback;
          this[kIterator].next(this[kHandleOne]);
        };
        Iterator.prototype[kHandleOne] = function(err, key, value) {
          const callback = this[kCallback];
          if (err)
            callback(err);
          else
            callback(null, keys ? key : value);
        };
        Iterator.prototype._nextv = function(size, options, callback) {
          this[kCallback] = callback;
          this[kIterator].nextv(size, options, this[kHandleMany]);
        };
        Iterator.prototype._all = function(options, callback) {
          this[kCallback] = callback;
          this[kIterator].all(options, this[kHandleMany]);
        };
        Iterator.prototype[kHandleMany] = function(err, entries) {
          const callback = this[kCallback];
          if (err)
            callback(err);
          else
            callback(null, entries.map(mapEntry));
        };
        Iterator.prototype._seek = function(target, options) {
          this[kIterator].seek(target, options);
        };
        Iterator.prototype._close = function(callback) {
          this[kIterator].close(callback);
        };
      }
      exports2.DefaultKeyIterator = DefaultKeyIterator;
      exports2.DefaultValueIterator = DefaultValueIterator;
    }
  });

  // node_modules/abstract-level/lib/deferred-iterator.js
  var require_deferred_iterator = __commonJS({
    "node_modules/abstract-level/lib/deferred-iterator.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
      var ModuleError = require_module_error();
      var kNut = Symbol("nut");
      var kUndefer = Symbol("undefer");
      var kFactory = Symbol("factory");
      var DeferredIterator = class extends AbstractIterator {
        constructor(db, options) {
          super(db, options);
          this[kNut] = null;
          this[kFactory] = () => db.iterator(options);
          this.db.defer(() => this[kUndefer]());
        }
      };
      var DeferredKeyIterator = class extends AbstractKeyIterator {
        constructor(db, options) {
          super(db, options);
          this[kNut] = null;
          this[kFactory] = () => db.keys(options);
          this.db.defer(() => this[kUndefer]());
        }
      };
      var DeferredValueIterator = class extends AbstractValueIterator {
        constructor(db, options) {
          super(db, options);
          this[kNut] = null;
          this[kFactory] = () => db.values(options);
          this.db.defer(() => this[kUndefer]());
        }
      };
      for (const Iterator of [DeferredIterator, DeferredKeyIterator, DeferredValueIterator]) {
        Iterator.prototype[kUndefer] = function() {
          if (this.db.status === "open") {
            this[kNut] = this[kFactory]();
          }
        };
        Iterator.prototype._next = function(callback) {
          if (this[kNut] !== null) {
            this[kNut].next(callback);
          } else if (this.db.status === "opening") {
            this.db.defer(() => this._next(callback));
          } else {
            this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          }
        };
        Iterator.prototype._nextv = function(size, options, callback) {
          if (this[kNut] !== null) {
            this[kNut].nextv(size, options, callback);
          } else if (this.db.status === "opening") {
            this.db.defer(() => this._nextv(size, options, callback));
          } else {
            this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          }
        };
        Iterator.prototype._all = function(options, callback) {
          if (this[kNut] !== null) {
            this[kNut].all(callback);
          } else if (this.db.status === "opening") {
            this.db.defer(() => this._all(options, callback));
          } else {
            this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          }
        };
        Iterator.prototype._seek = function(target, options) {
          if (this[kNut] !== null) {
            this[kNut]._seek(target, options);
          } else if (this.db.status === "opening") {
            this.db.defer(() => this._seek(target, options));
          }
        };
        Iterator.prototype._close = function(callback) {
          if (this[kNut] !== null) {
            this[kNut].close(callback);
          } else if (this.db.status === "opening") {
            this.db.defer(() => this._close(callback));
          } else {
            this.nextTick(callback);
          }
        };
      }
      exports2.DeferredIterator = DeferredIterator;
      exports2.DeferredKeyIterator = DeferredKeyIterator;
      exports2.DeferredValueIterator = DeferredValueIterator;
    }
  });

  // node_modules/abstract-level/abstract-chained-batch.js
  var require_abstract_chained_batch = __commonJS({
    "node_modules/abstract-level/abstract-chained-batch.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { fromCallback } = require_catering();
      var ModuleError = require_module_error();
      var { getCallback, getOptions } = require_common();
      var kPromise = Symbol("promise");
      var kStatus = Symbol("status");
      var kOperations = Symbol("operations");
      var kFinishClose = Symbol("finishClose");
      var kCloseCallbacks = Symbol("closeCallbacks");
      var AbstractChainedBatch = class {
        constructor(db) {
          if (typeof db !== "object" || db === null) {
            const hint = db === null ? "null" : typeof db;
            throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
          }
          this[kOperations] = [];
          this[kCloseCallbacks] = [];
          this[kStatus] = "open";
          this[kFinishClose] = this[kFinishClose].bind(this);
          this.db = db;
          this.db.attachResource(this);
          this.nextTick = db.nextTick;
        }
        get length() {
          return this[kOperations].length;
        }
        put(key, value, options) {
          if (this[kStatus] !== "open") {
            throw new ModuleError("Batch is not open: cannot call put() after write() or close()", {
              code: "LEVEL_BATCH_NOT_OPEN"
            });
          }
          const err = this.db._checkKey(key) || this.db._checkValue(value);
          if (err)
            throw err;
          const db = options && options.sublevel != null ? options.sublevel : this.db;
          const original = options;
          const keyEncoding = db.keyEncoding(options && options.keyEncoding);
          const valueEncoding = db.valueEncoding(options && options.valueEncoding);
          const keyFormat = keyEncoding.format;
          options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };
          if (db !== this.db) {
            options.sublevel = null;
          }
          const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
          const mappedValue = valueEncoding.encode(value);
          this._put(mappedKey, mappedValue, options);
          this[kOperations].push({ ...original, type: "put", key, value });
          return this;
        }
        _put(key, value, options) {
        }
        del(key, options) {
          if (this[kStatus] !== "open") {
            throw new ModuleError("Batch is not open: cannot call del() after write() or close()", {
              code: "LEVEL_BATCH_NOT_OPEN"
            });
          }
          const err = this.db._checkKey(key);
          if (err)
            throw err;
          const db = options && options.sublevel != null ? options.sublevel : this.db;
          const original = options;
          const keyEncoding = db.keyEncoding(options && options.keyEncoding);
          const keyFormat = keyEncoding.format;
          options = { ...options, keyEncoding: keyFormat };
          if (db !== this.db) {
            options.sublevel = null;
          }
          this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
          this[kOperations].push({ ...original, type: "del", key });
          return this;
        }
        _del(key, options) {
        }
        clear() {
          if (this[kStatus] !== "open") {
            throw new ModuleError("Batch is not open: cannot call clear() after write() or close()", {
              code: "LEVEL_BATCH_NOT_OPEN"
            });
          }
          this._clear();
          this[kOperations] = [];
          return this;
        }
        _clear() {
        }
        write(options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options);
          if (this[kStatus] !== "open") {
            this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
              code: "LEVEL_BATCH_NOT_OPEN"
            }));
          } else if (this.length === 0) {
            this.close(callback);
          } else {
            this[kStatus] = "writing";
            this._write(options, (err) => {
              this[kStatus] = "closing";
              this[kCloseCallbacks].push(() => callback(err));
              if (!err)
                this.db.emit("batch", this[kOperations]);
              this._close(this[kFinishClose]);
            });
          }
          return callback[kPromise];
        }
        _write(options, callback) {
        }
        close(callback) {
          callback = fromCallback(callback, kPromise);
          if (this[kStatus] === "closing") {
            this[kCloseCallbacks].push(callback);
          } else if (this[kStatus] === "closed") {
            this.nextTick(callback);
          } else {
            this[kCloseCallbacks].push(callback);
            if (this[kStatus] !== "writing") {
              this[kStatus] = "closing";
              this._close(this[kFinishClose]);
            }
          }
          return callback[kPromise];
        }
        _close(callback) {
          this.nextTick(callback);
        }
        [kFinishClose]() {
          this[kStatus] = "closed";
          this.db.detachResource(this);
          const callbacks = this[kCloseCallbacks];
          this[kCloseCallbacks] = [];
          for (const cb of callbacks) {
            cb();
          }
        }
      };
      exports2.AbstractChainedBatch = AbstractChainedBatch;
    }
  });

  // node_modules/abstract-level/lib/default-chained-batch.js
  var require_default_chained_batch = __commonJS({
    "node_modules/abstract-level/lib/default-chained-batch.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractChainedBatch } = require_abstract_chained_batch();
      var ModuleError = require_module_error();
      var kEncoded = Symbol("encoded");
      var DefaultChainedBatch = class extends AbstractChainedBatch {
        constructor(db) {
          super(db);
          this[kEncoded] = [];
        }
        _put(key, value, options) {
          this[kEncoded].push({ ...options, type: "put", key, value });
        }
        _del(key, options) {
          this[kEncoded].push({ ...options, type: "del", key });
        }
        _clear() {
          this[kEncoded] = [];
        }
        _write(options, callback) {
          if (this.db.status === "opening") {
            this.db.defer(() => this._write(options, callback));
          } else if (this.db.status === "open") {
            if (this[kEncoded].length === 0)
              this.nextTick(callback);
            else
              this.db._batch(this[kEncoded], options, callback);
          } else {
            this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
              code: "LEVEL_BATCH_NOT_OPEN"
            }));
          }
        }
      };
      exports2.DefaultChainedBatch = DefaultChainedBatch;
    }
  });

  // node_modules/abstract-level/lib/range-options.js
  var require_range_options = __commonJS({
    "node_modules/abstract-level/lib/range-options.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var ModuleError = require_module_error();
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var rangeOptions = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
      module2.exports = function(options, keyEncoding) {
        const result = {};
        for (const k2 in options) {
          if (!hasOwnProperty2.call(options, k2))
            continue;
          if (k2 === "keyEncoding" || k2 === "valueEncoding")
            continue;
          if (k2 === "start" || k2 === "end") {
            throw new ModuleError(`The legacy range option '${k2}' has been removed`, {
              code: "LEVEL_LEGACY"
            });
          } else if (k2 === "encoding") {
            throw new ModuleError("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
              code: "LEVEL_LEGACY"
            });
          }
          if (rangeOptions.has(k2)) {
            result[k2] = keyEncoding.encode(options[k2]);
          } else {
            result[k2] = options[k2];
          }
        }
        result.reverse = !!result.reverse;
        result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
        return result;
      };
    }
  });

  // node_modules/queue-microtask/index.js
  var require_queue_microtask = __commonJS({
    "node_modules/queue-microtask/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var promise;
      module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    }
  });

  // node_modules/abstract-level/lib/next-tick-browser.js
  var require_next_tick_browser2 = __commonJS({
    "node_modules/abstract-level/lib/next-tick-browser.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var queueMicrotask2 = require_queue_microtask();
      module2.exports = function(fn, ...args) {
        if (args.length === 0) {
          queueMicrotask2(fn);
        } else {
          queueMicrotask2(() => fn(...args));
        }
      };
    }
  });

  // node_modules/abstract-level/lib/abstract-sublevel-iterator.js
  var require_abstract_sublevel_iterator = __commonJS({
    "node_modules/abstract-level/lib/abstract-sublevel-iterator.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
      var kUnfix = Symbol("unfix");
      var kIterator = Symbol("iterator");
      var kHandleOne = Symbol("handleOne");
      var kHandleMany = Symbol("handleMany");
      var kCallback = Symbol("callback");
      var AbstractSublevelIterator = class extends AbstractIterator {
        constructor(db, options, iterator, unfix) {
          super(db, options);
          this[kIterator] = iterator;
          this[kUnfix] = unfix;
          this[kHandleOne] = this[kHandleOne].bind(this);
          this[kHandleMany] = this[kHandleMany].bind(this);
          this[kCallback] = null;
        }
        [kHandleOne](err, key, value) {
          const callback = this[kCallback];
          if (err)
            return callback(err);
          if (key !== void 0)
            key = this[kUnfix](key);
          callback(err, key, value);
        }
        [kHandleMany](err, entries) {
          const callback = this[kCallback];
          if (err)
            return callback(err);
          for (const entry of entries) {
            const key = entry[0];
            if (key !== void 0)
              entry[0] = this[kUnfix](key);
          }
          callback(err, entries);
        }
      };
      var AbstractSublevelKeyIterator = class extends AbstractKeyIterator {
        constructor(db, options, iterator, unfix) {
          super(db, options);
          this[kIterator] = iterator;
          this[kUnfix] = unfix;
          this[kHandleOne] = this[kHandleOne].bind(this);
          this[kHandleMany] = this[kHandleMany].bind(this);
          this[kCallback] = null;
        }
        [kHandleOne](err, key) {
          const callback = this[kCallback];
          if (err)
            return callback(err);
          if (key !== void 0)
            key = this[kUnfix](key);
          callback(err, key);
        }
        [kHandleMany](err, keys) {
          const callback = this[kCallback];
          if (err)
            return callback(err);
          for (let i2 = 0; i2 < keys.length; i2++) {
            const key = keys[i2];
            if (key !== void 0)
              keys[i2] = this[kUnfix](key);
          }
          callback(err, keys);
        }
      };
      var AbstractSublevelValueIterator = class extends AbstractValueIterator {
        constructor(db, options, iterator) {
          super(db, options);
          this[kIterator] = iterator;
        }
      };
      for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {
        Iterator.prototype._next = function(callback) {
          this[kCallback] = callback;
          this[kIterator].next(this[kHandleOne]);
        };
        Iterator.prototype._nextv = function(size, options, callback) {
          this[kCallback] = callback;
          this[kIterator].nextv(size, options, this[kHandleMany]);
        };
        Iterator.prototype._all = function(options, callback) {
          this[kCallback] = callback;
          this[kIterator].all(options, this[kHandleMany]);
        };
      }
      for (const Iterator of [AbstractSublevelValueIterator]) {
        Iterator.prototype._next = function(callback) {
          this[kIterator].next(callback);
        };
        Iterator.prototype._nextv = function(size, options, callback) {
          this[kIterator].nextv(size, options, callback);
        };
        Iterator.prototype._all = function(options, callback) {
          this[kIterator].all(options, callback);
        };
      }
      for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {
        Iterator.prototype._seek = function(target, options) {
          this[kIterator].seek(target, options);
        };
        Iterator.prototype._close = function(callback) {
          this[kIterator].close(callback);
        };
      }
      exports2.AbstractSublevelIterator = AbstractSublevelIterator;
      exports2.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
      exports2.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
    }
  });

  // node_modules/abstract-level/lib/abstract-sublevel.js
  var require_abstract_sublevel = __commonJS({
    "node_modules/abstract-level/lib/abstract-sublevel.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var ModuleError = require_module_error();
      var { Buffer: Buffer3 } = require_buffer() || {};
      var {
        AbstractSublevelIterator,
        AbstractSublevelKeyIterator,
        AbstractSublevelValueIterator
      } = require_abstract_sublevel_iterator();
      var kPrefix = Symbol("prefix");
      var kUpperBound = Symbol("upperBound");
      var kPrefixRange = Symbol("prefixRange");
      var kParent = Symbol("parent");
      var kUnfix = Symbol("unfix");
      var textEncoder6 = new TextEncoder();
      var defaults = { separator: "!" };
      module2.exports = function({ AbstractLevel }) {
        class AbstractSublevel extends AbstractLevel {
          static defaults(options) {
            if (typeof options === "string") {
              throw new ModuleError("The subleveldown string shorthand for { separator } has been removed", {
                code: "LEVEL_LEGACY"
              });
            } else if (options && options.open) {
              throw new ModuleError("The subleveldown open option has been removed", {
                code: "LEVEL_LEGACY"
              });
            }
            if (options == null) {
              return defaults;
            } else if (!options.separator) {
              return { ...options, separator: "!" };
            } else {
              return options;
            }
          }
          constructor(db, name6, options) {
            const { separator, manifest, ...forward } = AbstractSublevel.defaults(options);
            name6 = trim(name6, separator);
            const reserved = separator.charCodeAt(0) + 1;
            const parent = db[kParent] || db;
            if (!textEncoder6.encode(name6).every((x2) => x2 > reserved && x2 < 127)) {
              throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {
                code: "LEVEL_INVALID_PREFIX"
              });
            }
            super(mergeManifests(parent, manifest), forward);
            const prefix = (db.prefix || "") + separator + name6 + separator;
            const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
            this[kParent] = parent;
            this[kPrefix] = new MultiFormat(prefix);
            this[kUpperBound] = new MultiFormat(upperBound);
            this[kUnfix] = new Unfixer();
            this.nextTick = parent.nextTick;
          }
          prefixKey(key, keyFormat) {
            if (keyFormat === "utf8") {
              return this[kPrefix].utf8 + key;
            } else if (key.byteLength === 0) {
              return this[kPrefix][keyFormat];
            } else if (keyFormat === "view") {
              const view = this[kPrefix].view;
              const result = new Uint8Array(view.byteLength + key.byteLength);
              result.set(view, 0);
              result.set(key, view.byteLength);
              return result;
            } else {
              const buffer2 = this[kPrefix].buffer;
              return Buffer3.concat([buffer2, key], buffer2.byteLength + key.byteLength);
            }
          }
          [kPrefixRange](range, keyFormat) {
            if (range.gte !== void 0) {
              range.gte = this.prefixKey(range.gte, keyFormat);
            } else if (range.gt !== void 0) {
              range.gt = this.prefixKey(range.gt, keyFormat);
            } else {
              range.gte = this[kPrefix][keyFormat];
            }
            if (range.lte !== void 0) {
              range.lte = this.prefixKey(range.lte, keyFormat);
            } else if (range.lt !== void 0) {
              range.lt = this.prefixKey(range.lt, keyFormat);
            } else {
              range.lte = this[kUpperBound][keyFormat];
            }
          }
          get prefix() {
            return this[kPrefix].utf8;
          }
          get db() {
            return this[kParent];
          }
          _open(options, callback) {
            this[kParent].open({ passive: true }, callback);
          }
          _put(key, value, options, callback) {
            this[kParent].put(key, value, options, callback);
          }
          _get(key, options, callback) {
            this[kParent].get(key, options, callback);
          }
          _getMany(keys, options, callback) {
            this[kParent].getMany(keys, options, callback);
          }
          _del(key, options, callback) {
            this[kParent].del(key, options, callback);
          }
          _batch(operations, options, callback) {
            this[kParent].batch(operations, options, callback);
          }
          _clear(options, callback) {
            this[kPrefixRange](options, options.keyEncoding);
            this[kParent].clear(options, callback);
          }
          _iterator(options) {
            this[kPrefixRange](options, options.keyEncoding);
            const iterator = this[kParent].iterator(options);
            const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
            return new AbstractSublevelIterator(this, options, iterator, unfix);
          }
          _keys(options) {
            this[kPrefixRange](options, options.keyEncoding);
            const iterator = this[kParent].keys(options);
            const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
            return new AbstractSublevelKeyIterator(this, options, iterator, unfix);
          }
          _values(options) {
            this[kPrefixRange](options, options.keyEncoding);
            const iterator = this[kParent].values(options);
            return new AbstractSublevelValueIterator(this, options, iterator);
          }
        }
        return { AbstractSublevel };
      };
      var mergeManifests = function(parent, manifest) {
        return {
          ...parent.supports,
          createIfMissing: false,
          errorIfExists: false,
          events: {},
          additionalMethods: {},
          ...manifest,
          encodings: {
            utf8: supportsEncoding(parent, "utf8"),
            buffer: supportsEncoding(parent, "buffer"),
            view: supportsEncoding(parent, "view")
          }
        };
      };
      var supportsEncoding = function(parent, encoding) {
        return parent.supports.encodings[encoding] ? parent.keyEncoding(encoding).name === encoding : false;
      };
      var MultiFormat = class {
        constructor(key) {
          this.utf8 = key;
          this.view = textEncoder6.encode(key);
          this.buffer = Buffer3 ? Buffer3.from(this.view.buffer, 0, this.view.byteLength) : {};
        }
      };
      var Unfixer = class {
        constructor() {
          this.cache = /* @__PURE__ */ new Map();
        }
        get(prefixLength, keyFormat) {
          let unfix = this.cache.get(keyFormat);
          if (unfix === void 0) {
            if (keyFormat === "view") {
              unfix = function(prefixLength2, key) {
                return key.subarray(prefixLength2);
              }.bind(null, prefixLength);
            } else {
              unfix = function(prefixLength2, key) {
                return key.slice(prefixLength2);
              }.bind(null, prefixLength);
            }
            this.cache.set(keyFormat, unfix);
          }
          return unfix;
        }
      };
      var trim = function(str, char) {
        let start = 0;
        let end = str.length;
        while (start < end && str[start] === char)
          start++;
        while (end > start && str[end - 1] === char)
          end--;
        return str.slice(start, end);
      };
    }
  });

  // node_modules/abstract-level/abstract-level.js
  var require_abstract_level = __commonJS({
    "node_modules/abstract-level/abstract-level.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { supports } = require_level_supports();
      var { Transcoder } = require_level_transcoder();
      var { EventEmitter: EventEmitter3 } = require_events();
      var { fromCallback } = require_catering();
      var ModuleError = require_module_error();
      var { AbstractIterator } = require_abstract_iterator();
      var { DefaultKeyIterator, DefaultValueIterator } = require_default_kv_iterator();
      var { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require_deferred_iterator();
      var { DefaultChainedBatch } = require_default_chained_batch();
      var { getCallback, getOptions } = require_common();
      var rangeOptions = require_range_options();
      var kPromise = Symbol("promise");
      var kLanded = Symbol("landed");
      var kResources = Symbol("resources");
      var kCloseResources = Symbol("closeResources");
      var kOperations = Symbol("operations");
      var kUndefer = Symbol("undefer");
      var kDeferOpen = Symbol("deferOpen");
      var kOptions = Symbol("options");
      var kStatus = Symbol("status");
      var kDefaultOptions = Symbol("defaultOptions");
      var kTranscoder = Symbol("transcoder");
      var kKeyEncoding = Symbol("keyEncoding");
      var kValueEncoding = Symbol("valueEncoding");
      var noop3 = () => {
      };
      var AbstractLevel = class extends EventEmitter3 {
        constructor(manifest, options) {
          super();
          if (typeof manifest !== "object" || manifest === null) {
            throw new TypeError("The first argument 'manifest' must be an object");
          }
          options = getOptions(options);
          const { keyEncoding, valueEncoding, passive, ...forward } = options;
          this[kResources] = /* @__PURE__ */ new Set();
          this[kOperations] = [];
          this[kDeferOpen] = true;
          this[kOptions] = forward;
          this[kStatus] = "opening";
          this.supports = supports(manifest, {
            status: true,
            promises: true,
            clear: true,
            getMany: true,
            deferredOpen: true,
            snapshots: manifest.snapshots !== false,
            permanence: manifest.permanence !== false,
            keyIterator: true,
            valueIterator: true,
            iteratorNextv: true,
            iteratorAll: true,
            encodings: manifest.encodings || {},
            events: Object.assign({}, manifest.events, {
              opening: true,
              open: true,
              closing: true,
              closed: true,
              put: true,
              del: true,
              batch: true,
              clear: true
            })
          });
          this[kTranscoder] = new Transcoder(formats(this));
          this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || "utf8");
          this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || "utf8");
          for (const encoding of this[kTranscoder].encodings()) {
            if (!this.supports.encodings[encoding.commonName]) {
              this.supports.encodings[encoding.commonName] = true;
            }
          }
          this[kDefaultOptions] = {
            empty: Object.freeze({}),
            entry: Object.freeze({
              keyEncoding: this[kKeyEncoding].commonName,
              valueEncoding: this[kValueEncoding].commonName
            }),
            key: Object.freeze({
              keyEncoding: this[kKeyEncoding].commonName
            })
          };
          this.nextTick(() => {
            if (this[kDeferOpen]) {
              this.open({ passive: false }, noop3);
            }
          });
        }
        get status() {
          return this[kStatus];
        }
        keyEncoding(encoding) {
          return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);
        }
        valueEncoding(encoding) {
          return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);
        }
        open(options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = { ...this[kOptions], ...getOptions(options) };
          options.createIfMissing = options.createIfMissing !== false;
          options.errorIfExists = !!options.errorIfExists;
          const maybeOpened = (err) => {
            if (this[kStatus] === "closing" || this[kStatus] === "opening") {
              this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened);
            } else if (this[kStatus] !== "open") {
              callback(new ModuleError("Database is not open", {
                code: "LEVEL_DATABASE_NOT_OPEN",
                cause: err
              }));
            } else {
              callback();
            }
          };
          if (options.passive) {
            if (this[kStatus] === "opening") {
              this.once(kLanded, maybeOpened);
            } else {
              this.nextTick(maybeOpened);
            }
          } else if (this[kStatus] === "closed" || this[kDeferOpen]) {
            this[kDeferOpen] = false;
            this[kStatus] = "opening";
            this.emit("opening");
            this._open(options, (err) => {
              if (err) {
                this[kStatus] = "closed";
                this[kCloseResources](() => {
                  this.emit(kLanded);
                  maybeOpened(err);
                });
                this[kUndefer]();
                return;
              }
              this[kStatus] = "open";
              this[kUndefer]();
              this.emit(kLanded);
              if (this[kStatus] === "open")
                this.emit("open");
              if (this[kStatus] === "open")
                this.emit("ready");
              maybeOpened();
            });
          } else if (this[kStatus] === "open") {
            this.nextTick(maybeOpened);
          } else {
            this.once(kLanded, () => this.open(options, callback));
          }
          return callback[kPromise];
        }
        _open(options, callback) {
          this.nextTick(callback);
        }
        close(callback) {
          callback = fromCallback(callback, kPromise);
          const maybeClosed = (err) => {
            if (this[kStatus] === "opening" || this[kStatus] === "closing") {
              this.once(kLanded, err ? maybeClosed(err) : maybeClosed);
            } else if (this[kStatus] !== "closed") {
              callback(new ModuleError("Database is not closed", {
                code: "LEVEL_DATABASE_NOT_CLOSED",
                cause: err
              }));
            } else {
              callback();
            }
          };
          if (this[kStatus] === "open") {
            this[kStatus] = "closing";
            this.emit("closing");
            const cancel = (err) => {
              this[kStatus] = "open";
              this[kUndefer]();
              this.emit(kLanded);
              maybeClosed(err);
            };
            this[kCloseResources](() => {
              this._close((err) => {
                if (err)
                  return cancel(err);
                this[kStatus] = "closed";
                this[kUndefer]();
                this.emit(kLanded);
                if (this[kStatus] === "closed")
                  this.emit("closed");
                maybeClosed();
              });
            });
          } else if (this[kStatus] === "closed") {
            this.nextTick(maybeClosed);
          } else {
            this.once(kLanded, () => this.close(callback));
          }
          return callback[kPromise];
        }
        [kCloseResources](callback) {
          if (this[kResources].size === 0) {
            return this.nextTick(callback);
          }
          let pending = this[kResources].size;
          let sync = true;
          const next = () => {
            if (--pending === 0) {
              if (sync)
                this.nextTick(callback);
              else
                callback();
            }
          };
          for (const resource of this[kResources]) {
            resource.close(next);
          }
          sync = false;
          this[kResources].clear();
        }
        _close(callback) {
          this.nextTick(callback);
        }
        get(key, options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, this[kDefaultOptions].entry);
          if (this[kStatus] === "opening") {
            this.defer(() => this.get(key, options, callback));
            return callback[kPromise];
          }
          if (maybeError(this, callback)) {
            return callback[kPromise];
          }
          const err = this._checkKey(key);
          if (err) {
            this.nextTick(callback, err);
            return callback[kPromise];
          }
          const keyEncoding = this.keyEncoding(options.keyEncoding);
          const valueEncoding = this.valueEncoding(options.valueEncoding);
          const keyFormat = keyEncoding.format;
          const valueFormat = valueEncoding.format;
          if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
            options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
          }
          this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err2, value) => {
            if (err2) {
              if (err2.code === "LEVEL_NOT_FOUND" || err2.notFound || /NotFound/i.test(err2)) {
                if (!err2.code)
                  err2.code = "LEVEL_NOT_FOUND";
                if (!err2.notFound)
                  err2.notFound = true;
                if (!err2.status)
                  err2.status = 404;
              }
              return callback(err2);
            }
            try {
              value = valueEncoding.decode(value);
            } catch (err3) {
              return callback(new ModuleError("Could not decode value", {
                code: "LEVEL_DECODE_ERROR",
                cause: err3
              }));
            }
            callback(null, value);
          });
          return callback[kPromise];
        }
        _get(key, options, callback) {
          this.nextTick(callback, new Error("NotFound"));
        }
        getMany(keys, options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, this[kDefaultOptions].entry);
          if (this[kStatus] === "opening") {
            this.defer(() => this.getMany(keys, options, callback));
            return callback[kPromise];
          }
          if (maybeError(this, callback)) {
            return callback[kPromise];
          }
          if (!Array.isArray(keys)) {
            this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
            return callback[kPromise];
          }
          if (keys.length === 0) {
            this.nextTick(callback, null, []);
            return callback[kPromise];
          }
          const keyEncoding = this.keyEncoding(options.keyEncoding);
          const valueEncoding = this.valueEncoding(options.valueEncoding);
          const keyFormat = keyEncoding.format;
          const valueFormat = valueEncoding.format;
          if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
            options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
          }
          const mappedKeys = new Array(keys.length);
          for (let i2 = 0; i2 < keys.length; i2++) {
            const key = keys[i2];
            const err = this._checkKey(key);
            if (err) {
              this.nextTick(callback, err);
              return callback[kPromise];
            }
            mappedKeys[i2] = this.prefixKey(keyEncoding.encode(key), keyFormat);
          }
          this._getMany(mappedKeys, options, (err, values) => {
            if (err)
              return callback(err);
            try {
              for (let i2 = 0; i2 < values.length; i2++) {
                if (values[i2] !== void 0) {
                  values[i2] = valueEncoding.decode(values[i2]);
                }
              }
            } catch (err2) {
              return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {
                code: "LEVEL_DECODE_ERROR",
                cause: err2
              }));
            }
            callback(null, values);
          });
          return callback[kPromise];
        }
        _getMany(keys, options, callback) {
          this.nextTick(callback, null, new Array(keys.length).fill(void 0));
        }
        put(key, value, options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, this[kDefaultOptions].entry);
          if (this[kStatus] === "opening") {
            this.defer(() => this.put(key, value, options, callback));
            return callback[kPromise];
          }
          if (maybeError(this, callback)) {
            return callback[kPromise];
          }
          const err = this._checkKey(key) || this._checkValue(value);
          if (err) {
            this.nextTick(callback, err);
            return callback[kPromise];
          }
          const keyEncoding = this.keyEncoding(options.keyEncoding);
          const valueEncoding = this.valueEncoding(options.valueEncoding);
          const keyFormat = keyEncoding.format;
          const valueFormat = valueEncoding.format;
          if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
            options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
          }
          const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
          const mappedValue = valueEncoding.encode(value);
          this._put(mappedKey, mappedValue, options, (err2) => {
            if (err2)
              return callback(err2);
            this.emit("put", key, value);
            callback();
          });
          return callback[kPromise];
        }
        _put(key, value, options, callback) {
          this.nextTick(callback);
        }
        del(key, options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, this[kDefaultOptions].key);
          if (this[kStatus] === "opening") {
            this.defer(() => this.del(key, options, callback));
            return callback[kPromise];
          }
          if (maybeError(this, callback)) {
            return callback[kPromise];
          }
          const err = this._checkKey(key);
          if (err) {
            this.nextTick(callback, err);
            return callback[kPromise];
          }
          const keyEncoding = this.keyEncoding(options.keyEncoding);
          const keyFormat = keyEncoding.format;
          if (options.keyEncoding !== keyFormat) {
            options = Object.assign({}, options, { keyEncoding: keyFormat });
          }
          this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err2) => {
            if (err2)
              return callback(err2);
            this.emit("del", key);
            callback();
          });
          return callback[kPromise];
        }
        _del(key, options, callback) {
          this.nextTick(callback);
        }
        batch(operations, options, callback) {
          if (!arguments.length) {
            if (this[kStatus] === "opening")
              return new DefaultChainedBatch(this);
            if (this[kStatus] !== "open") {
              throw new ModuleError("Database is not open", {
                code: "LEVEL_DATABASE_NOT_OPEN"
              });
            }
            return this._chainedBatch();
          }
          if (typeof operations === "function")
            callback = operations;
          else
            callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, this[kDefaultOptions].empty);
          if (this[kStatus] === "opening") {
            this.defer(() => this.batch(operations, options, callback));
            return callback[kPromise];
          }
          if (maybeError(this, callback)) {
            return callback[kPromise];
          }
          if (!Array.isArray(operations)) {
            this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
            return callback[kPromise];
          }
          if (operations.length === 0) {
            this.nextTick(callback);
            return callback[kPromise];
          }
          const mapped = new Array(operations.length);
          const { keyEncoding: ke2, valueEncoding: ve2, ...forward } = options;
          for (let i2 = 0; i2 < operations.length; i2++) {
            if (typeof operations[i2] !== "object" || operations[i2] === null) {
              this.nextTick(callback, new TypeError("A batch operation must be an object"));
              return callback[kPromise];
            }
            const op = Object.assign({}, operations[i2]);
            if (op.type !== "put" && op.type !== "del") {
              this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
              return callback[kPromise];
            }
            const err = this._checkKey(op.key);
            if (err) {
              this.nextTick(callback, err);
              return callback[kPromise];
            }
            const db = op.sublevel != null ? op.sublevel : this;
            const keyEncoding = db.keyEncoding(op.keyEncoding || ke2);
            const keyFormat = keyEncoding.format;
            op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
            op.keyEncoding = keyFormat;
            if (op.type === "put") {
              const valueErr = this._checkValue(op.value);
              if (valueErr) {
                this.nextTick(callback, valueErr);
                return callback[kPromise];
              }
              const valueEncoding = db.valueEncoding(op.valueEncoding || ve2);
              op.value = valueEncoding.encode(op.value);
              op.valueEncoding = valueEncoding.format;
            }
            if (db !== this) {
              op.sublevel = null;
            }
            mapped[i2] = op;
          }
          this._batch(mapped, forward, (err) => {
            if (err)
              return callback(err);
            this.emit("batch", operations);
            callback();
          });
          return callback[kPromise];
        }
        _batch(operations, options, callback) {
          this.nextTick(callback);
        }
        sublevel(name6, options) {
          return this._sublevel(name6, AbstractSublevel.defaults(options));
        }
        _sublevel(name6, options) {
          return new AbstractSublevel(this, name6, options);
        }
        prefixKey(key, keyFormat) {
          return key;
        }
        clear(options, callback) {
          callback = getCallback(options, callback);
          callback = fromCallback(callback, kPromise);
          options = getOptions(options, this[kDefaultOptions].empty);
          if (this[kStatus] === "opening") {
            this.defer(() => this.clear(options, callback));
            return callback[kPromise];
          }
          if (maybeError(this, callback)) {
            return callback[kPromise];
          }
          const original = options;
          const keyEncoding = this.keyEncoding(options.keyEncoding);
          options = rangeOptions(options, keyEncoding);
          options.keyEncoding = keyEncoding.format;
          if (options.limit === 0) {
            this.nextTick(callback);
          } else {
            this._clear(options, (err) => {
              if (err)
                return callback(err);
              this.emit("clear", original);
              callback();
            });
          }
          return callback[kPromise];
        }
        _clear(options, callback) {
          this.nextTick(callback);
        }
        iterator(options) {
          const keyEncoding = this.keyEncoding(options && options.keyEncoding);
          const valueEncoding = this.valueEncoding(options && options.valueEncoding);
          options = rangeOptions(options, keyEncoding);
          options.keys = options.keys !== false;
          options.values = options.values !== false;
          options[AbstractIterator.keyEncoding] = keyEncoding;
          options[AbstractIterator.valueEncoding] = valueEncoding;
          options.keyEncoding = keyEncoding.format;
          options.valueEncoding = valueEncoding.format;
          if (this[kStatus] === "opening") {
            return new DeferredIterator(this, options);
          } else if (this[kStatus] !== "open") {
            throw new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN"
            });
          }
          return this._iterator(options);
        }
        _iterator(options) {
          return new AbstractIterator(this, options);
        }
        keys(options) {
          const keyEncoding = this.keyEncoding(options && options.keyEncoding);
          const valueEncoding = this.valueEncoding(options && options.valueEncoding);
          options = rangeOptions(options, keyEncoding);
          options[AbstractIterator.keyEncoding] = keyEncoding;
          options[AbstractIterator.valueEncoding] = valueEncoding;
          options.keyEncoding = keyEncoding.format;
          options.valueEncoding = valueEncoding.format;
          if (this[kStatus] === "opening") {
            return new DeferredKeyIterator(this, options);
          } else if (this[kStatus] !== "open") {
            throw new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN"
            });
          }
          return this._keys(options);
        }
        _keys(options) {
          return new DefaultKeyIterator(this, options);
        }
        values(options) {
          const keyEncoding = this.keyEncoding(options && options.keyEncoding);
          const valueEncoding = this.valueEncoding(options && options.valueEncoding);
          options = rangeOptions(options, keyEncoding);
          options[AbstractIterator.keyEncoding] = keyEncoding;
          options[AbstractIterator.valueEncoding] = valueEncoding;
          options.keyEncoding = keyEncoding.format;
          options.valueEncoding = valueEncoding.format;
          if (this[kStatus] === "opening") {
            return new DeferredValueIterator(this, options);
          } else if (this[kStatus] !== "open") {
            throw new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN"
            });
          }
          return this._values(options);
        }
        _values(options) {
          return new DefaultValueIterator(this, options);
        }
        defer(fn) {
          if (typeof fn !== "function") {
            throw new TypeError("The first argument must be a function");
          }
          this[kOperations].push(fn);
        }
        [kUndefer]() {
          if (this[kOperations].length === 0) {
            return;
          }
          const operations = this[kOperations];
          this[kOperations] = [];
          for (const op of operations) {
            op();
          }
        }
        attachResource(resource) {
          if (typeof resource !== "object" || resource === null || typeof resource.close !== "function") {
            throw new TypeError("The first argument must be a resource object");
          }
          this[kResources].add(resource);
        }
        detachResource(resource) {
          this[kResources].delete(resource);
        }
        _chainedBatch() {
          return new DefaultChainedBatch(this);
        }
        _checkKey(key) {
          if (key === null || key === void 0) {
            return new ModuleError("Key cannot be null or undefined", {
              code: "LEVEL_INVALID_KEY"
            });
          }
        }
        _checkValue(value) {
          if (value === null || value === void 0) {
            return new ModuleError("Value cannot be null or undefined", {
              code: "LEVEL_INVALID_VALUE"
            });
          }
        }
      };
      AbstractLevel.prototype.nextTick = require_next_tick_browser2();
      var { AbstractSublevel } = require_abstract_sublevel()({ AbstractLevel });
      exports2.AbstractLevel = AbstractLevel;
      exports2.AbstractSublevel = AbstractSublevel;
      var maybeError = function(db, callback) {
        if (db[kStatus] !== "open") {
          db.nextTick(callback, new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          }));
          return true;
        }
        return false;
      };
      var formats = function(db) {
        return Object.keys(db.supports.encodings).filter((k2) => !!db.supports.encodings[k2]);
      };
    }
  });

  // node_modules/abstract-level/index.js
  var require_abstract_level2 = __commonJS({
    "node_modules/abstract-level/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      exports2.AbstractLevel = require_abstract_level().AbstractLevel;
      exports2.AbstractSublevel = require_abstract_level().AbstractSublevel;
      exports2.AbstractIterator = require_abstract_iterator().AbstractIterator;
      exports2.AbstractKeyIterator = require_abstract_iterator().AbstractKeyIterator;
      exports2.AbstractValueIterator = require_abstract_iterator().AbstractValueIterator;
      exports2.AbstractChainedBatch = require_abstract_chained_batch().AbstractChainedBatch;
    }
  });

  // node_modules/run-parallel-limit/index.js
  var require_run_parallel_limit = __commonJS({
    "node_modules/run-parallel-limit/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = runParallelLimit;
      var queueMicrotask2 = require_queue_microtask();
      function runParallelLimit(tasks, limit, cb) {
        if (typeof limit !== "number")
          throw new Error("second argument must be a Number");
        let results, len, pending, keys, isErrored;
        let isSync = true;
        let next;
        if (Array.isArray(tasks)) {
          results = [];
          pending = len = tasks.length;
        } else {
          keys = Object.keys(tasks);
          results = {};
          pending = len = keys.length;
        }
        function done(err) {
          function end() {
            if (cb)
              cb(err, results);
            cb = null;
          }
          if (isSync)
            queueMicrotask2(end);
          else
            end();
        }
        function each(i2, err, result) {
          results[i2] = result;
          if (err)
            isErrored = true;
          if (--pending === 0 || err) {
            done(err);
          } else if (!isErrored && next < len) {
            let key;
            if (keys) {
              key = keys[next];
              next += 1;
              tasks[key](function(err2, result2) {
                each(key, err2, result2);
              });
            } else {
              key = next;
              next += 1;
              tasks[key](function(err2, result2) {
                each(key, err2, result2);
              });
            }
          }
        }
        next = limit;
        if (!pending) {
          done(null);
        } else if (keys) {
          keys.some(function(key, i2) {
            tasks[key](function(err, result) {
              each(key, err, result);
            });
            if (i2 === limit - 1)
              return true;
            return false;
          });
        } else {
          tasks.some(function(task, i2) {
            task(function(err, result) {
              each(i2, err, result);
            });
            if (i2 === limit - 1)
              return true;
            return false;
          });
        }
        isSync = false;
      }
    }
  });

  // node_modules/browser-level/util/key-range.js
  var require_key_range = __commonJS({
    "node_modules/browser-level/util/key-range.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = function createKeyRange(options) {
        const lower = options.gte !== void 0 ? options.gte : options.gt !== void 0 ? options.gt : void 0;
        const upper = options.lte !== void 0 ? options.lte : options.lt !== void 0 ? options.lt : void 0;
        const lowerExclusive = options.gte === void 0;
        const upperExclusive = options.lte === void 0;
        if (lower !== void 0 && upper !== void 0) {
          return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
        } else if (lower !== void 0) {
          return IDBKeyRange.lowerBound(lower, lowerExclusive);
        } else if (upper !== void 0) {
          return IDBKeyRange.upperBound(upper, upperExclusive);
        } else {
          return null;
        }
      };
    }
  });

  // node_modules/browser-level/util/deserialize.js
  var require_deserialize = __commonJS({
    "node_modules/browser-level/util/deserialize.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var textEncoder6 = new TextEncoder();
      module2.exports = function(data) {
        if (data instanceof Uint8Array) {
          return data;
        } else if (data instanceof ArrayBuffer) {
          return new Uint8Array(data);
        } else {
          return textEncoder6.encode(data);
        }
      };
    }
  });

  // node_modules/browser-level/iterator.js
  var require_iterator = __commonJS({
    "node_modules/browser-level/iterator.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractIterator } = require_abstract_level2();
      var createKeyRange = require_key_range();
      var deserialize = require_deserialize();
      var kCache = Symbol("cache");
      var kFinished = Symbol("finished");
      var kOptions = Symbol("options");
      var kCurrentOptions = Symbol("currentOptions");
      var kPosition = Symbol("position");
      var kLocation = Symbol("location");
      var kFirst = Symbol("first");
      var emptyOptions = {};
      var Iterator = class extends AbstractIterator {
        constructor(db, location, options) {
          super(db, options);
          this[kCache] = [];
          this[kFinished] = this.limit === 0;
          this[kOptions] = options;
          this[kCurrentOptions] = { ...options };
          this[kPosition] = void 0;
          this[kLocation] = location;
          this[kFirst] = true;
        }
        _nextv(size, options, callback) {
          this[kFirst] = false;
          if (this[kFinished]) {
            return this.nextTick(callback, null, []);
          } else if (this[kCache].length > 0) {
            size = Math.min(size, this[kCache].length);
            return this.nextTick(callback, null, this[kCache].splice(0, size));
          }
          if (this[kPosition] !== void 0) {
            if (this[kOptions].reverse) {
              this[kCurrentOptions].lt = this[kPosition];
              this[kCurrentOptions].lte = void 0;
            } else {
              this[kCurrentOptions].gt = this[kPosition];
              this[kCurrentOptions].gte = void 0;
            }
          }
          let keyRange;
          try {
            keyRange = createKeyRange(this[kCurrentOptions]);
          } catch (_3) {
            this[kFinished] = true;
            return this.nextTick(callback, null, []);
          }
          const transaction = this.db.db.transaction([this[kLocation]], "readonly");
          const store = transaction.objectStore(this[kLocation]);
          const entries = [];
          if (!this[kOptions].reverse) {
            let keys;
            let values;
            const complete = () => {
              if (keys === void 0 || values === void 0)
                return;
              const length7 = Math.max(keys.length, values.length);
              if (length7 === 0 || size === Infinity) {
                this[kFinished] = true;
              } else {
                this[kPosition] = keys[length7 - 1];
              }
              entries.length = length7;
              for (let i2 = 0; i2 < length7; i2++) {
                const key = keys[i2];
                const value = values[i2];
                entries[i2] = [
                  this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                  this[kOptions].values && value !== void 0 ? deserialize(value) : void 0
                ];
              }
              maybeCommit(transaction);
            };
            if (this[kOptions].keys || size < Infinity) {
              store.getAllKeys(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
                keys = ev.target.result;
                complete();
              };
            } else {
              keys = [];
              this.nextTick(complete);
            }
            if (this[kOptions].values) {
              store.getAll(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
                values = ev.target.result;
                complete();
              };
            } else {
              values = [];
              this.nextTick(complete);
            }
          } else {
            const method = !this[kOptions].values && store.openKeyCursor ? "openKeyCursor" : "openCursor";
            store[method](keyRange, "prev").onsuccess = (ev) => {
              const cursor = ev.target.result;
              if (cursor) {
                const { key, value } = cursor;
                this[kPosition] = key;
                entries.push([
                  this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                  this[kOptions].values && value !== void 0 ? deserialize(value) : void 0
                ]);
                if (entries.length < size) {
                  cursor.continue();
                } else {
                  maybeCommit(transaction);
                }
              } else {
                this[kFinished] = true;
              }
            };
          }
          transaction.onabort = () => {
            callback(transaction.error || new Error("aborted by user"));
            callback = null;
          };
          transaction.oncomplete = () => {
            callback(null, entries);
            callback = null;
          };
        }
        _next(callback) {
          if (this[kCache].length > 0) {
            const [key, value] = this[kCache].shift();
            this.nextTick(callback, null, key, value);
          } else if (this[kFinished]) {
            this.nextTick(callback);
          } else {
            let size = Math.min(100, this.limit - this.count);
            if (this[kFirst]) {
              this[kFirst] = false;
              size = 1;
            }
            this._nextv(size, emptyOptions, (err, entries) => {
              if (err)
                return callback(err);
              this[kCache] = entries;
              this._next(callback);
            });
          }
        }
        _all(options, callback) {
          this[kFirst] = false;
          const cache2 = this[kCache].splice(0, this[kCache].length);
          const size = this.limit - this.count - cache2.length;
          if (size <= 0) {
            return this.nextTick(callback, null, cache2);
          }
          this._nextv(size, emptyOptions, (err, entries) => {
            if (err)
              return callback(err);
            if (cache2.length > 0)
              entries = cache2.concat(entries);
            callback(null, entries);
          });
        }
        _seek(target, options) {
          this[kFirst] = true;
          this[kCache] = [];
          this[kFinished] = false;
          this[kPosition] = void 0;
          this[kCurrentOptions] = { ...this[kOptions] };
          let keyRange;
          try {
            keyRange = createKeyRange(this[kOptions]);
          } catch (_3) {
            this[kFinished] = true;
            return;
          }
          if (keyRange !== null && !keyRange.includes(target)) {
            this[kFinished] = true;
          } else if (this[kOptions].reverse) {
            this[kCurrentOptions].lte = target;
          } else {
            this[kCurrentOptions].gte = target;
          }
        }
      };
      exports2.Iterator = Iterator;
      function maybeCommit(transaction) {
        if (typeof transaction.commit === "function") {
          transaction.commit();
        }
      }
    }
  });

  // node_modules/browser-level/util/clear.js
  var require_clear = __commonJS({
    "node_modules/browser-level/util/clear.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = function clear(db, location, keyRange, options, callback) {
        if (options.limit === 0)
          return db.nextTick(callback);
        const transaction = db.db.transaction([location], "readwrite");
        const store = transaction.objectStore(location);
        let count = 0;
        transaction.oncomplete = function() {
          callback();
        };
        transaction.onabort = function() {
          callback(transaction.error || new Error("aborted by user"));
        };
        const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
        const direction = options.reverse ? "prev" : "next";
        store[method](keyRange, direction).onsuccess = function(ev) {
          const cursor = ev.target.result;
          if (cursor) {
            store.delete(cursor.key).onsuccess = function() {
              if (options.limit <= 0 || ++count < options.limit) {
                cursor.continue();
              }
            };
          }
        };
      };
    }
  });

  // node_modules/browser-level/index.js
  var require_browser_level = __commonJS({
    "node_modules/browser-level/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractLevel } = require_abstract_level2();
      var ModuleError = require_module_error();
      var parallel = require_run_parallel_limit();
      var { fromCallback } = require_catering();
      var { Iterator } = require_iterator();
      var deserialize = require_deserialize();
      var clear = require_clear();
      var createKeyRange = require_key_range();
      var DEFAULT_PREFIX = "level-js-";
      var kIDB = Symbol("idb");
      var kNamePrefix = Symbol("namePrefix");
      var kLocation = Symbol("location");
      var kVersion = Symbol("version");
      var kStore = Symbol("store");
      var kOnComplete = Symbol("onComplete");
      var kPromise = Symbol("promise");
      var BrowserLevel = class extends AbstractLevel {
        constructor(location, options, _3) {
          if (typeof options === "function" || typeof _3 === "function") {
            throw new ModuleError("The levelup-style callback argument has been removed", {
              code: "LEVEL_LEGACY"
            });
          }
          const { prefix, version: version8, ...forward } = options || {};
          super({
            encodings: { view: true },
            snapshots: false,
            createIfMissing: false,
            errorIfExists: false,
            seek: true
          }, forward);
          if (typeof location !== "string") {
            throw new Error("constructor requires a location string argument");
          }
          this[kLocation] = location;
          this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
          this[kVersion] = parseInt(version8 || 1, 10);
          this[kIDB] = null;
        }
        get location() {
          return this[kLocation];
        }
        get namePrefix() {
          return this[kNamePrefix];
        }
        get version() {
          return this[kVersion];
        }
        get db() {
          return this[kIDB];
        }
        get type() {
          return "browser-level";
        }
        _open(options, callback) {
          const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
          req.onerror = function() {
            callback(req.error || new Error("unknown error"));
          };
          req.onsuccess = () => {
            this[kIDB] = req.result;
            callback();
          };
          req.onupgradeneeded = (ev) => {
            const db = ev.target.result;
            if (!db.objectStoreNames.contains(this[kLocation])) {
              db.createObjectStore(this[kLocation]);
            }
          };
        }
        [kStore](mode) {
          const transaction = this[kIDB].transaction([this[kLocation]], mode);
          return transaction.objectStore(this[kLocation]);
        }
        [kOnComplete](request, callback) {
          const transaction = request.transaction;
          transaction.onabort = function() {
            callback(transaction.error || new Error("aborted by user"));
          };
          transaction.oncomplete = function() {
            callback(null, request.result);
          };
        }
        _get(key, options, callback) {
          const store = this[kStore]("readonly");
          let req;
          try {
            req = store.get(key);
          } catch (err) {
            return this.nextTick(callback, err);
          }
          this[kOnComplete](req, function(err, value) {
            if (err)
              return callback(err);
            if (value === void 0) {
              return callback(new ModuleError("Entry not found", {
                code: "LEVEL_NOT_FOUND"
              }));
            }
            callback(null, deserialize(value));
          });
        }
        _getMany(keys, options, callback) {
          const store = this[kStore]("readonly");
          const tasks = keys.map((key) => (next) => {
            let request;
            try {
              request = store.get(key);
            } catch (err) {
              return next(err);
            }
            request.onsuccess = () => {
              const value = request.result;
              next(null, value === void 0 ? value : deserialize(value));
            };
            request.onerror = (ev) => {
              ev.stopPropagation();
              next(request.error);
            };
          });
          parallel(tasks, 16, callback);
        }
        _del(key, options, callback) {
          const store = this[kStore]("readwrite");
          let req;
          try {
            req = store.delete(key);
          } catch (err) {
            return this.nextTick(callback, err);
          }
          this[kOnComplete](req, callback);
        }
        _put(key, value, options, callback) {
          const store = this[kStore]("readwrite");
          let req;
          try {
            req = store.put(value, key);
          } catch (err) {
            return this.nextTick(callback, err);
          }
          this[kOnComplete](req, callback);
        }
        _iterator(options) {
          return new Iterator(this, this[kLocation], options);
        }
        _batch(operations, options, callback) {
          const store = this[kStore]("readwrite");
          const transaction = store.transaction;
          let index = 0;
          let error;
          transaction.onabort = function() {
            callback(error || transaction.error || new Error("aborted by user"));
          };
          transaction.oncomplete = function() {
            callback();
          };
          function loop() {
            const op = operations[index++];
            const key = op.key;
            let req;
            try {
              req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
            } catch (err) {
              error = err;
              transaction.abort();
              return;
            }
            if (index < operations.length) {
              req.onsuccess = loop;
            } else if (typeof transaction.commit === "function") {
              transaction.commit();
            }
          }
          loop();
        }
        _clear(options, callback) {
          let keyRange;
          let req;
          try {
            keyRange = createKeyRange(options);
          } catch (e2) {
            return this.nextTick(callback);
          }
          if (options.limit >= 0) {
            return clear(this, this[kLocation], keyRange, options, callback);
          }
          try {
            const store = this[kStore]("readwrite");
            req = keyRange ? store.delete(keyRange) : store.clear();
          } catch (err) {
            return this.nextTick(callback, err);
          }
          this[kOnComplete](req, callback);
        }
        _close(callback) {
          this[kIDB].close();
          this.nextTick(callback);
        }
      };
      BrowserLevel.destroy = function(location, prefix, callback) {
        if (typeof prefix === "function") {
          callback = prefix;
          prefix = DEFAULT_PREFIX;
        }
        callback = fromCallback(callback, kPromise);
        const request = indexedDB.deleteDatabase(prefix + location);
        request.onsuccess = function() {
          callback();
        };
        request.onerror = function(err) {
          callback(err);
        };
        return callback[kPromise];
      };
      exports2.BrowserLevel = BrowserLevel;
    }
  });

  // node_modules/level/browser.js
  var require_browser = __commonJS({
    "node_modules/level/browser.js"(exports2) {
      init_virtual_process_polyfill();
      exports2.Level = require_browser_level().BrowserLevel;
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports2, module2) {
      init_virtual_process_polyfill();
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule && freeModule.require && freeModule.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e2) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length7 = array == null ? 0 : array.length;
          while (++index < length7) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length7 = array == null ? 0 : array.length;
          while (++index < length7) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length7 = array == null ? 0 : array.length;
          while (length7--) {
            if (iteratee(array[length7], length7, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length7 = array == null ? 0 : array.length;
          while (++index < length7) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length7 = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length7) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length7 = array == null ? 0 : array.length;
          return !!length7 && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length7 = array == null ? 0 : array.length;
          while (++index < length7) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length7 = array == null ? 0 : array.length, result = Array(length7);
          while (++index < length7) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length7 = values.length, offset = array.length;
          while (++index < length7) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length7 = array == null ? 0 : array.length;
          if (initAccum && length7) {
            accumulator = array[++index];
          }
          while (++index < length7) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length7 = array == null ? 0 : array.length;
          if (initAccum && length7) {
            accumulator = array[--length7];
          }
          while (length7--) {
            accumulator = iteratee(accumulator, array[length7], length7, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length7 = array == null ? 0 : array.length;
          while (++index < length7) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string2) {
          return string2.split("");
        }
        function asciiWords(string2) {
          return string2.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length7 = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length7) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length7 = array.length;
          while (++index < length7) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length7 = array == null ? 0 : array.length;
          return length7 ? baseSum(array, iteratee) / length7 : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length7 = array.length;
          array.sort(comparer);
          while (length7--) {
            array[length7] = array[length7].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length7 = array.length;
          while (++index < length7) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n2, iteratee) {
          var index = -1, result = Array(n2);
          while (++index < n2) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string2) {
          return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length7 = strSymbols.length;
          while (++index < length7 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length7 = array.length, result = 0;
          while (length7--) {
            if (array[length7] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        function hasUnicodeWord(string2) {
          return reHasUnicodeWord.test(string2);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length7 = array.length, resIndex = 0, result = [];
          while (++index < length7) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length7 = array.length;
          while (++index < length7) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string2) {
          return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function trimmedEndIndex(string2) {
          var index = string2.length;
          while (index-- && reWhitespace.test(string2.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string2) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string2)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function unicodeWords(string2) {
          return string2.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _3.defaults(root.Object(), context, _3.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty2 = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer3 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe3 = Buffer3 ? Buffer3.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e2) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray3(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty2.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray3(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length7 = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length7, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length7 && takeCount == length7) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length7-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length7 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length7) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length7 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length7) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length7 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length7) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length7 = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length7) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer5(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length7 = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length7)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length7 = array.length;
            return length7 ? array[baseRandom(0, length7 - 1)] : undefined2;
          }
          function arraySampleSize(array, n2) {
            return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length7 = array.length;
            while (length7--) {
              if (eq(array[length7][0], key)) {
                return length7;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length7 = paths.length, result2 = Array2(length7), skip = object == null;
            while (++index < length7) {
              result2[index] = skip ? undefined2 : get2(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray3(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer5(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length7 = props.length;
            if (object == null) {
              return !length7;
            }
            object = Object2(object);
            while (length7--) {
              var key = props[length7], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes3 = arrayIncludes, isCommon = true, length7 = array.length, result2 = [], valuesLength = values2.length;
            if (!length7) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes3 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes3 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length7) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes3(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length7 = array.length;
            while (++index < length7) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length7 = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length7 ? 0 : length7 + start;
            }
            end = end === undefined2 || end > length7 ? length7 : toInteger(end);
            if (end < 0) {
              end += length7;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length7 = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length7) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length7 = path.length;
            while (object != null && index < length7) {
              object = object[toKey(path[index++])];
            }
            return index && index == length7 ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray3(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty2.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length7 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length7 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length7 && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed) : includes3(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last2(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray3(object), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer5(object)) {
              if (!isBuffer5(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length7 = index, noCustomizer = !customizer;
            if (object == null) {
              return !length7;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length7) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity4;
            }
            if (typeof value == "object") {
              return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty2.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject2(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get2(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject2(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer5(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray3(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n2) {
            var length7 = array.length;
            if (!length7) {
              return;
            }
            n2 += n2 < 0 ? length7 : 0;
            return isIndex(n2, length7) ? array[n2] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray3(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity4];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length7 = paths.length, result2 = {};
            while (++index < length7) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length7 = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length7) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length7 = array ? indexes.length : 0, lastIndex = length7 - 1;
            while (length7--) {
              var index = indexes[length7];
              if (length7 == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length7 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length7);
            while (length7--) {
              result2[fromRight ? length7 : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string2, n2) {
            var result2 = "";
            if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n2 % 2) {
                result2 += string2;
              }
              n2 = nativeFloor(n2 / 2);
              if (n2) {
                string2 += string2;
              }
            } while (n2);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity4), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n2) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n2, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length7 = path.length, lastIndex = length7 - 1, nested = object;
            while (nested != null && ++index < length7) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity4 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity4 : function(func, string2) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string2),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length7 = array.length;
            if (start < 0) {
              start = -start > length7 ? 0 : length7 + start;
            }
            end = end > length7 ? length7 : end;
            if (end < 0) {
              end += length7;
            }
            length7 = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length7);
            while (++index < length7) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity4, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length7 = array.length, resIndex = 0, result2 = [];
            while (++index < length7) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray3(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol2(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes3 = arrayIncludes, length7 = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes3 = arrayIncludesWith;
            } else if (length7 >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes3 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length7) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes3(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last2(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length7 = array.length, index = fromRight ? length7 : -1;
            while ((fromRight ? index-- : ++index < length7) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length7) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length7 : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length7 = arrays.length;
            if (length7 < 2) {
              return length7 ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length7);
            while (++index < length7) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length7) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length7 = props.length, valsLength = values2.length, result2 = {};
            while (++index < length7) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity4;
          }
          function castPath(value, object) {
            if (isArray3(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString6(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length7 = array.length;
            end = end === undefined2 ? length7 : end;
            return !start && end >= length7 ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer2, isDeep) {
            if (isDeep) {
              return buffer2.slice();
            }
            var length7 = buffer2.length, result2 = allocUnsafe3 ? allocUnsafe3(length7) : new buffer2.constructor(length7);
            buffer2.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView2, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(dataView2.buffer) : dataView2.buffer;
            return new dataView2.constructor(buffer2, dataView2.byteOffset, dataView2.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length7 = objCriteria.length, ordersLength = orders.length;
            while (++index < length7) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length7 = source.length;
            array || (array = Array2(length7));
            while (++index < length7) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length7 = props.length;
            while (++index < length7) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray3(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length7 = sources.length, customizer = length7 > 1 ? sources[length7 - 1] : undefined2, guard = length7 > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length7--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length7 < 3 ? undefined2 : customizer;
                length7 = 1;
              }
              object = Object2(object);
              while (++index < length7) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length7 = collection.length, index = fromRight ? length7 : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length7) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length7 = props.length;
              while (length7--) {
                var key = props[fromRight ? length7 : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string2) {
              string2 = toString6(string2);
              var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string2) {
              return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length7 = arguments.length, args = Array2(length7), index = length7, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length7 < 3 && args[0] !== placeholder && args[length7 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length7 -= holders.length;
              if (length7 < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length7
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length7 = funcs.length, index = length7, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length7;
              while (++index < length7) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray3(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length7 ? funcs[index2].apply(this, args) : value;
                while (++index2 < length7) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length7 = arguments.length, args = Array2(length7), index = length7;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length7 -= holdersCount;
              if (isCurried && length7 < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length7
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length7 = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length7 > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length7) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length7, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length7) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length7 / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length7).join("") : result2.slice(0, length7);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString6(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString6(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length7 = partials ? partials.length : 0;
            if (!length7) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length7 -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length7, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop3 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length7 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
            while (length7--) {
              var data = array[length7], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length7 = result2.length;
            while (length7--) {
              var key = result2[length7], value = object[key];
              result2[length7] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e2) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length7 = transforms.length;
            while (++index < length7) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length7 = path.length, result2 = false;
            while (++index < length7) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length7) {
              return result2;
            }
            length7 = object == null ? 0 : object.length;
            return !!length7 && isLength(length7) && isIndex(key, length7) && (isArray3(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length7 = array.length, result2 = new array.constructor(length7);
            if (length7 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length7 = details.length;
            if (!length7) {
              return source;
            }
            var lastIndex = length7 - 1;
            details[lastIndex] = (length7 > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length7 > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length7) {
            var type = typeof value;
            length7 = length7 == null ? MAX_SAFE_INTEGER : length7;
            return !!length7 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length7);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray3(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction2 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString2(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length7 = nativeMax(args.length - start, 0), array = Array2(length7);
              while (++index < length7) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length7 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length7--) {
              var index = indexes[length7];
              array[length7] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length7 = array.length, lastIndex = length7 - 1;
            size2 = size2 === undefined2 ? length7 : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string2) {
            var result2 = [];
            if (string2.charCodeAt(0) === 46) {
              result2.push("");
            }
            string2.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol2(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e2) {
              }
              try {
                return func + "";
              } catch (e2) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length7 = array == null ? 0 : array.length;
            if (!length7 || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length7 / size2));
            while (index < length7) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length7 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length7) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat4() {
            var length7 = arguments.length;
            if (!length7) {
              return [];
            }
            var args = Array2(length7 - 1), array = arguments[0], index = length7;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray3(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last2(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last2(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n2, guard) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            return baseSlice(array, n2 < 0 ? 0 : n2, length7);
          }
          function dropRight(array, n2, guard) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            n2 = length7 - n2;
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill2(array, value, start, end) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length7;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length7 + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return -1;
            }
            var index = length7 - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length7 + index, 0) : nativeMin(index, length7 - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length7 = array == null ? 0 : array.length;
            return length7 ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length7 = array == null ? 0 : array.length;
            return length7 ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length7 = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length7) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf2(array, value, fromIndex) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length7 + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length7 = array == null ? 0 : array.length;
            return length7 ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last2(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last2(array) {
            var length7 = array == null ? 0 : array.length;
            return length7 ? array[length7 - 1] : undefined2;
          }
          function lastIndexOf2(array, value, fromIndex) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return -1;
            }
            var index = length7;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length7 + index, 0) : nativeMin(index, length7 - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n2) {
            return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length7 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length7) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length7 = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length7) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice3(array, start, end) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length7;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length7 : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length7 = array == null ? 0 : array.length;
            if (length7) {
              var index = baseSortedIndex(array, value);
              if (index < length7 && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length7 = array == null ? 0 : array.length;
            if (length7) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length7 = array == null ? 0 : array.length;
            return length7 ? baseSlice(array, 1, length7) : [];
          }
          function take(array, n2, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function takeRight(array, n2, guard) {
            var length7 = array == null ? 0 : array.length;
            if (!length7) {
              return [];
            }
            n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
            n2 = length7 - n2;
            return baseSlice(array, n2 < 0 ? 0 : n2, length7);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length7 = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length7 = nativeMax(group.length, length7);
                return true;
              }
            });
            return baseTimes(length7, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length7 = arrays.length, iteratee2 = length7 > 1 ? arrays[length7 - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length7 = paths.length, start = length7 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length7 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length7 ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length7 && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray3(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray3(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray3(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray3(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes2(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length7 = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length7 + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length7 && collection.indexOf(value, fromIndex) > -1 : !!length7 && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray3(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray3(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray3(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce2(collection, iteratee2, accumulator) {
            var func = isArray3(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray3(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray3(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray3(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n2, guard) {
            if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            var func = isArray3(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n2);
          }
          function shuffle(collection) {
            var func = isArray3(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray3(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length7 = iteratees.length;
            if (length7 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length7 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n2, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n2, guard) {
            n2 = guard ? undefined2 : n2;
            n2 = func && n2 == null ? func.length : n2;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
          }
          function before(n2, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n2 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush2() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush2;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once4(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray3(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length7 = nativeMin(args.length, funcsLength);
              while (++index < length7) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray3(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt2 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray3 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean2(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer5 = nativeIsBuffer || stubFalse;
          var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray3(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer5(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty2.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError2(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber2(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull2(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber2(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString2(value) {
            return typeof value == "string" || !isArray3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol2(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined2(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt2 = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString2(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary2 = reIsBinary.test(value);
            return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString6(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at2 = flatRest(baseAt);
          function create8(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length7 = sources.length;
            var guard = length7 > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length7 = 1;
            }
            while (++index < length7) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get2(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity4));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty2.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length7 = paths.length;
            while (length7--) {
              baseUnset(result2, paths[length7]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length7 = path.length;
            if (!length7) {
              length7 = 1;
              object = undefined2;
            }
            while (++index < length7) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length7;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray3(object), isArrLike = isArr || isBuffer5(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string2) {
            return upperFirst(toString6(string2).toLowerCase());
          }
          function deburr(string2) {
            string2 = toString6(string2);
            return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string2, target, position) {
            string2 = toString6(string2);
            target = baseToString(target);
            var length7 = string2.length;
            position = position === undefined2 ? length7 : baseClamp(toInteger(position), 0, length7);
            var end = position;
            position -= target.length;
            return position >= 0 && string2.slice(position, end) == target;
          }
          function escape(string2) {
            string2 = toString6(string2);
            return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
          }
          function escapeRegExp(string2) {
            string2 = toString6(string2);
            return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad2(string2, length7, chars) {
            string2 = toString6(string2);
            length7 = toInteger(length7);
            var strLength = length7 ? stringSize(string2) : 0;
            if (!length7 || strLength >= length7) {
              return string2;
            }
            var mid = (length7 - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string2, length7, chars) {
            string2 = toString6(string2);
            length7 = toInteger(length7);
            var strLength = length7 ? stringSize(string2) : 0;
            return length7 && strLength < length7 ? string2 + createPadding(length7 - strLength, chars) : string2;
          }
          function padStart(string2, length7, chars) {
            string2 = toString6(string2);
            length7 = toInteger(length7);
            var strLength = length7 ? stringSize(string2) : 0;
            return length7 && strLength < length7 ? createPadding(length7 - strLength, chars) + string2 : string2;
          }
          function parseInt2(string2, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString6(string2).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string2, n2, guard) {
            if (guard ? isIterateeCall(string2, n2, guard) : n2 === undefined2) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            return baseRepeat(toString6(string2), n2);
          }
          function replace() {
            var args = arguments, string2 = toString6(args[0]);
            return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string2, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string2 = toString6(string2);
            if (string2 && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string2)) {
                return castSlice(stringToArray(string2), 0, limit);
              }
            }
            return string2.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string2, target, position) {
            string2 = toString6(string2);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
            target = baseToString(target);
            return string2.slice(position, position + target.length) == target;
          }
          function template(string2, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string2, options, guard)) {
              options = undefined2;
            }
            string2 = toString6(string2);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty2.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError2(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString6(value).toLowerCase();
          }
          function toUpper(value) {
            return toString6(value).toUpperCase();
          }
          function trim(string2, chars, guard) {
            string2 = toString6(string2);
            if (string2 && (guard || chars === undefined2)) {
              return baseTrim(string2);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string2, chars, guard) {
            string2 = toString6(string2);
            if (string2 && (guard || chars === undefined2)) {
              return string2.slice(0, trimmedEndIndex(string2) + 1);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string2, chars, guard) {
            string2 = toString6(string2);
            if (string2 && (guard || chars === undefined2)) {
              return string2.replace(reTrimStart, "");
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string2, options) {
            var length7 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length7 = "length" in options ? toInteger(options.length) : length7;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string2 = toString6(string2);
            var strLength = string2.length;
            if (hasUnicode(string2)) {
              var strSymbols = stringToArray(string2);
              strLength = strSymbols.length;
            }
            if (length7 >= strLength) {
              return string2;
            }
            var end = length7 - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp2(separator)) {
              if (string2.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString6(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string2.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string2) {
            string2 = toString6(string2);
            return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string2, pattern, guard) {
            string2 = toString6(string2);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
            }
            return string2.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e2) {
              return isError2(e2) ? e2 : new Error2(e2);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length7 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length7 ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length7) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity4(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop3() {
          }
          function nthArg(n2) {
            n2 = toInteger(n2);
            return baseRest(function(args) {
              return baseNth(args, n2);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n2, iteratee2) {
            n2 = toInteger(n2);
            if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length7 = nativeMin(n2, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n2 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length7, iteratee2);
            while (++index < n2) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray3(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol2(value) ? [value] : copyArray(stringToPath(toString6(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString6(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity4, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity4);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity4, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity4) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at2;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat4;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create8;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill2;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once4;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice3;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get2;
          lodash.gt = gt2;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity4;
          lodash.includes = includes2;
          lodash.indexOf = indexOf2;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray3;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean2;
          lodash.isBuffer = isBuffer5;
          lodash.isDate = isDate2;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError2;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction2;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull2;
          lodash.isNumber = isNumber2;
          lodash.isObject = isObject2;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp2;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString2;
          lodash.isSymbol = isSymbol2;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined2;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last2;
          lodash.lastIndexOf = lastIndexOf2;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt2;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop3;
          lodash.now = now;
          lodash.pad = pad2;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce2;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString6;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n2) {
              n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n2) {
              return this.reverse()[methodName](n2).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity4);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray3(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray3(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray3(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty2.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _3 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _3;
          define(function() {
            return _3;
          });
        } else if (freeModule) {
          (freeModule.exports = _3)._ = _3;
          freeExports._ = _3;
        } else {
          root._ = _3;
        }
      }).call(exports2);
    }
  });

  // node_modules/charwise/codec/number.js
  var require_number = __commonJS({
    "node_modules/charwise/codec/number.js"(exports2) {
      init_virtual_process_polyfill();
      exports2.encode = function(number) {
        if (isNaN(number)) {
          return "DaN";
        }
        if (number === 0) {
          return "FE  0M0";
        }
        if (number === Infinity) {
          return "FF";
        }
        if (number === -Infinity) {
          return "DD";
        }
        var splitScientificNotation = number.toExponential().split("e");
        var exponent = Number(splitScientificNotation[1]) + 500;
        var mantissa = splitScientificNotation[0] + (splitScientificNotation[0].indexOf(".") === -1 ? "." : "") + "0".repeat(20);
        var encoded = "E" + padStart(String(exponent), 3) + "M" + String(mantissa);
        if (number > 0) {
          return "F" + encoded;
        } else {
          return "D" + flip(encoded);
        }
      };
      exports2.decode = function(encoded) {
        if (encoded === "DaN") {
          return NaN;
        }
        if (encoded === "FF") {
          return Infinity;
        }
        if (encoded === "DD") {
          return -Infinity;
        }
        var isNegative = encoded[0] === "D";
        var splitEncoded = (isNegative ? flip(encoded) : encoded).slice(2).split("M");
        return Number((isNegative ? "-" : "") + splitEncoded[1] + "e" + String(Number(splitEncoded[0]) - 500));
      };
      function flip(number) {
        var flipped = "";
        for (var i2 = 0; i2 < number.length; i2++) {
          var digit = number[i2];
          if (isNaN(Number(digit)) || digit === " ") {
            if (digit !== "-") {
              flipped += digit;
            }
          } else {
            flipped += String(9 - Number(digit));
          }
        }
        return flipped;
      }
      function padStart(str, count) {
        return " ".repeat(count - str.length).substr(0, count) + str;
      }
    }
  });

  // node_modules/charwise/codec/object.js
  var require_object = __commonJS({
    "node_modules/charwise/codec/object.js"(exports2) {
      init_virtual_process_polyfill();
      var dictEscape = { "?": "?@", "!": "??", '"': "?%" };
      function escape(str) {
        if (!/[!"]/.test(str)) {
          return str;
        }
        return str.replace(/[\?!"]/g, function(match) {
          return dictEscape[match];
        });
      }
      var dictUnescape = { "?@": "?", "??": "!", "?%": '"' };
      function unescape(str) {
        if (!/\?[%\?@]/.test(str)) {
          return str;
        }
        return str.replace(/\?[%\?@]/g, function(match) {
          return dictUnescape[match];
        });
      }
      exports2.factory = function(codec) {
        return {
          encode: encode21,
          decode: decode32
        };
        function encode21(array) {
          if (array === null) {
            return "A";
          }
          if (!Array.isArray(array)) {
            throw new Error("can only encode arrays");
          }
          var l2 = array.length;
          if (l2 == 0) {
            return "K!";
          }
          var s2 = encodeItem(array[0]);
          for (var i2 = 1; i2 < l2; i2++) {
            s2 += '"' + encodeItem(array[i2]);
          }
          return "K" + s2 + "!";
        }
        function encodeItem(item) {
          if (typeof item === "object") {
            return encode21(item);
          }
          return escape(codec.encode(item));
        }
        function decode32(encoded) {
          if (encoded === "A") {
            return null;
          }
          if (encoded === "K!") {
            return [];
          }
          var items = encoded.split('"');
          var pointers = [[]];
          var array;
          var depth = 0;
          var l2 = items.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var item = items[i2];
            var itemLength = item.length;
            var open = 0;
            while (item[open] == "K") {
              open++;
            }
            var close = 0;
            while (item[itemLength - close - 1] == "!") {
              close++;
            }
            var content = item.slice(open, itemLength - close);
            var newdepth = depth + open;
            for (var j2 = depth; j2 < newdepth; j2++) {
              pointers[j2 + 1] = [];
              pointers[j2].push(pointers[j2 + 1]);
              depth = newdepth;
              array = pointers[depth];
            }
            if (content.length !== 0) {
              array.push(codec.decode(unescape(content)));
            }
            var newdepth = depth - close;
            for (var j2 = newdepth; j2 < depth; j2++) {
              pointers[j2 + 1] = [];
              depth = newdepth;
              array = pointers[depth];
            }
          }
          return pointers[0][0];
        }
      };
    }
  });

  // node_modules/charwise/index.js
  var require_charwise = __commonJS({
    "node_modules/charwise/index.js"(exports2) {
      init_virtual_process_polyfill();
      var number = require_number();
      var object = require_object();
      var flip = exports2.flip = function(n2) {
        var s2 = n2.toString();
        var f2 = "";
        for (var i2 in s2) {
          f2 += s2[i2] == "." ? "." : 9 - +s2[i2];
        }
        return f2;
      };
      exports2.number = number;
      exports2.string = {
        encode: function(s2) {
          if (!/\x00|\x01/.test(s2))
            return "J" + s2;
          else {
            return "J" + s2.replace(/\x01/g, "").replace(/\x00/g, "");
          }
        },
        decode: function(s2) {
          if ("J" === s2[0])
            return s2.substring(1);
        }
      };
      exports2.encode = function(t2) {
        return exports2[typeof t2].encode(t2);
      };
      exports2.decode = function(s2) {
        if (s2 === "")
          return s2;
        if (!decoders[s2[0]])
          throw new Error("no decoder for:" + JSON.stringify(s2));
        return decoders[s2[0]](s2);
      };
      exports2.object = object.factory(exports2);
      exports2.boolean = {
        encode: function(b2) {
          return b2 ? "C" : "B";
        },
        decode: function(b2) {
          return "C" === b2;
        }
      };
      exports2.undefined = {
        encode: function(b2) {
          return "L";
        },
        decode: function() {
          return void 0;
        }
      };
      var decoders = {
        A: exports2.object.decode,
        B: exports2.boolean.decode,
        C: exports2.boolean.decode,
        D: exports2.number.decode,
        F: exports2.number.decode,
        J: exports2.string.decode,
        K: exports2.object.decode,
        L: exports2.undefined.decode
      };
      exports2.buffer = false;
      exports2.type = "charwise";
    }
  });

  // node_modules/abstract-leveldown/node_modules/level-supports/index.js
  var require_level_supports2 = __commonJS({
    "node_modules/abstract-leveldown/node_modules/level-supports/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = function supports(...manifests) {
        const manifest = manifests.reduce((acc, m2) => Object.assign(acc, m2), {});
        return Object.assign(manifest, {
          bufferKeys: manifest.bufferKeys || false,
          snapshots: manifest.snapshots || false,
          permanence: manifest.permanence || false,
          seek: manifest.seek || false,
          clear: manifest.clear || false,
          getMany: manifest.getMany || false,
          keyIterator: manifest.keyIterator || false,
          valueIterator: manifest.valueIterator || false,
          iteratorNextv: manifest.iteratorNextv || false,
          iteratorAll: manifest.iteratorAll || false,
          status: manifest.status || false,
          idempotentOpen: manifest.idempotentOpen || false,
          passiveOpen: manifest.passiveOpen || false,
          serialize: manifest.serialize || false,
          createIfMissing: manifest.createIfMissing || false,
          errorIfExists: manifest.errorIfExists || false,
          deferredOpen: manifest.deferredOpen || false,
          openCallback: manifest.openCallback || false,
          promises: manifest.promises || false,
          streams: manifest.streams || false,
          encodings: maybeObject(manifest.encodings),
          events: maybeObject(manifest.events),
          additionalMethods: Object.assign({}, manifest.additionalMethods)
        });
      };
      function maybeObject(value) {
        return !value ? false : Object.assign({}, value);
      }
    }
  });

  // node_modules/is-buffer/index.js
  var require_is_buffer = __commonJS({
    "node_modules/is-buffer/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = function isBuffer5(obj) {
        return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      };
    }
  });

  // node_modules/abstract-leveldown/next-tick-browser.js
  var require_next_tick_browser3 = __commonJS({
    "node_modules/abstract-leveldown/next-tick-browser.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var queueMicrotask2 = require_queue_microtask();
      module2.exports = function(fn, ...args) {
        if (args.length === 0) {
          queueMicrotask2(fn);
        } else {
          queueMicrotask2(() => fn(...args));
        }
      };
    }
  });

  // node_modules/abstract-leveldown/abstract-iterator.js
  var require_abstract_iterator2 = __commonJS({
    "node_modules/abstract-leveldown/abstract-iterator.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      function AbstractIterator(db) {
        if (typeof db !== "object" || db === null) {
          throw new TypeError("First argument must be an abstract-leveldown compliant store");
        }
        this.db = db;
        this._ended = false;
        this._nexting = false;
      }
      AbstractIterator.prototype.next = function(callback) {
        let ret = this;
        if (callback === void 0) {
          ret = new Promise(function(resolve5, reject) {
            callback = function(err, key, value) {
              if (err)
                reject(err);
              else if (key === void 0 && value === void 0)
                resolve5();
              else
                resolve5([key, value]);
            };
          });
        } else if (typeof callback !== "function") {
          throw new Error("next() requires a callback argument");
        }
        if (this._ended) {
          this._nextTick(callback, new Error("cannot call next() after end()"));
          return ret;
        }
        if (this._nexting) {
          this._nextTick(callback, new Error("cannot call next() before previous next() has completed"));
          return ret;
        }
        this._nexting = true;
        this._next((err, ...rest) => {
          this._nexting = false;
          callback(err, ...rest);
        });
        return ret;
      };
      AbstractIterator.prototype._next = function(callback) {
        this._nextTick(callback);
      };
      AbstractIterator.prototype.seek = function(target) {
        if (this._ended) {
          throw new Error("cannot call seek() after end()");
        }
        if (this._nexting) {
          throw new Error("cannot call seek() before next() has completed");
        }
        target = this.db._serializeKey(target);
        this._seek(target);
      };
      AbstractIterator.prototype._seek = function(target) {
      };
      AbstractIterator.prototype.end = function(callback) {
        let promise;
        if (callback === void 0) {
          promise = new Promise(function(resolve5, reject) {
            callback = function(err) {
              if (err)
                reject(err);
              else
                resolve5();
            };
          });
        } else if (typeof callback !== "function") {
          throw new Error("end() requires a callback argument");
        }
        if (this._ended) {
          this._nextTick(callback, new Error("end() already called on iterator"));
          return promise;
        }
        this._ended = true;
        this._end(callback);
        return promise;
      };
      AbstractIterator.prototype._end = function(callback) {
        this._nextTick(callback);
      };
      AbstractIterator.prototype[Symbol.asyncIterator] = async function* () {
        try {
          let kv;
          while ((kv = await this.next()) !== void 0) {
            yield kv;
          }
        } finally {
          if (!this._ended)
            await this.end();
        }
      };
      AbstractIterator.prototype._nextTick = require_next_tick_browser3();
      module2.exports = AbstractIterator;
    }
  });

  // node_modules/abstract-leveldown/abstract-chained-batch.js
  var require_abstract_chained_batch2 = __commonJS({
    "node_modules/abstract-leveldown/abstract-chained-batch.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var emptyOptions = Object.freeze({});
      function AbstractChainedBatch(db) {
        if (typeof db !== "object" || db === null) {
          throw new TypeError("First argument must be an abstract-leveldown compliant store");
        }
        this.db = db;
        this._operations = [];
        this._written = false;
      }
      AbstractChainedBatch.prototype._checkWritten = function() {
        if (this._written) {
          throw new Error("write() already called on this batch");
        }
      };
      AbstractChainedBatch.prototype.put = function(key, value, options) {
        this._checkWritten();
        const err = this.db._checkKey(key) || this.db._checkValue(value);
        if (err)
          throw err;
        key = this.db._serializeKey(key);
        value = this.db._serializeValue(value);
        this._put(key, value, options != null ? options : emptyOptions);
        return this;
      };
      AbstractChainedBatch.prototype._put = function(key, value, options) {
        this._operations.push({ ...options, type: "put", key, value });
      };
      AbstractChainedBatch.prototype.del = function(key, options) {
        this._checkWritten();
        const err = this.db._checkKey(key);
        if (err)
          throw err;
        key = this.db._serializeKey(key);
        this._del(key, options != null ? options : emptyOptions);
        return this;
      };
      AbstractChainedBatch.prototype._del = function(key, options) {
        this._operations.push({ ...options, type: "del", key });
      };
      AbstractChainedBatch.prototype.clear = function() {
        this._checkWritten();
        this._clear();
        return this;
      };
      AbstractChainedBatch.prototype._clear = function() {
        this._operations = [];
      };
      AbstractChainedBatch.prototype.write = function(options, callback) {
        this._checkWritten();
        if (typeof options === "function") {
          callback = options;
        }
        if (typeof callback !== "function") {
          throw new Error("write() requires a callback argument");
        }
        if (typeof options !== "object" || options === null) {
          options = {};
        }
        this._written = true;
        this._write(options, callback);
      };
      AbstractChainedBatch.prototype._write = function(options, callback) {
        this.db._batch(this._operations, options, callback);
      };
      AbstractChainedBatch.prototype._nextTick = require_next_tick_browser3();
      module2.exports = AbstractChainedBatch;
    }
  });

  // node_modules/abstract-leveldown/lib/common.js
  var require_common2 = __commonJS({
    "node_modules/abstract-leveldown/lib/common.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      exports2.getCallback = function(options, callback) {
        return typeof options === "function" ? options : callback;
      };
      exports2.getOptions = function(options) {
        return typeof options === "object" && options !== null ? options : {};
      };
    }
  });

  // node_modules/abstract-leveldown/abstract-leveldown.js
  var require_abstract_leveldown = __commonJS({
    "node_modules/abstract-leveldown/abstract-leveldown.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var supports = require_level_supports2();
      var isBuffer5 = require_is_buffer();
      var catering = require_catering();
      var AbstractIterator = require_abstract_iterator2();
      var AbstractChainedBatch = require_abstract_chained_batch2();
      var getCallback = require_common2().getCallback;
      var getOptions = require_common2().getOptions;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var rangeOptions = ["lt", "lte", "gt", "gte"];
      function AbstractLevelDOWN(manifest) {
        this.status = "new";
        this.supports = supports(manifest, {
          status: true
        });
      }
      AbstractLevelDOWN.prototype.open = function(options, callback) {
        const oldStatus = this.status;
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("open() requires a callback argument");
        }
        if (typeof options !== "object" || options === null)
          options = {};
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        this.status = "opening";
        this._open(options, (err) => {
          if (err) {
            this.status = oldStatus;
            return callback(err);
          }
          this.status = "open";
          callback();
        });
      };
      AbstractLevelDOWN.prototype._open = function(options, callback) {
        this._nextTick(callback);
      };
      AbstractLevelDOWN.prototype.close = function(callback) {
        const oldStatus = this.status;
        if (typeof callback !== "function") {
          throw new Error("close() requires a callback argument");
        }
        this.status = "closing";
        this._close((err) => {
          if (err) {
            this.status = oldStatus;
            return callback(err);
          }
          this.status = "closed";
          callback();
        });
      };
      AbstractLevelDOWN.prototype._close = function(callback) {
        this._nextTick(callback);
      };
      AbstractLevelDOWN.prototype.get = function(key, options, callback) {
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("get() requires a callback argument");
        }
        const err = this._checkKey(key);
        if (err)
          return this._nextTick(callback, err);
        key = this._serializeKey(key);
        if (typeof options !== "object" || options === null)
          options = {};
        options.asBuffer = options.asBuffer !== false;
        this._get(key, options, callback);
      };
      AbstractLevelDOWN.prototype._get = function(key, options, callback) {
        this._nextTick(function() {
          callback(new Error("NotFound"));
        });
      };
      AbstractLevelDOWN.prototype.getMany = function(keys, options, callback) {
        callback = getCallback(options, callback);
        callback = catering.fromCallback(callback);
        options = getOptions(options);
        if (maybeError(this, callback)) {
          return callback.promise;
        }
        if (!Array.isArray(keys)) {
          this._nextTick(callback, new Error("getMany() requires an array argument"));
          return callback.promise;
        }
        if (keys.length === 0) {
          this._nextTick(callback, null, []);
          return callback.promise;
        }
        if (typeof options.asBuffer !== "boolean") {
          options = { ...options, asBuffer: true };
        }
        const serialized = new Array(keys.length);
        for (let i2 = 0; i2 < keys.length; i2++) {
          const key = keys[i2];
          const err = this._checkKey(key);
          if (err) {
            this._nextTick(callback, err);
            return callback.promise;
          }
          serialized[i2] = this._serializeKey(key);
        }
        this._getMany(serialized, options, callback);
        return callback.promise;
      };
      AbstractLevelDOWN.prototype._getMany = function(keys, options, callback) {
        this._nextTick(callback, null, new Array(keys.length).fill(void 0));
      };
      AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("put() requires a callback argument");
        }
        const err = this._checkKey(key) || this._checkValue(value);
        if (err)
          return this._nextTick(callback, err);
        key = this._serializeKey(key);
        value = this._serializeValue(value);
        if (typeof options !== "object" || options === null)
          options = {};
        this._put(key, value, options, callback);
      };
      AbstractLevelDOWN.prototype._put = function(key, value, options, callback) {
        this._nextTick(callback);
      };
      AbstractLevelDOWN.prototype.del = function(key, options, callback) {
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("del() requires a callback argument");
        }
        const err = this._checkKey(key);
        if (err)
          return this._nextTick(callback, err);
        key = this._serializeKey(key);
        if (typeof options !== "object" || options === null)
          options = {};
        this._del(key, options, callback);
      };
      AbstractLevelDOWN.prototype._del = function(key, options, callback) {
        this._nextTick(callback);
      };
      AbstractLevelDOWN.prototype.batch = function(array, options, callback) {
        if (!arguments.length)
          return this._chainedBatch();
        if (typeof options === "function")
          callback = options;
        if (typeof array === "function")
          callback = array;
        if (typeof callback !== "function") {
          throw new Error("batch(array) requires a callback argument");
        }
        if (!Array.isArray(array)) {
          return this._nextTick(callback, new Error("batch(array) requires an array argument"));
        }
        if (array.length === 0) {
          return this._nextTick(callback);
        }
        if (typeof options !== "object" || options === null)
          options = {};
        const serialized = new Array(array.length);
        for (let i2 = 0; i2 < array.length; i2++) {
          if (typeof array[i2] !== "object" || array[i2] === null) {
            return this._nextTick(callback, new Error("batch(array) element must be an object and not `null`"));
          }
          const e2 = Object.assign({}, array[i2]);
          if (e2.type !== "put" && e2.type !== "del") {
            return this._nextTick(callback, new Error("`type` must be 'put' or 'del'"));
          }
          const err = this._checkKey(e2.key);
          if (err)
            return this._nextTick(callback, err);
          e2.key = this._serializeKey(e2.key);
          if (e2.type === "put") {
            const valueErr = this._checkValue(e2.value);
            if (valueErr)
              return this._nextTick(callback, valueErr);
            e2.value = this._serializeValue(e2.value);
          }
          serialized[i2] = e2;
        }
        this._batch(serialized, options, callback);
      };
      AbstractLevelDOWN.prototype._batch = function(array, options, callback) {
        this._nextTick(callback);
      };
      AbstractLevelDOWN.prototype.clear = function(options, callback) {
        if (typeof options === "function") {
          callback = options;
        } else if (typeof callback !== "function") {
          throw new Error("clear() requires a callback argument");
        }
        options = cleanRangeOptions(this, options);
        options.reverse = !!options.reverse;
        options.limit = "limit" in options ? options.limit : -1;
        this._clear(options, callback);
      };
      AbstractLevelDOWN.prototype._clear = function(options, callback) {
        options.keys = true;
        options.values = false;
        options.keyAsBuffer = true;
        options.valueAsBuffer = true;
        const iterator = this._iterator(options);
        const emptyOptions = {};
        const next = (err) => {
          if (err) {
            return iterator.end(function() {
              callback(err);
            });
          }
          iterator.next((err2, key) => {
            if (err2)
              return next(err2);
            if (key === void 0)
              return iterator.end(callback);
            this._del(key, emptyOptions, next);
          });
        };
        next();
      };
      AbstractLevelDOWN.prototype._setupIteratorOptions = function(options) {
        options = cleanRangeOptions(this, options);
        options.reverse = !!options.reverse;
        options.keys = options.keys !== false;
        options.values = options.values !== false;
        options.limit = "limit" in options ? options.limit : -1;
        options.keyAsBuffer = options.keyAsBuffer !== false;
        options.valueAsBuffer = options.valueAsBuffer !== false;
        return options;
      };
      function cleanRangeOptions(db, options) {
        const result = {};
        for (const k2 in options) {
          if (!hasOwnProperty2.call(options, k2))
            continue;
          if (k2 === "start" || k2 === "end") {
            throw new Error('Legacy range options ("start" and "end") have been removed');
          }
          let opt = options[k2];
          if (isRangeOption(k2)) {
            opt = db._serializeKey(opt);
          }
          result[k2] = opt;
        }
        return result;
      }
      function isRangeOption(k2) {
        return rangeOptions.indexOf(k2) !== -1;
      }
      AbstractLevelDOWN.prototype.iterator = function(options) {
        if (typeof options !== "object" || options === null)
          options = {};
        options = this._setupIteratorOptions(options);
        return this._iterator(options);
      };
      AbstractLevelDOWN.prototype._iterator = function(options) {
        return new AbstractIterator(this);
      };
      AbstractLevelDOWN.prototype._chainedBatch = function() {
        return new AbstractChainedBatch(this);
      };
      AbstractLevelDOWN.prototype._serializeKey = function(key) {
        return key;
      };
      AbstractLevelDOWN.prototype._serializeValue = function(value) {
        return value;
      };
      AbstractLevelDOWN.prototype._checkKey = function(key) {
        if (key === null || key === void 0) {
          return new Error("key cannot be `null` or `undefined`");
        } else if (isBuffer5(key) && key.length === 0) {
          return new Error("key cannot be an empty Buffer");
        } else if (key === "") {
          return new Error("key cannot be an empty String");
        } else if (Array.isArray(key) && key.length === 0) {
          return new Error("key cannot be an empty Array");
        }
      };
      AbstractLevelDOWN.prototype._checkValue = function(value) {
        if (value === null || value === void 0) {
          return new Error("value cannot be `null` or `undefined`");
        }
      };
      AbstractLevelDOWN.prototype.isOperational = function() {
        return this.status === "open" || this._isOperational();
      };
      AbstractLevelDOWN.prototype._isOperational = function() {
        return false;
      };
      AbstractLevelDOWN.prototype._nextTick = require_next_tick_browser3();
      module2.exports = AbstractLevelDOWN;
      function maybeError(db, callback) {
        if (!db.isOperational()) {
          db._nextTick(callback, new Error("Database is not open"));
          return true;
        }
        return false;
      }
    }
  });

  // node_modules/abstract-leveldown/index.js
  var require_abstract_leveldown2 = __commonJS({
    "node_modules/abstract-leveldown/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      exports2.AbstractLevelDOWN = require_abstract_leveldown();
      exports2.AbstractIterator = require_abstract_iterator2();
      exports2.AbstractChainedBatch = require_abstract_chained_batch2();
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      if (typeof Object.create === "function") {
        module2.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/level-codec/lib/encodings.js
  var require_encodings2 = __commonJS({
    "node_modules/level-codec/lib/encodings.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var { Buffer: Buffer3 } = require_buffer();
      exports2.utf8 = exports2["utf-8"] = {
        encode: function(data) {
          return isBinary2(data) ? data : String(data);
        },
        decode: identity4,
        buffer: false,
        type: "utf8"
      };
      exports2.json = {
        encode: JSON.stringify,
        decode: JSON.parse,
        buffer: false,
        type: "json"
      };
      exports2.binary = {
        encode: function(data) {
          return isBinary2(data) ? data : Buffer3.from(data);
        },
        decode: identity4,
        buffer: true,
        type: "binary"
      };
      exports2.none = {
        encode: identity4,
        decode: identity4,
        buffer: false,
        type: "id"
      };
      exports2.id = exports2.none;
      var bufferEncodings = [
        "hex",
        "ascii",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le"
      ];
      for (const type of bufferEncodings) {
        exports2[type] = {
          encode: function(data) {
            return isBinary2(data) ? data : Buffer3.from(data, type);
          },
          decode: function(buffer2) {
            return buffer2.toString(type);
          },
          buffer: true,
          type
        };
      }
      function identity4(value) {
        return value;
      }
      function isBinary2(data) {
        return data === void 0 || data === null || Buffer3.isBuffer(data);
      }
    }
  });

  // node_modules/level-codec/index.js
  var require_level_codec = __commonJS({
    "node_modules/level-codec/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var encodings = require_encodings2();
      var rangeOptions = /* @__PURE__ */ new Set(["lt", "gt", "lte", "gte"]);
      module2.exports = Codec7;
      function Codec7(opts) {
        if (!(this instanceof Codec7)) {
          return new Codec7(opts);
        }
        this.opts = opts || {};
        this.encodings = encodings;
      }
      Codec7.prototype._encoding = function(encoding) {
        if (typeof encoding === "string")
          encoding = encodings[encoding];
        if (!encoding)
          encoding = encodings.id;
        return encoding;
      };
      Codec7.prototype._keyEncoding = function(opts, batchOpts) {
        return this._encoding(batchOpts && batchOpts.keyEncoding || opts && opts.keyEncoding || this.opts.keyEncoding);
      };
      Codec7.prototype._valueEncoding = function(opts, batchOpts) {
        return this._encoding(batchOpts && (batchOpts.valueEncoding || batchOpts.encoding) || opts && (opts.valueEncoding || opts.encoding) || (this.opts.valueEncoding || this.opts.encoding));
      };
      Codec7.prototype.encodeKey = function(key, opts, batchOpts) {
        return this._keyEncoding(opts, batchOpts).encode(key);
      };
      Codec7.prototype.encodeValue = function(value, opts, batchOpts) {
        return this._valueEncoding(opts, batchOpts).encode(value);
      };
      Codec7.prototype.decodeKey = function(key, opts) {
        return this._keyEncoding(opts).decode(key);
      };
      Codec7.prototype.decodeValue = function(value, opts) {
        return this._valueEncoding(opts).decode(value);
      };
      Codec7.prototype.encodeBatch = function(ops, opts) {
        return ops.map((_op) => {
          const op = {
            type: _op.type,
            key: this.encodeKey(_op.key, opts, _op)
          };
          if (this.keyAsBuffer(opts, _op))
            op.keyEncoding = "binary";
          if (_op.prefix)
            op.prefix = _op.prefix;
          if ("value" in _op) {
            op.value = this.encodeValue(_op.value, opts, _op);
            if (this.valueAsBuffer(opts, _op))
              op.valueEncoding = "binary";
          }
          return op;
        });
      };
      Codec7.prototype.encodeLtgt = function(ltgt) {
        const ret = {};
        for (const key of Object.keys(ltgt)) {
          if (key === "start" || key === "end") {
            throw new Error('Legacy range options ("start" and "end") have been removed');
          }
          ret[key] = rangeOptions.has(key) ? this.encodeKey(ltgt[key], ltgt) : ltgt[key];
        }
        return ret;
      };
      Codec7.prototype.createStreamDecoder = function(opts) {
        if (opts.keys && opts.values) {
          return (key, value) => {
            return {
              key: this.decodeKey(key, opts),
              value: this.decodeValue(value, opts)
            };
          };
        } else if (opts.keys) {
          return (key) => {
            return this.decodeKey(key, opts);
          };
        } else if (opts.values) {
          return (_3, value) => {
            return this.decodeValue(value, opts);
          };
        } else {
          return function() {
          };
        }
      };
      Codec7.prototype.keyAsBuffer = function(opts) {
        return this._keyEncoding(opts).buffer;
      };
      Codec7.prototype.valueAsBuffer = function(opts) {
        return this._valueEncoding(opts).buffer;
      };
    }
  });

  // node_modules/level-errors/errors.js
  var require_errors = __commonJS({
    "node_modules/level-errors/errors.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      function createError(type, Proto) {
        const Err = function(message, cause) {
          if (typeof message === "object" && message !== null) {
            cause = cause || message;
            message = message.message || message.name;
          }
          message = message || "";
          cause = cause || void 0;
          if (typeof cause === "object" && cause.type === type && cause.message === message) {
            return cause;
          }
          Object.defineProperty(this, "type", { value: type, enumerable: false, writable: true, configurable: true });
          Object.defineProperty(this, "name", { value: type, enumerable: false, writable: true, configurable: true });
          Object.defineProperty(this, "cause", { value: cause, enumerable: false, writable: true, configurable: true });
          Object.defineProperty(this, "message", { value: message, enumerable: false, writable: true, configurable: true });
          Error.call(this);
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, Err);
          }
        };
        Err.prototype = new Proto();
        return Err;
      }
      var LevelUPError = createError("LevelUPError", Error);
      module2.exports = {
        LevelUPError,
        InitializationError: createError("InitializationError", LevelUPError),
        OpenError: createError("OpenError", LevelUPError),
        ReadError: createError("ReadError", LevelUPError),
        WriteError: createError("WriteError", LevelUPError),
        NotFoundError: createError("NotFoundError", LevelUPError),
        EncodingError: createError("EncodingError", LevelUPError)
      };
      module2.exports.NotFoundError.prototype.notFound = true;
      module2.exports.NotFoundError.prototype.status = 404;
    }
  });

  // node_modules/encoding-down/index.js
  var require_encoding_down = __commonJS({
    "node_modules/encoding-down/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
      var AbstractChainedBatch = require_abstract_leveldown2().AbstractChainedBatch;
      var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
      var inherits2 = require_inherits_browser();
      var Codec7 = require_level_codec();
      var EncodingError = require_errors().EncodingError;
      var rangeMethods = ["approximateSize", "compactRange"];
      module2.exports = DB;
      function DB(db, opts) {
        if (!(this instanceof DB))
          return new DB(db, opts);
        const manifest = db.supports || {};
        const additionalMethods = manifest.additionalMethods || {};
        AbstractLevelDOWN.call(this, manifest);
        this.supports.encodings = true;
        this.supports.additionalMethods = {};
        rangeMethods.forEach(function(m2) {
          const fallback = typeof db[m2] === "function";
          if (additionalMethods[m2] || fallback) {
            this.supports.additionalMethods[m2] = true;
            this[m2] = function(start, end, opts2, cb) {
              start = this.codec.encodeKey(start, opts2);
              end = this.codec.encodeKey(end, opts2);
              return this.db[m2](start, end, opts2, cb);
            };
          }
        }, this);
        opts = opts || {};
        if (typeof opts.keyEncoding === "undefined")
          opts.keyEncoding = "utf8";
        if (typeof opts.valueEncoding === "undefined")
          opts.valueEncoding = "utf8";
        this.db = db;
        this.codec = new Codec7(opts);
      }
      inherits2(DB, AbstractLevelDOWN);
      DB.prototype.type = "encoding-down";
      DB.prototype._serializeKey = DB.prototype._serializeValue = function(datum) {
        return datum;
      };
      DB.prototype._open = function(opts, cb) {
        this.db.open(opts, cb);
      };
      DB.prototype._close = function(cb) {
        this.db.close(cb);
      };
      DB.prototype._put = function(key, value, opts, cb) {
        key = this.codec.encodeKey(key, opts);
        value = this.codec.encodeValue(value, opts);
        this.db.put(key, value, opts, cb);
      };
      DB.prototype._get = function(key, opts, cb) {
        key = this.codec.encodeKey(key, opts);
        opts.asBuffer = this.codec.valueAsBuffer(opts);
        this.db.get(key, opts, (err, value) => {
          if (err)
            return cb(err);
          try {
            value = this.codec.decodeValue(value, opts);
          } catch (err2) {
            return cb(new EncodingError(err2));
          }
          cb(null, value);
        });
      };
      DB.prototype._getMany = function(keys, opts, cb) {
        keys = keys.map((key) => this.codec.encodeKey(key, opts));
        opts.asBuffer = this.codec.valueAsBuffer(opts);
        this.db.getMany(keys, opts, (err, values) => {
          if (err)
            return cb(err);
          const decoded = new Array(values.length);
          for (let i2 = 0; i2 < values.length; i2++) {
            if (values[i2] === void 0) {
              decoded[i2] = void 0;
              continue;
            }
            try {
              decoded[i2] = this.codec.decodeValue(values[i2], opts);
            } catch (err2) {
              return cb(new EncodingError(err2));
            }
          }
          cb(null, decoded);
        });
      };
      DB.prototype._del = function(key, opts, cb) {
        key = this.codec.encodeKey(key, opts);
        this.db.del(key, opts, cb);
      };
      DB.prototype._chainedBatch = function() {
        return new Batch(this);
      };
      DB.prototype._batch = function(ops, opts, cb) {
        ops = this.codec.encodeBatch(ops, opts);
        this.db.batch(ops, opts, cb);
      };
      DB.prototype._iterator = function(opts) {
        opts.keyAsBuffer = this.codec.keyAsBuffer(opts);
        opts.valueAsBuffer = this.codec.valueAsBuffer(opts);
        return new Iterator(this, opts);
      };
      DB.prototype._clear = function(opts, callback) {
        opts = this.codec.encodeLtgt(opts);
        this.db.clear(opts, callback);
      };
      function Iterator(db, opts) {
        AbstractIterator.call(this, db);
        this.codec = db.codec;
        this.keys = opts.keys;
        this.values = opts.values;
        this.opts = this.codec.encodeLtgt(opts);
        this.it = db.db.iterator(this.opts);
      }
      inherits2(Iterator, AbstractIterator);
      Iterator.prototype._next = function(cb) {
        this.it.next((err, key, value) => {
          if (err)
            return cb(err);
          try {
            if (this.keys && typeof key !== "undefined") {
              key = this.codec.decodeKey(key, this.opts);
            } else {
              key = void 0;
            }
            if (this.values && typeof value !== "undefined") {
              value = this.codec.decodeValue(value, this.opts);
            } else {
              value = void 0;
            }
          } catch (err2) {
            return cb(new EncodingError(err2));
          }
          cb(null, key, value);
        });
      };
      Iterator.prototype._seek = function(key) {
        key = this.codec.encodeKey(key, this.opts);
        this.it.seek(key);
      };
      Iterator.prototype._end = function(cb) {
        this.it.end(cb);
      };
      function Batch(db, codec) {
        AbstractChainedBatch.call(this, db);
        this.codec = db.codec;
        this.batch = db.db.batch();
      }
      inherits2(Batch, AbstractChainedBatch);
      Batch.prototype._put = function(key, value, options) {
        key = this.codec.encodeKey(key, options);
        value = this.codec.encodeValue(value, options);
        this.batch.put(key, value);
      };
      Batch.prototype._del = function(key, options) {
        key = this.codec.encodeKey(key, options);
        this.batch.del(key);
      };
      Batch.prototype._clear = function() {
        this.batch.clear();
      };
      Batch.prototype._write = function(opts, cb) {
        this.batch.write(opts, cb);
      };
    }
  });

  // node-modules-polyfills:process
  function defaultSetTimout2() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout2() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout2(fun) {
    if (cachedSetTimeout2 === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
      cachedSetTimeout2 = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout2(fun, 0);
    } catch (e2) {
      try {
        return cachedSetTimeout2.call(null, fun, 0);
      } catch (e3) {
        return cachedSetTimeout2.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout2(marker) {
    if (cachedClearTimeout2 === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
      cachedClearTimeout2 = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout2(marker);
    } catch (e2) {
      try {
        return cachedClearTimeout2.call(null, marker);
      } catch (e3) {
        return cachedClearTimeout2.call(this, marker);
      }
    }
  }
  function cleanUpNextTick2() {
    if (!draining2 || !currentQueue2) {
      return;
    }
    draining2 = false;
    if (currentQueue2.length) {
      queue2 = currentQueue2.concat(queue2);
    } else {
      queueIndex2 = -1;
    }
    if (queue2.length) {
      drainQueue2();
    }
  }
  function drainQueue2() {
    if (draining2) {
      return;
    }
    var timeout = runTimeout2(cleanUpNextTick2);
    draining2 = true;
    var len = queue2.length;
    while (len) {
      currentQueue2 = queue2;
      queue2 = [];
      while (++queueIndex2 < len) {
        if (currentQueue2) {
          currentQueue2[queueIndex2].run();
        }
      }
      queueIndex2 = -1;
      len = queue2.length;
    }
    currentQueue2 = null;
    draining2 = false;
    runClearTimeout2(timeout);
  }
  function nextTick2(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue2.push(new Item2(fun, args));
    if (queue2.length === 1 && !draining2) {
      runTimeout2(drainQueue2);
    }
  }
  function Item2(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop2() {
  }
  function binding2(name6) {
    throw new Error("process.binding is not supported");
  }
  function cwd2() {
    return "/";
  }
  function chdir2(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask2() {
    return 0;
  }
  function hrtime2(previousTimestamp) {
    var clocktime = performanceNow2.call(performance3) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime2() {
    var currentTime = new Date();
    var dif = currentTime - startTime2;
    return dif / 1e3;
  }
  var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform2, browser2, env2, argv2, version2, versions2, release2, config2, on2, addListener3, once3, off2, removeListener3, removeAllListeners3, emit3, performance3, performanceNow2, startTime2, browser$1, process_default;
  var init_process = __esm({
    "node-modules-polyfills:process"() {
      init_virtual_process_polyfill();
      cachedSetTimeout2 = defaultSetTimout2;
      cachedClearTimeout2 = defaultClearTimeout2;
      if (typeof globalThis.setTimeout === "function") {
        cachedSetTimeout2 = setTimeout;
      }
      if (typeof globalThis.clearTimeout === "function") {
        cachedClearTimeout2 = clearTimeout;
      }
      queue2 = [];
      draining2 = false;
      queueIndex2 = -1;
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title2 = "browser";
      platform2 = "browser";
      browser2 = true;
      env2 = {};
      argv2 = [];
      version2 = "";
      versions2 = {};
      release2 = {};
      config2 = {};
      on2 = noop2;
      addListener3 = noop2;
      once3 = noop2;
      off2 = noop2;
      removeListener3 = noop2;
      removeAllListeners3 = noop2;
      emit3 = noop2;
      performance3 = globalThis.performance || {};
      performanceNow2 = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
        return new Date().getTime();
      };
      startTime2 = new Date();
      browser$1 = {
        nextTick: nextTick2,
        title: title2,
        browser: browser2,
        env: env2,
        argv: argv2,
        version: version2,
        versions: versions2,
        on: on2,
        addListener: addListener3,
        once: once3,
        off: off2,
        removeListener: removeListener3,
        removeAllListeners: removeAllListeners3,
        emit: emit3,
        binding: binding2,
        cwd: cwd2,
        chdir: chdir2,
        umask: umask2,
        hrtime: hrtime2,
        platform: platform2,
        release: release2,
        config: config2,
        uptime: uptime2
      };
      process_default = browser$1;
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
  var inherits, inherits_default;
  var init_inherits = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
      init_virtual_process_polyfill();
      if (typeof Object.create === "function") {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      inherits_default = inherits;
    }
  });

  // node-modules-polyfills:util
  var util_exports = {};
  __export(util_exports, {
    _extend: () => _extend,
    debuglog: () => debuglog,
    default: () => util_default,
    deprecate: () => deprecate,
    format: () => format2,
    inherits: () => inherits_default,
    inspect: () => inspect2,
    isArray: () => isArray2,
    isBoolean: () => isBoolean,
    isBuffer: () => isBuffer4,
    isDate: () => isDate,
    isError: () => isError,
    isFunction: () => isFunction,
    isNull: () => isNull,
    isNullOrUndefined: () => isNullOrUndefined,
    isNumber: () => isNumber,
    isObject: () => isObject,
    isPrimitive: () => isPrimitive,
    isRegExp: () => isRegExp,
    isString: () => isString,
    isSymbol: () => isSymbol,
    isUndefined: () => isUndefined,
    log: () => log
  });
  function format2(f2) {
    if (!isString(f2)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect2(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f2).replace(formatRegExp, function(x3) {
      if (x3 === "%%")
        return "%";
      if (i2 >= len)
        return x3;
      switch (x3) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_3) {
            return "[Circular]";
          }
        default:
          return x3;
      }
    });
    for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
      if (isNull(x2) || !isObject(x2)) {
        str += " " + x2;
      } else {
        str += " " + inspect2(x2);
      }
    }
    return str;
  }
  function deprecate(fn, msg) {
    if (isUndefined(globalThis.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (process_default.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process_default.throwDeprecation) {
          throw new Error(msg);
        } else if (process_default.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = process_default.env.NODE_DEBUG || "";
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format2.apply(null, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else {
        debugs[set] = function() {
        };
      }
    }
    return debugs[set];
  }
  function inspect2(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  function stylizeWithColor(str, styleType) {
    var style = inspect2.styles[styleType];
    if (style) {
      return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name6 = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name6 + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base7 = "", array = false, braces = ["{", "}"];
    if (isArray2(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction(value)) {
      var n2 = value.name ? ": " + value.name : "";
      base7 = " [Function" + n2 + "]";
    }
    if (isRegExp(value)) {
      base7 = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base7 = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base7 = " " + formatError(value);
    }
    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base7 + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base7, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) {
      if (hasOwnProperty(value, String(i2))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i2),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name6, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name6 = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name6)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name6 = JSON.stringify("" + key);
      if (name6.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name6 = name6.substr(1, name6.length - 2);
        name6 = ctx.stylize(name6, "name");
      } else {
        name6 = name6.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name6 = ctx.stylize(name6, "string");
      }
    }
    return name6 + ": " + str;
  }
  function reduceToSingleString(output, base7, braces) {
    var numLinesEst = 0;
    var length7 = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf("\n") >= 0)
        numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length7 > 60) {
      return braces[0] + (base7 === "" ? "" : base7 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base7 + " " + output.join(", ") + " " + braces[1];
  }
  function isArray2(ar) {
    return Array.isArray(ar);
  }
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber(arg) {
    return typeof arg === "number";
  }
  function isString(arg) {
    return typeof arg === "string";
  }
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp(re2) {
    return isObject(re2) && objectToString(re2) === "[object RegExp]";
  }
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate(d2) {
    return isObject(d2) && objectToString(d2) === "[object Date]";
  }
  function isError(e2) {
    return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
  }
  function isFunction(arg) {
    return typeof arg === "function";
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  function isBuffer4(maybeBuf) {
    return Buffer.isBuffer(maybeBuf);
  }
  function objectToString(o2) {
    return Object.prototype.toString.call(o2);
  }
  function pad(n2) {
    return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
  }
  function timestamp() {
    var d2 = new Date();
    var time = [
      pad(d2.getHours()),
      pad(d2.getMinutes()),
      pad(d2.getSeconds())
    ].join(":");
    return [d2.getDate(), months[d2.getMonth()], time].join(" ");
  }
  function log() {
    console.log("%s - %s", timestamp(), format2.apply(null, arguments));
  }
  function _extend(origin, add) {
    if (!add || !isObject(add))
      return origin;
    var keys = Object.keys(add);
    var i2 = keys.length;
    while (i2--) {
      origin[keys[i2]] = add[keys[i2]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var formatRegExp, debugs, debugEnviron, months, util_default;
  var init_util = __esm({
    "node-modules-polyfills:util"() {
      init_virtual_process_polyfill();
      init_process();
      init_inherits();
      formatRegExp = /%[sdj%]/g;
      debugs = {};
      inspect2.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect2.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      util_default = {
        inherits: inherits_default,
        _extend,
        log,
        isBuffer: isBuffer4,
        isPrimitive,
        isFunction,
        isError,
        isDate,
        isObject,
        isRegExp,
        isUndefined,
        isSymbol,
        isString,
        isNumber,
        isNullOrUndefined,
        isNull,
        isBoolean,
        isArray: isArray2,
        inspect: inspect2,
        deprecate,
        format: format2,
        debuglog
      };
    }
  });

  // node-modules-polyfills-commonjs:util
  var require_util = __commonJS({
    "node-modules-polyfills-commonjs:util"(exports2, module2) {
      init_virtual_process_polyfill();
      var polyfill = (init_util(), __toCommonJS(util_exports));
      if (polyfill && polyfill.default) {
        module2.exports = polyfill.default;
        for (let k2 in polyfill) {
          module2.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module2.exports = polyfill;
      }
    }
  });

  // node_modules/deferred-leveldown/util.js
  var require_util2 = __commonJS({
    "node_modules/deferred-leveldown/util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      exports2.getCallback = function(args, symbol, map) {
        let callback = args[args.length - 1];
        if (typeof callback !== "function") {
          const promise = new Promise((resolve5, reject) => {
            args.push(callback = function(err, ...results) {
              if (err)
                reject(err);
              else
                resolve5(map ? map(...results) : results[0]);
            });
          });
          callback[symbol] = promise;
        }
        return callback;
      };
    }
  });

  // node_modules/deferred-leveldown/deferred-iterator.js
  var require_deferred_iterator2 = __commonJS({
    "node_modules/deferred-leveldown/deferred-iterator.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractIterator } = require_abstract_leveldown2();
      var inherits2 = require_inherits_browser();
      var getCallback = require_util2().getCallback;
      var kOptions = Symbol("options");
      var kIterator = Symbol("iterator");
      var kOperations = Symbol("operations");
      var kPromise = Symbol("promise");
      function DeferredIterator(db, options) {
        AbstractIterator.call(this, db);
        this[kOptions] = options;
        this[kIterator] = null;
        this[kOperations] = [];
      }
      inherits2(DeferredIterator, AbstractIterator);
      DeferredIterator.prototype.setDb = function(db) {
        this[kIterator] = db.iterator(this[kOptions]);
        for (const op of this[kOperations].splice(0, this[kOperations].length)) {
          this[kIterator][op.method](...op.args);
        }
      };
      DeferredIterator.prototype.next = function(...args) {
        if (this.db.status === "open") {
          return this[kIterator].next(...args);
        }
        const callback = getCallback(args, kPromise, function map(key, value) {
          if (key === void 0 && value === void 0) {
            return void 0;
          } else {
            return [key, value];
          }
        });
        if (this.db.status === "opening") {
          this[kOperations].push({ method: "next", args });
        } else {
          this._nextTick(callback, new Error("Database is not open"));
        }
        return callback[kPromise] || this;
      };
      DeferredIterator.prototype.seek = function(...args) {
        if (this.db.status === "open") {
          this[kIterator].seek(...args);
        } else if (this.db.status === "opening") {
          this[kOperations].push({ method: "seek", args });
        } else {
          throw new Error("Database is not open");
        }
      };
      DeferredIterator.prototype.end = function(...args) {
        if (this.db.status === "open") {
          return this[kIterator].end(...args);
        }
        const callback = getCallback(args, kPromise);
        if (this.db.status === "opening") {
          this[kOperations].push({ method: "end", args });
        } else {
          this._nextTick(callback, new Error("Database is not open"));
        }
        return callback[kPromise] || this;
      };
      for (const method of ["next", "seek", "end"]) {
        DeferredIterator.prototype["_" + method] = function() {
          throw new Error("Did not expect private method to be called: " + method);
        };
      }
      module2.exports = DeferredIterator;
    }
  });

  // node_modules/deferred-leveldown/deferred-chained-batch.js
  var require_deferred_chained_batch = __commonJS({
    "node_modules/deferred-leveldown/deferred-chained-batch.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractChainedBatch } = require_abstract_leveldown2();
      var kOperations = Symbol("operations");
      module2.exports = class DeferredChainedBatch extends AbstractChainedBatch {
        constructor(db) {
          super(db);
          this[kOperations] = [];
        }
        _put(key, value, options) {
          this[kOperations].push({ ...options, type: "put", key, value });
        }
        _del(key, options) {
          this[kOperations].push({ ...options, type: "del", key });
        }
        _clear() {
          this[kOperations] = [];
        }
        _write(options, callback) {
          this.db.batch(this[kOperations], options, callback);
        }
      };
    }
  });

  // node_modules/deferred-leveldown/deferred-leveldown.js
  var require_deferred_leveldown = __commonJS({
    "node_modules/deferred-leveldown/deferred-leveldown.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var { AbstractLevelDOWN } = require_abstract_leveldown2();
      var inherits2 = require_inherits_browser();
      var DeferredIterator = require_deferred_iterator2();
      var DeferredChainedBatch = require_deferred_chained_batch();
      var getCallback = require_util2().getCallback;
      var deferrables = ["put", "get", "getMany", "del", "batch", "clear"];
      var optionalDeferrables = ["approximateSize", "compactRange"];
      var kInnerDb = Symbol("innerDb");
      var kOperations = Symbol("operations");
      var kPromise = Symbol("promise");
      function DeferredLevelDOWN(db) {
        AbstractLevelDOWN.call(this, db.supports || {});
        for (const m2 of optionalDeferrables) {
          if (typeof db[m2] === "function" && !this.supports.additionalMethods[m2]) {
            this.supports.additionalMethods[m2] = true;
          }
        }
        this[kInnerDb] = db;
        this[kOperations] = [];
        implement(this);
      }
      inherits2(DeferredLevelDOWN, AbstractLevelDOWN);
      DeferredLevelDOWN.prototype.type = "deferred-leveldown";
      Object.defineProperty(DeferredLevelDOWN.prototype, "_db", {
        enumerable: true,
        get() {
          return this[kInnerDb];
        }
      });
      DeferredLevelDOWN.prototype._open = function(options, callback) {
        const onopen = (err) => {
          if (err || this[kInnerDb].status !== "open") {
            return callback(err || new Error("Database is not open"));
          }
          const operations = this[kOperations];
          this[kOperations] = [];
          for (const op of operations) {
            if (op.iterator) {
              op.iterator.setDb(this[kInnerDb]);
            } else {
              this[kInnerDb][op.method](...op.args);
            }
          }
          if (this[kOperations].length > 0) {
            throw new Error("Did not expect further operations");
          }
          callback();
        };
        if (this[kInnerDb].status === "new" || this[kInnerDb].status === "closed") {
          this[kInnerDb].open(options, onopen);
        } else {
          this._nextTick(onopen);
        }
      };
      DeferredLevelDOWN.prototype._close = function(callback) {
        this[kInnerDb].close(callback);
      };
      DeferredLevelDOWN.prototype._isOperational = function() {
        return this.status === "opening";
      };
      function implement(self2) {
        const additionalMethods = Object.keys(self2.supports.additionalMethods);
        for (const method of deferrables.concat(additionalMethods)) {
          self2[method] = function(...args) {
            if (method === "batch" && args.length === 0) {
              return new DeferredChainedBatch(this);
            } else if (this.status === "open") {
              return this[kInnerDb][method](...args);
            }
            const callback = getCallback(args, kPromise);
            if (this.status === "opening") {
              this[kOperations].push({ method, args });
            } else {
              this._nextTick(callback, new Error("Database is not open"));
            }
            return callback[kPromise];
          };
        }
        self2.iterator = function(options) {
          if (this.status === "open") {
            return this[kInnerDb].iterator(options);
          } else if (this.status === "opening") {
            const iterator = new DeferredIterator(this, options);
            this[kOperations].push({ iterator });
            return iterator;
          } else {
            throw new Error("Database is not open");
          }
        };
        for (const method of deferrables.concat(["iterator"])) {
          self2["_" + method] = function() {
            throw new Error("Did not expect private method to be called: " + method);
          };
        }
      }
      module2.exports = DeferredLevelDOWN;
      module2.exports.DeferredIterator = DeferredIterator;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = require_events().EventEmitter;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? arguments[i2] : {};
          if (i2 % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor2 = props[i2];
          descriptor2.enumerable = descriptor2.enumerable || false;
          descriptor2.configurable = true;
          if ("value" in descriptor2)
            descriptor2.writable = true;
          Object.defineProperty(target, descriptor2.key, descriptor2);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src7, target, offset) {
        Buffer3.prototype.copy.call(src7, target, offset);
      }
      module2.exports = /* @__PURE__ */ function() {
        function BufferList3() {
          _classCallCheck(this, BufferList3);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList3, [{
          key: "push",
          value: function push(v2) {
            var entry = {
              data: v2,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v2) {
            var entry = {
              data: v2,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s2) {
            if (this.length === 0)
              return "";
            var p2 = this.head;
            var ret = "" + p2.data;
            while (p2 = p2.next) {
              ret += s2 + p2.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat4(n2) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n2 >>> 0);
            var p2 = this.head;
            var i2 = 0;
            while (p2) {
              copyBuffer(p2.data, ret, i2);
              i2 += p2.data.length;
              p2 = p2.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n2, hasStrings) {
            var ret;
            if (n2 < this.head.data.length) {
              ret = this.head.data.slice(0, n2);
              this.head.data = this.head.data.slice(n2);
            } else if (n2 === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n2) {
            var p2 = this.head;
            var c2 = 1;
            var ret = p2.data;
            n2 -= ret.length;
            while (p2 = p2.next) {
              var str = p2.data;
              var nb = n2 > str.length ? str.length : n2;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n2);
              n2 -= nb;
              if (n2 === 0) {
                if (nb === str.length) {
                  ++c2;
                  if (p2.next)
                    this.head = p2.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p2;
                  p2.data = str.slice(nb);
                }
                break;
              }
              ++c2;
            }
            this.length -= c2;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n2) {
            var ret = Buffer3.allocUnsafe(n2);
            var p2 = this.head;
            var c2 = 1;
            p2.data.copy(ret);
            n2 -= p2.data.length;
            while (p2 = p2.next) {
              var buf2 = p2.data;
              var nb = n2 > buf2.length ? buf2.length : n2;
              buf2.copy(ret, ret.length - n2, 0, nb);
              n2 -= nb;
              if (n2 === 0) {
                if (nb === buf2.length) {
                  ++c2;
                  if (p2.next)
                    this.head = p2.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p2;
                  p2.data = buf2.slice(nb);
                }
                break;
              }
              ++c2;
            }
            this.length -= c2;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_3, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList3;
      }();
    }
  });

  // node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module2.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/readable-stream/errors-browser.js
  var require_errors_browser = __commonJS({
    "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code8, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code8;
        codes[code8] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i2) {
            return String(i2);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name6, value) {
        return 'The value "' + value + '" is invalid for option "' + name6 + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name6, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name6, " argument")) {
          msg = "The ".concat(name6, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes2(name6, ".") ? "property" : "argument";
          msg = 'The "'.concat(name6, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name6) {
        return "The " + name6 + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name6) {
        return "Cannot call " + name6 + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module2.exports.codes = codes;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name6 = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name6, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module2.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/util-deprecate/browser.js
  var require_browser2 = __commonJS({
    "node_modules/util-deprecate/browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = deprecate7;
      function deprecate7(fn, msg) {
        if (config3("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config3("throwDeprecation")) {
              throw new Error(msg);
            } else if (config3("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config3(name6) {
        try {
          if (!globalThis.localStorage)
            return false;
        } catch (_3) {
          return false;
        }
        var val = globalThis.localStorage[name6];
        if (null == val)
          return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_3) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get2() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get2() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last2 = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last2) {
            last2.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l2 = state.bufferedRequestCount;
          var buffer2 = new Array(l2);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer2[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer2.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get2() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get2() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module2.exports = Duplex;
      var Readable = require_stream_readable();
      var Writable = require_stream_writable();
      require_inherits_browser()(Duplex, Readable);
      {
        keys = objectKeys(Writable.prototype);
        for (v2 = 0; v2 < keys.length; v2++) {
          method = keys[v2];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v2;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get2() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get2() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get2() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get2() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var buffer2 = require_buffer();
      var Buffer3 = buffer2.Buffer;
      function copyProps(src7, dst) {
        for (var key in src7) {
          dst[key] = src7[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module2.exports = buffer2;
      } else {
        copyProps(buffer2, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length7) {
        return Buffer3(arg, encodingOrOffset, length7);
      }
      SafeBuffer.prototype = Object.create(Buffer3.prototype);
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length7) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length7);
      };
      SafeBuffer.alloc = function(size, fill2, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf2 = Buffer3(size);
        if (fill2 !== void 0) {
          if (typeof encoding === "string") {
            buf2.fill(fill2, encoding);
          } else {
            buf2.fill(fill2);
          }
        } else {
          buf2.fill(0);
        }
        return buf2;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size);
      };
    }
  });

  // node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var Buffer3 = require_safe_buffer().Buffer;
      var isEncoding2 = Buffer3.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding2 || !isEncoding2(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports2.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer3.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf2) {
        if (buf2.length === 0)
          return "";
        var r2;
        var i2;
        if (this.lastNeed) {
          r2 = this.fillLast(buf2);
          if (r2 === void 0)
            return "";
          i2 = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i2 = 0;
        }
        if (i2 < buf2.length)
          return r2 ? r2 + this.text(buf2, i2) : this.text(buf2, i2);
        return r2 || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf2) {
        if (this.lastNeed <= buf2.length) {
          buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf2.length);
        this.lastNeed -= buf2.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf2, i2) {
        var j2 = buf2.length - 1;
        if (j2 < i2)
          return 0;
        var nb = utf8CheckByte(buf2[j2]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j2 < i2 || nb === -2)
          return 0;
        nb = utf8CheckByte(buf2[j2]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j2 < i2 || nb === -2)
          return 0;
        nb = utf8CheckByte(buf2[j2]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf2, p2) {
        if ((buf2[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf2.length > 1) {
          if ((buf2[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf2.length > 2) {
            if ((buf2[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf2) {
        var p2 = this.lastTotal - this.lastNeed;
        var r2 = utf8CheckExtraBytes(this, buf2, p2);
        if (r2 !== void 0)
          return r2;
        if (this.lastNeed <= buf2.length) {
          buf2.copy(this.lastChar, p2, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf2.copy(this.lastChar, p2, 0, buf2.length);
        this.lastNeed -= buf2.length;
      }
      function utf8Text(buf2, i2) {
        var total = utf8CheckIncomplete(this, buf2, i2);
        if (!this.lastNeed)
          return buf2.toString("utf8", i2);
        this.lastTotal = total;
        var end = buf2.length - (total - this.lastNeed);
        buf2.copy(this.lastChar, 0, end);
        return buf2.toString("utf8", i2, end);
      }
      function utf8End(buf2) {
        var r2 = buf2 && buf2.length ? this.write(buf2) : "";
        if (this.lastNeed)
          return r2 + "\uFFFD";
        return r2;
      }
      function utf16Text(buf2, i2) {
        if ((buf2.length - i2) % 2 === 0) {
          var r2 = buf2.toString("utf16le", i2);
          if (r2) {
            var c2 = r2.charCodeAt(r2.length - 1);
            if (c2 >= 55296 && c2 <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf2[buf2.length - 2];
              this.lastChar[1] = buf2[buf2.length - 1];
              return r2.slice(0, -1);
            }
          }
          return r2;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf2[buf2.length - 1];
        return buf2.toString("utf16le", i2, buf2.length - 1);
      }
      function utf16End(buf2) {
        var r2 = buf2 && buf2.length ? this.write(buf2) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r2 + this.lastChar.toString("utf16le", 0, end);
        }
        return r2;
      }
      function base64Text(buf2, i2) {
        var n2 = (buf2.length - i2) % 3;
        if (n2 === 0)
          return buf2.toString("base64", i2);
        this.lastNeed = 3 - n2;
        this.lastTotal = 3;
        if (n2 === 1) {
          this.lastChar[0] = buf2[buf2.length - 1];
        } else {
          this.lastChar[0] = buf2[buf2.length - 2];
          this.lastChar[1] = buf2[buf2.length - 1];
        }
        return buf2.toString("base64", i2, buf2.length - n2);
      }
      function base64End(buf2) {
        var r2 = buf2 && buf2.length ? this.write(buf2) : "";
        if (this.lastNeed)
          return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r2;
      }
      function simpleWrite(buf2) {
        return buf2.toString(this.encoding);
      }
      function simpleEnd(buf2) {
        return buf2 && buf2.length ? this.write(buf2) : "";
      }
    }
  });

  // node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once4(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop3() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once4(callback || noop3);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module2.exports = eos;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve5 = iter[kLastResolve];
        if (resolve5 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve5(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve5, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve5(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve5, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve5, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve5(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve5, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve5(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve5, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve5(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve5;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve5 = iterator[kLastResolve];
          if (resolve5 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve5(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module2.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = Readable;
      var Duplex;
      Readable.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList3 = require_buffer_list();
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from12;
      require_inherits_browser()(Readable, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener2(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList3();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!(this instanceof Readable))
          return new Readable(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable.prototype, "destroyed", {
        enumerable: false,
        get: function get2() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p2 = this._readableState.buffer.head;
        var content = "";
        while (p2 !== null) {
          content += decoder.write(p2.data);
          p2 = p2.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n2) {
        if (n2 >= MAX_HWM) {
          n2 = MAX_HWM;
        } else {
          n2--;
          n2 |= n2 >>> 1;
          n2 |= n2 >>> 2;
          n2 |= n2 >>> 4;
          n2 |= n2 >>> 8;
          n2 |= n2 >>> 16;
          n2++;
        }
        return n2;
      }
      function howMuchToRead(n2, state) {
        if (n2 <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n2 !== n2) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n2 > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n2);
        if (n2 <= state.length)
          return n2;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n2) {
        debug("read", n2);
        n2 = parseInt(n2, 10);
        var state = this._readableState;
        var nOrig = n2;
        if (n2 !== 0)
          state.emittedReadable = false;
        if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n2 = howMuchToRead(n2, state);
        if (n2 === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n2 < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n2 = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n2 > 0)
          ret = fromList(n2, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n2 = 0;
        } else {
          state.length -= n2;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n2 && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n2) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src7 = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src7.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src7) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src7);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src7.removeListener("end", onend);
          src7.removeListener("end", unpipe);
          src7.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src7.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src7.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src7.unpipe(dest);
        }
        dest.emit("pipe", src7);
        if (!state.flowing) {
          debug("pipe resume");
          src7.resume();
        }
        return dest;
      };
      function pipeOnDrain(src7) {
        return function pipeOnDrainFunctionResult() {
          var state = src7._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src7, "data")) {
            state.flowing = true;
            flow(src7);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i2 = 0; i2 < len; i2++) {
            dests[i2].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf2(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i2 in stream) {
          if (this[i2] === void 0 && typeof stream[i2] === "function") {
            this[i2] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i2);
          }
        }
        for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
          stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
        }
        this._read = function(n3) {
          debug("wrapped _read", n3);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get2() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable.prototype, "readableBuffer", {
        enumerable: false,
        get: function get2() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable.prototype, "readableFlowing", {
        enumerable: false,
        get: function get2() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable._fromList = fromList;
      Object.defineProperty(Readable.prototype, "readableLength", {
        enumerable: false,
        get: function get2() {
          return this._readableState.length;
        }
      });
      function fromList(n2, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n2 || n2 >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n2, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable.from = function(iterable, opts) {
          if (from12 === void 0) {
            from12 = require_from_browser();
          }
          return from12(Readable, iterable, opts);
        };
      }
      function indexOf2(xs, x2) {
        for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
          if (xs[i2] === x2)
            return i2;
        }
        return -1;
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = Transform;
      var _require$codes = require_errors_browser().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n2) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = PassThrough;
      var Transform = require_stream_transform();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var eos;
      function once4(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop3(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once4(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from12, to) {
        return from12.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop3;
        if (typeof streams[streams.length - 1] !== "function")
          return noop3;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i2) {
          var reading = i2 < streams.length - 1;
          var writing = i2 > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module2.exports = pipeline;
    }
  });

  // node_modules/readable-stream/readable-browser.js
  var require_readable_browser = __commonJS({
    "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  });

  // node_modules/level-iterator-stream/index.js
  var require_level_iterator_stream = __commonJS({
    "node_modules/level-iterator-stream/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var inherits2 = require_inherits_browser();
      var { Readable } = require_readable_browser();
      module2.exports = ReadStream;
      inherits2(ReadStream, Readable);
      function ReadStream(iterator, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(iterator, options);
        options = options || {};
        Readable.call(this, Object.assign({}, options, {
          objectMode: true
        }));
        this._iterator = iterator;
        this._options = options;
        this.on("end", this.destroy.bind(this, null, null));
      }
      ReadStream.prototype._read = function() {
        if (this.destroyed)
          return;
        this._iterator.next((err, key, value) => {
          if (this.destroyed)
            return;
          if (err)
            return this.destroy(err);
          if (key === void 0 && value === void 0) {
            this.push(null);
          } else if (this._options.keys !== false && this._options.values === false) {
            this.push(key);
          } else if (this._options.keys === false && this._options.values !== false) {
            this.push(value);
          } else {
            this.push({ key, value });
          }
        });
      };
      ReadStream.prototype._destroy = function(err, callback) {
        this._iterator.end(function(err2) {
          callback(err || err2);
        });
      };
    }
  });

  // node_modules/levelup/lib/common.js
  var require_common3 = __commonJS({
    "node_modules/levelup/lib/common.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      exports2.getCallback = function(options, callback) {
        return typeof options === "function" ? options : callback;
      };
      exports2.getOptions = function(options) {
        return typeof options === "object" && options !== null ? options : {};
      };
    }
  });

  // node_modules/levelup/lib/batch.js
  var require_batch = __commonJS({
    "node_modules/levelup/lib/batch.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var WriteError = require_errors().WriteError;
      var catering = require_catering();
      var getCallback = require_common3().getCallback;
      var getOptions = require_common3().getOptions;
      function Batch(levelup) {
        this.db = levelup;
        this.batch = levelup.db.batch();
        this.ops = [];
        this.length = 0;
      }
      Batch.prototype.put = function(key, value, options) {
        try {
          this.batch.put(key, value, options);
        } catch (e2) {
          throw new WriteError(e2);
        }
        this.ops.push({ ...options, type: "put", key, value });
        this.length++;
        return this;
      };
      Batch.prototype.del = function(key, options) {
        try {
          this.batch.del(key, options);
        } catch (err) {
          throw new WriteError(err);
        }
        this.ops.push({ ...options, type: "del", key });
        this.length++;
        return this;
      };
      Batch.prototype.clear = function() {
        try {
          this.batch.clear();
        } catch (err) {
          throw new WriteError(err);
        }
        this.ops = [];
        this.length = 0;
        return this;
      };
      Batch.prototype.write = function(options, callback) {
        const levelup = this.db;
        const ops = this.ops;
        callback = getCallback(options, callback);
        callback = catering.fromCallback(callback);
        options = getOptions(options);
        try {
          this.batch.write(options, function(err) {
            if (err) {
              return callback(new WriteError(err));
            }
            levelup.emit("batch", ops);
            callback();
          });
        } catch (err) {
          throw new WriteError(err);
        }
        return callback.promise;
      };
      module2.exports = Batch;
    }
  });

  // node_modules/levelup/node_modules/level-supports/index.js
  var require_level_supports3 = __commonJS({
    "node_modules/levelup/node_modules/level-supports/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = function supports(...manifests) {
        const manifest = manifests.reduce((acc, m2) => Object.assign(acc, m2), {});
        return Object.assign(manifest, {
          bufferKeys: manifest.bufferKeys || false,
          snapshots: manifest.snapshots || false,
          permanence: manifest.permanence || false,
          seek: manifest.seek || false,
          clear: manifest.clear || false,
          getMany: manifest.getMany || false,
          keyIterator: manifest.keyIterator || false,
          valueIterator: manifest.valueIterator || false,
          iteratorNextv: manifest.iteratorNextv || false,
          iteratorAll: manifest.iteratorAll || false,
          status: manifest.status || false,
          idempotentOpen: manifest.idempotentOpen || false,
          passiveOpen: manifest.passiveOpen || false,
          serialize: manifest.serialize || false,
          createIfMissing: manifest.createIfMissing || false,
          errorIfExists: manifest.errorIfExists || false,
          deferredOpen: manifest.deferredOpen || false,
          openCallback: manifest.openCallback || false,
          promises: manifest.promises || false,
          streams: manifest.streams || false,
          encodings: maybeObject(manifest.encodings),
          events: maybeObject(manifest.events),
          additionalMethods: Object.assign({}, manifest.additionalMethods)
        });
      };
      function maybeObject(value) {
        return !value ? false : Object.assign({}, value);
      }
    }
  });

  // node_modules/levelup/lib/next-tick-browser.js
  var require_next_tick_browser4 = __commonJS({
    "node_modules/levelup/lib/next-tick-browser.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var queueMicrotask2 = require_queue_microtask();
      module2.exports = function(fn, ...args) {
        if (args.length === 0) {
          queueMicrotask2(fn);
        } else {
          queueMicrotask2(() => fn(...args));
        }
      };
    }
  });

  // node_modules/levelup/lib/levelup.js
  var require_levelup = __commonJS({
    "node_modules/levelup/lib/levelup.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var EventEmitter3 = require_events().EventEmitter;
      var inherits2 = require_util().inherits;
      var DeferredLevelDOWN = require_deferred_leveldown();
      var IteratorStream = require_level_iterator_stream();
      var Batch = require_batch();
      var errors = require_errors();
      var supports = require_level_supports3();
      var catering = require_catering();
      var getCallback = require_common3().getCallback;
      var getOptions = require_common3().getOptions;
      var nextTick3 = require_next_tick_browser4();
      var WriteError = errors.WriteError;
      var ReadError = errors.ReadError;
      var NotFoundError = errors.NotFoundError;
      var OpenError = errors.OpenError;
      var InitializationError = errors.InitializationError;
      function LevelUP(db, options, callback) {
        if (!(this instanceof LevelUP)) {
          return new LevelUP(db, options, callback);
        }
        let error;
        EventEmitter3.call(this);
        this.setMaxListeners(Infinity);
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        if (!db || typeof db !== "object") {
          error = new InitializationError("First argument must be an abstract-leveldown compliant store");
          if (typeof callback === "function") {
            return nextTick3(callback, error);
          }
          throw error;
        }
        if (typeof db.status !== "string") {
          throw new Error(".status required, old abstract-leveldown");
        }
        this.options = getOptions(options);
        this._db = db;
        this.db = null;
        this.open(callback || ((err) => {
          if (err)
            this.emit("error", err);
        }));
        this.supports = supports(this.db.supports, {
          status: true,
          deferredOpen: true,
          openCallback: true,
          promises: true,
          streams: true
        });
        for (const method of Object.keys(this.supports.additionalMethods)) {
          if (this[method] != null)
            continue;
          this[method] = function(...args) {
            return this.db[method](...args);
          };
        }
      }
      LevelUP.prototype.emit = EventEmitter3.prototype.emit;
      LevelUP.prototype.once = EventEmitter3.prototype.once;
      inherits2(LevelUP, EventEmitter3);
      Object.defineProperty(LevelUP.prototype, "status", {
        enumerable: true,
        get() {
          return this.db.status;
        }
      });
      LevelUP.prototype.isOperational = function() {
        return this.db.status === "open" || this.db.status === "opening";
      };
      LevelUP.prototype.open = function(opts, callback) {
        if (typeof opts === "function") {
          callback = opts;
          opts = null;
        }
        callback = catering.fromCallback(callback);
        if (!opts) {
          opts = this.options;
        }
        if (this.db && this.isOpen()) {
          nextTick3(callback, null, this);
          return callback.promise;
        }
        if (this.db && this._isOpening()) {
          this.once("open", () => {
            callback(null, this);
          });
          return callback.promise;
        }
        this.db = new DeferredLevelDOWN(this._db);
        this.emit("opening");
        this.db.open(opts, (err) => {
          if (err) {
            return callback(new OpenError(err));
          }
          this.db = this._db;
          callback(null, this);
          this.emit("open");
          this.emit("ready");
        });
        return callback.promise;
      };
      LevelUP.prototype.close = function(callback) {
        callback = catering.fromCallback(callback);
        if (this.isOpen()) {
          this.db.close((err, ...rest) => {
            this.emit("closed");
            callback(err, ...rest);
          });
          this.emit("closing");
        } else if (this.isClosed()) {
          nextTick3(callback);
        } else if (this.db.status === "closing") {
          this.once("closed", callback);
        } else if (this._isOpening()) {
          this.once("open", () => {
            this.close(callback);
          });
        }
        return callback.promise;
      };
      LevelUP.prototype.isOpen = function() {
        return this.db.status === "open";
      };
      LevelUP.prototype._isOpening = function() {
        return this.db.status === "opening";
      };
      LevelUP.prototype.isClosed = function() {
        return /^clos|new/.test(this.db.status);
      };
      LevelUP.prototype.get = function(key, options, callback) {
        callback = getCallback(options, callback);
        callback = catering.fromCallback(callback);
        if (maybeError(this, callback)) {
          return callback.promise;
        }
        options = getOptions(options);
        this.db.get(key, options, function(err, value) {
          if (err) {
            if (/notfound/i.test(err) || err.notFound) {
              err = new NotFoundError("Key not found in database [" + key + "]", err);
            } else {
              err = new ReadError(err);
            }
            return callback(err);
          }
          callback(null, value);
        });
        return callback.promise;
      };
      LevelUP.prototype.getMany = function(keys, options, callback) {
        return this.db.getMany(keys, options, callback);
      };
      LevelUP.prototype.put = function(key, value, options, callback) {
        callback = getCallback(options, callback);
        callback = catering.fromCallback(callback);
        if (maybeError(this, callback)) {
          return callback.promise;
        }
        options = getOptions(options);
        this.db.put(key, value, options, (err) => {
          if (err) {
            return callback(new WriteError(err));
          }
          this.emit("put", key, value);
          callback();
        });
        return callback.promise;
      };
      LevelUP.prototype.del = function(key, options, callback) {
        callback = getCallback(options, callback);
        callback = catering.fromCallback(callback);
        if (maybeError(this, callback)) {
          return callback.promise;
        }
        options = getOptions(options);
        this.db.del(key, options, (err) => {
          if (err) {
            return callback(new WriteError(err));
          }
          this.emit("del", key);
          callback();
        });
        return callback.promise;
      };
      LevelUP.prototype.batch = function(arr, options, callback) {
        if (!arguments.length) {
          return new Batch(this);
        }
        if (typeof arr === "function")
          callback = arr;
        else
          callback = getCallback(options, callback);
        callback = catering.fromCallback(callback);
        if (maybeError(this, callback)) {
          return callback.promise;
        }
        options = getOptions(options);
        this.db.batch(arr, options, (err) => {
          if (err) {
            return callback(new WriteError(err));
          }
          this.emit("batch", arr);
          callback();
        });
        return callback.promise;
      };
      LevelUP.prototype.iterator = function(options) {
        return this.db.iterator(options);
      };
      LevelUP.prototype.clear = function(options, callback) {
        callback = getCallback(options, callback);
        options = getOptions(options);
        callback = catering.fromCallback(callback);
        if (maybeError(this, callback)) {
          return callback.promise;
        }
        this.db.clear(options, (err) => {
          if (err) {
            return callback(new WriteError(err));
          }
          this.emit("clear", options);
          callback();
        });
        return callback.promise;
      };
      LevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function(options) {
        options = Object.assign({ keys: true, values: true }, options);
        if (typeof options.limit !== "number") {
          options.limit = -1;
        }
        return new IteratorStream(this.db.iterator(options), options);
      };
      LevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function(options) {
        return this.createReadStream(Object.assign({}, options, { keys: true, values: false }));
      };
      LevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function(options) {
        return this.createReadStream(Object.assign({}, options, { keys: false, values: true }));
      };
      LevelUP.prototype.toString = function() {
        return "LevelUP";
      };
      LevelUP.prototype.type = "levelup";
      LevelUP.prototype._nextTick = nextTick3;
      function maybeError(db, callback) {
        if (!db.isOperational()) {
          nextTick3(callback, new ReadError("Database is not open"));
          return true;
        }
        return false;
      }
      LevelUP.errors = errors;
      module2.exports = LevelUP;
    }
  });

  // node_modules/fergies-inverted-index/src/parseToken.js
  var require_parseToken = __commonJS({
    "node_modules/fergies-inverted-index/src/parseToken.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var charwise = {};
      charwise.LO = null;
      charwise.HI = void 0;
      module2.exports = (token, availableFields) => new Promise((resolve5, reject) => {
        if (Array.isArray(token)) {
          return reject(new Error("token cannot be Array"));
        }
        if (typeof token === "undefined")
          token = {};
        if (typeof token === "string") {
          if (token.indexOf(":") === -1) {
            return resolve5({
              FIELD: availableFields,
              VALUE: {
                GTE: token,
                LTE: token
              }
            });
          }
          const [field, ...value] = token.split(":");
          return resolve5({
            FIELD: [field],
            VALUE: {
              GTE: value.join(":"),
              LTE: value.join(":")
            }
          });
        }
        if (typeof token === "number") {
          token = {
            VALUE: {
              GTE: token,
              LTE: token
            }
          };
        }
        if (token.VALUE === null) {
          token.VALUE = {
            GTE: null,
            LTE: null
          };
        }
        if (typeof token.VALUE === "string" || typeof token.VALUE === "number") {
          token.VALUE = {
            GTE: token.VALUE,
            LTE: token.VALUE
          };
        }
        if (typeof token.VALUE === "undefined" || !Object.keys(token.VALUE).length) {
          token.VALUE = {
            GTE: charwise.LO,
            LTE: charwise.HI
          };
        }
        if (typeof token.VALUE.GTE === "undefined")
          token.VALUE.GTE = charwise.LO;
        if (typeof token.VALUE.LTE === "undefined")
          token.VALUE.LTE = charwise.HI;
        token.VALUE = Object.assign(token.VALUE, {
          GTE: token.VALUE.GTE,
          LTE: token.VALUE.LTE
        });
        if (typeof token.FIELD === "undefined") {
          return resolve5(
            Object.assign(token, {
              FIELD: availableFields
            })
          );
        }
        token.FIELD = [token.FIELD].flat();
        return resolve5(token);
      });
    }
  });

  // node_modules/fergies-inverted-index/src/read.js
  var require_read = __commonJS({
    "node_modules/fergies-inverted-index/src/read.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var tokenParser = require_parseToken();
      var charwise = require_charwise();
      charwise.LO = null;
      charwise.HI = void 0;
      module2.exports = (ops) => {
        const isString2 = (s2) => typeof s2 === "string";
        const parseToken = async (token) => tokenParser(token, await AVAILABLE_FIELDS());
        const queryReplace = (token) => {
          if (typeof token === "undefined")
            return RANGE(void 0);
          if (token.VALUE.GTE === token.VALUE.LTE && ops.queryReplace && ops.queryReplace[token.VALUE.GTE]) {
            return UNION(
              ops.queryReplace[token.VALUE.GTE].map((replacementToken) => ({
                FIELD: token.FIELD,
                VALUE: {
                  GTE: replacementToken,
                  LTE: replacementToken
                }
              }))
            ).then((res) => res.union);
          }
          return token;
        };
        const setCaseSensitivity = (token) => {
          const setCase = (str) => ops.caseSensitive || typeof str !== "string" ? str : str.toLowerCase();
          return {
            FIELD: token.FIELD.map(setCase),
            VALUE: {
              GTE: setCase(token.VALUE.GTE),
              LTE: setCase(token.VALUE.LTE)
            }
          };
        };
        const removeStopwords = (token) => token.VALUE.GTE === token.VALUE.LTE && ops.stopwords.includes(token.VALUE.GTE) ? void 0 : token;
        const GET = async (token, pipeline = (token2) => new Promise((resolve5) => resolve5(token2))) => {
          return new Promise(async (resolve5, reject) => {
            const testForBreak = (token2) => {
              if (typeof token2 === "undefined")
                return resolve5(void 0);
              if (token2 instanceof Promise)
                return resolve5(token2);
            };
            try {
              testForBreak(token);
              token = await parseToken(token);
              token = await setCaseSensitivity(token);
              token = await removeStopwords(token);
              token = await queryReplace(token);
              testForBreak(token);
              token = await pipeline(token);
              testForBreak(token);
            } catch (e2) {
              return reject(e2);
            }
            if (Array.isArray(token))
              return resolve5(token);
            return resolve5(RANGE(token));
          });
        };
        const UNION = async (tokens, pipeline) => Promise.all(tokens.map((token) => GET(token, pipeline))).then((sets) => {
          const setObject = sets.flat(Infinity).reduce((acc, cur) => {
            if (cur)
              acc.set(cur._id, [...acc.get(cur._id) || [], cur._match]);
            return acc;
          }, /* @__PURE__ */ new Map());
          return {
            sumTokensMinusStopwords: sets.filter((s2) => s2).length,
            union: Array.from(setObject.keys()).map((id) => ({
              _id: id,
              _match: setObject.get(id)
            }))
          };
        });
        const INTERSECTION = (tokens, pipeline) => UNION(tokens, pipeline).then(
          (result) => result.union.filter(
            (item) => item._match.length === result.sumTokensMinusStopwords
          )
        );
        const SET_SUBTRACTION = (a2, b2) => Promise.all([isString2(a2) ? GET(a2) : a2, isString2(b2) ? GET(b2) : b2]).then(
          ([a3, b3]) => a3.filter((aItem) => b3.map((bItem) => bItem._id).indexOf(aItem._id) === -1)
        );
        const formatKey = (field, value, lte) => {
          const valueAndScore = [];
          if (value !== void 0 || typeof value === "number") {
            valueAndScore.push(value);
          }
          if (lte)
            valueAndScore.push(charwise.HI);
          return ["IDX", field, valueAndScore];
        };
        const RANGE = (token) => new Promise((resolve5) => {
          if (typeof token === "undefined")
            return resolve5(void 0);
          const rs = /* @__PURE__ */ new Map();
          return Promise.all(
            token.FIELD.map((fieldName) => {
              return new Promise(
                (resolve6) => ops._db.createReadStream({
                  gte: formatKey(fieldName, token.VALUE.GTE),
                  lte: formatKey(fieldName, token.VALUE.LTE, true),
                  limit: token.LIMIT,
                  reverse: token.REVERSE
                }).on("data", (token2) => {
                  return token2.value.forEach((docId) => {
                    return rs.set(docId, [
                      ...rs.get(docId) || [],
                      JSON.stringify({
                        FIELD: token2.key[1],
                        VALUE: token2.key[2][0],
                        SCORE: token2.key[2][1]
                      })
                    ]);
                  });
                }).on("end", resolve6)
              );
            })
          ).then(
            () => resolve5(
              Array.from(rs.keys()).map((id) => {
                return {
                  _id: id,
                  _match: rs.get(id)
                };
              })
            )
          );
        });
        const AVAILABLE_FIELDS = () => new Promise((resolve5) => {
          const fieldNames = [];
          ops._db.createReadStream({
            gte: ["FIELD", charwise.LO],
            lte: ["FIELD", charwise.HI]
          }).on("data", (d2) => fieldNames.push(d2.value)).on("end", () => resolve5(fieldNames));
        });
        const CREATED = () => ops._db.get(["~CREATED"]);
        const LAST_UPDATED = () => ops._db.get(["~LAST_UPDATED"]);
        const EXIST = (...ids) => Promise.all(
          ids.map((id) => ops._db.get([ops.docExistsSpace, id]).catch((e2) => null))
        ).then(
          (result) => result.reduce((acc, cur, i2) => {
            if (cur != null)
              acc.push(ids[i2]);
            return acc;
          }, [])
        );
        const AGGREGATION_FILTER = (aggregation, filterSet) => {
          if (!filterSet || filterSet.length === 0)
            return aggregation;
          filterSet = new Set(filterSet.map((item) => item._id));
          return aggregation.map(
            (bucket) => Object.assign(bucket, {
              _id: [...new Set([...bucket._id].filter((x2) => filterSet.has(x2)))]
            })
          );
        };
        const AGGREGATE = ({ BUCKETS: BUCKETS2, FACETS: FACETS2, QUERY }) => Promise.all([BUCKETS2, FACETS2, QUERY]).then(
          ([bucketsResult = [], facetsResult = [], queryResult = []]) => ({
            BUCKETS: AGGREGATION_FILTER(bucketsResult.flat(), queryResult),
            FACETS: AGGREGATION_FILTER(facetsResult.flat(), queryResult),
            RESULT: queryResult
          })
        );
        const BUCKETS = (...buckets) => Promise.all(buckets.map(BUCKET));
        const BUCKET = async (token) => parseToken(
          token
        ).then(
          (token2) => GET(token2).then(
            (result) => Object.assign(token2, {
              _id: [
                ...result.reduce((acc, cur) => acc.add(cur._id), /* @__PURE__ */ new Set())
              ].sort(),
              VALUE: token2.VALUE
            })
          )
        );
        const OBJECT = (_ids) => Promise.all(
          _ids.map((id) => ops._db.get(["DOC", id._id]).catch((reason) => null))
        ).then(
          (_objects) => _ids.map((_id, i2) => {
            _id._object = _objects[i2];
            return _id;
          })
        );
        const getRange = (rangeOps) => new Promise((resolve5, reject) => {
          const keys = [];
          ops._db.createReadStream(rangeOps).on("data", (data) => {
            keys.push(data);
          }).on("end", () => resolve5(keys));
        });
        const MAX = (fieldName) => BOUNDING_VALUE(fieldName, true);
        const BOUNDING_VALUE = (token, reverse) => parseToken(token).then(
          (token2) => RANGE(
            Object.assign(token2, {
              LIMIT: 1,
              REVERSE: reverse
            })
          )
        ).then(
          (max) => max.length ? JSON.parse(max.pop()._match.pop()).VALUE : null
        );
        const DISTINCT = (...tokens) => Promise.all(
          tokens.length ? tokens.map(DIST) : [DIST({})]
        ).then(
          (dist) => [
            ...dist.flat().reduce((acc, cur) => acc.add(JSON.stringify(cur)), /* @__PURE__ */ new Set())
          ].map(JSON.parse)
        );
        const DIST = (token) => parseToken(token).then(
          (token2) => Promise.all(
            token2.FIELD.map((field) => {
              let lte = token2.VALUE.LTE;
              if (typeof token2.VALUE.LTE !== "undefined" && typeof token2.VALUE.LTE !== "number") {
                lte = lte + "\uFFEE";
              }
              let gte = token2.VALUE.GTE;
              if (token2.VALUE.GTE && typeof token2.VALUE.GTE !== "number") {
                gte = gte + " ";
              }
              return getRange({
                gte: formatKey(field, gte),
                lte: formatKey(field, lte, true),
                keys: true,
                values: false
              }).then(
                (items) => items.map((item) => ({
                  FIELD: item[1],
                  VALUE: item[2][0]
                }))
              );
            })
          )
        ).then((result) => result.flat());
        const FACETS = (...tokens) => Promise.all(
          tokens.length ? tokens.map(FACET) : [FACET({})]
        ).then(
          (facets) => [
            ...facets.flat().reduce((acc, cur) => acc.add(JSON.stringify(cur)), /* @__PURE__ */ new Set())
          ].map(JSON.parse)
        );
        const FACET = (token) => parseToken(token).then(
          (token2) => Promise.all(
            token2.FIELD.map(
              (field) => getRange({
                gte: formatKey(field, token2.VALUE.GTE),
                lte: formatKey(field, token2.VALUE.LTE, true)
              }).then(
                (items) => items.map((item) => ({
                  FIELD: item.key[1],
                  VALUE: item.key[2][0],
                  _id: item.value
                }))
              )
            )
          )
        ).then((result) => result.flat());
        const collator = new Intl.Collator("en", {
          numeric: true,
          sensitivity: "base"
        });
        const SORT = (results) => new Promise(
          (resolve5) => resolve5(results.sort((a2, b2) => collator.compare(a2._id, b2._id)))
        );
        return {
          AGGREGATE,
          AGGREGATION_FILTER,
          BUCKET,
          BUCKETS,
          CREATED,
          DISTINCT,
          EXIST,
          EXPORT: getRange,
          FACETS,
          FIELDS: AVAILABLE_FIELDS,
          GET,
          INTERSECTION,
          LAST_UPDATED,
          MAX,
          MIN: BOUNDING_VALUE,
          OBJECT,
          SET_SUBTRACTION,
          SORT,
          UNION,
          parseToken
        };
      };
    }
  });

  // node_modules/traverse/index.js
  var require_traverse = __commonJS({
    "node_modules/traverse/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      function toS(obj) {
        return Object.prototype.toString.call(obj);
      }
      function isDate2(obj) {
        return toS(obj) === "[object Date]";
      }
      function isRegExp2(obj) {
        return toS(obj) === "[object RegExp]";
      }
      function isError2(obj) {
        return toS(obj) === "[object Error]";
      }
      function isBoolean2(obj) {
        return toS(obj) === "[object Boolean]";
      }
      function isNumber2(obj) {
        return toS(obj) === "[object Number]";
      }
      function isString2(obj) {
        return toS(obj) === "[object String]";
      }
      var isArray3 = Array.isArray || function isArray4(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
      function forEach(xs, fn) {
        if (xs.forEach) {
          return xs.forEach(fn);
        }
        for (var i2 = 0; i2 < xs.length; i2++) {
          fn(xs[i2], i2, xs);
        }
        return void 0;
      }
      var objectKeys = Object.keys || function keys(obj) {
        var res = [];
        for (var key in obj) {
          res.push(key);
        }
        return res;
      };
      var hasOwnProperty2 = Object.prototype.hasOwnProperty || function(obj, key) {
        return key in obj;
      };
      function copy2(src7) {
        if (typeof src7 === "object" && src7 !== null) {
          var dst;
          if (isArray3(src7)) {
            dst = [];
          } else if (isDate2(src7)) {
            dst = new Date(src7.getTime ? src7.getTime() : src7);
          } else if (isRegExp2(src7)) {
            dst = new RegExp(src7);
          } else if (isError2(src7)) {
            dst = { message: src7.message };
          } else if (isBoolean2(src7) || isNumber2(src7) || isString2(src7)) {
            dst = Object(src7);
          } else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src7));
          } else if (src7.constructor === Object) {
            dst = {};
          } else {
            var proto = src7.constructor && src7.constructor.prototype || src7.__proto__ || {};
            var T2 = function T3() {
            };
            T2.prototype = proto;
            dst = new T2();
          }
          forEach(objectKeys(src7), function(key) {
            dst[key] = src7[key];
          });
          return dst;
        }
        return src7;
      }
      function walk(root, cb, immutable) {
        var path = [];
        var parents = [];
        var alive = true;
        return function walker(node_) {
          var node = immutable ? copy2(node_) : node_;
          var modifiers = {};
          var keepGoing = true;
          var state = {
            node,
            node_,
            path: [].concat(path),
            parent: parents[parents.length - 1],
            parents,
            key: path[path.length - 1],
            isRoot: path.length === 0,
            level: path.length,
            circular: null,
            update: function(x2, stopHere) {
              if (!state.isRoot) {
                state.parent.node[state.key] = x2;
              }
              state.node = x2;
              if (stopHere) {
                keepGoing = false;
              }
            },
            delete: function(stopHere) {
              delete state.parent.node[state.key];
              if (stopHere) {
                keepGoing = false;
              }
            },
            remove: function(stopHere) {
              if (isArray3(state.parent.node)) {
                state.parent.node.splice(state.key, 1);
              } else {
                delete state.parent.node[state.key];
              }
              if (stopHere) {
                keepGoing = false;
              }
            },
            keys: null,
            before: function(f2) {
              modifiers.before = f2;
            },
            after: function(f2) {
              modifiers.after = f2;
            },
            pre: function(f2) {
              modifiers.pre = f2;
            },
            post: function(f2) {
              modifiers.post = f2;
            },
            stop: function() {
              alive = false;
            },
            block: function() {
              keepGoing = false;
            }
          };
          if (!alive) {
            return state;
          }
          function updateState() {
            if (typeof state.node === "object" && state.node !== null) {
              if (!state.keys || state.node_ !== state.node) {
                state.keys = objectKeys(state.node);
              }
              state.isLeaf = state.keys.length === 0;
              for (var i2 = 0; i2 < parents.length; i2++) {
                if (parents[i2].node_ === node_) {
                  state.circular = parents[i2];
                  break;
                }
              }
            } else {
              state.isLeaf = true;
              state.keys = null;
            }
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
          }
          updateState();
          var ret = cb.call(state, state.node);
          if (ret !== void 0 && state.update) {
            state.update(ret);
          }
          if (modifiers.before) {
            modifiers.before.call(state, state.node);
          }
          if (!keepGoing) {
            return state;
          }
          if (typeof state.node === "object" && state.node !== null && !state.circular) {
            parents.push(state);
            updateState();
            forEach(state.keys, function(key, i2) {
              path.push(key);
              if (modifiers.pre) {
                modifiers.pre.call(state, state.node[key], key);
              }
              var child = walker(state.node[key]);
              if (immutable && hasOwnProperty2.call(state.node, key)) {
                state.node[key] = child.node;
              }
              child.isLast = i2 === state.keys.length - 1;
              child.isFirst = i2 === 0;
              if (modifiers.post) {
                modifiers.post.call(state, child);
              }
              path.pop();
            });
            parents.pop();
          }
          if (modifiers.after) {
            modifiers.after.call(state, state.node);
          }
          return state;
        }(root).node;
      }
      function Traverse(obj) {
        this.value = obj;
      }
      Traverse.prototype.get = function(ps) {
        var node = this.value;
        for (var i2 = 0; i2 < ps.length; i2++) {
          var key = ps[i2];
          if (!node || !hasOwnProperty2.call(node, key)) {
            return void 0;
          }
          node = node[key];
        }
        return node;
      };
      Traverse.prototype.has = function(ps) {
        var node = this.value;
        for (var i2 = 0; i2 < ps.length; i2++) {
          var key = ps[i2];
          if (!node || !hasOwnProperty2.call(node, key)) {
            return false;
          }
          node = node[key];
        }
        return true;
      };
      Traverse.prototype.set = function(ps, value) {
        var node = this.value;
        for (var i2 = 0; i2 < ps.length - 1; i2++) {
          var key = ps[i2];
          if (!hasOwnProperty2.call(node, key)) {
            node[key] = {};
          }
          node = node[key];
        }
        node[ps[i2]] = value;
        return value;
      };
      Traverse.prototype.map = function(cb) {
        return walk(this.value, cb, true);
      };
      Traverse.prototype.forEach = function(cb) {
        this.value = walk(this.value, cb, false);
        return this.value;
      };
      Traverse.prototype.reduce = function(cb, init2) {
        var skip = arguments.length === 1;
        var acc = skip ? this.value : init2;
        this.forEach(function(x2) {
          if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x2);
          }
        });
        return acc;
      };
      Traverse.prototype.paths = function() {
        var acc = [];
        this.forEach(function() {
          acc.push(this.path);
        });
        return acc;
      };
      Traverse.prototype.nodes = function() {
        var acc = [];
        this.forEach(function() {
          acc.push(this.node);
        });
        return acc;
      };
      Traverse.prototype.clone = function() {
        var parents = [];
        var nodes = [];
        return function clone(src7) {
          for (var i2 = 0; i2 < parents.length; i2++) {
            if (parents[i2] === src7) {
              return nodes[i2];
            }
          }
          if (typeof src7 === "object" && src7 !== null) {
            var dst = copy2(src7);
            parents.push(src7);
            nodes.push(dst);
            forEach(objectKeys(src7), function(key) {
              dst[key] = clone(src7[key]);
            });
            parents.pop();
            nodes.pop();
            return dst;
          }
          return src7;
        }(this.value);
      };
      function traverse(obj) {
        return new Traverse(obj);
      }
      forEach(objectKeys(Traverse.prototype), function(key) {
        traverse[key] = function(obj) {
          var args = [].slice.call(arguments, 1);
          var t2 = new Traverse(obj);
          return t2[key].apply(t2, args);
        };
      });
      module2.exports = traverse;
    }
  });

  // node_modules/fergies-inverted-index/src/write.js
  var require_write = __commonJS({
    "node_modules/fergies-inverted-index/src/write.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var trav = require_traverse();
      var reader = require_read();
      module2.exports = (ops) => {
        let incrementalId = 0;
        const invertDoc = (obj, putOptions) => {
          if (obj._object == null) {
            return {
              _id: obj._id,
              keys: []
            };
          }
          const keys = [];
          trav(obj._object).forEach(function(node) {
            let searchable = true;
            const fieldName = this.path.filter((item) => !Number.isInteger(+item)).join(".");
            if (fieldName === "_id")
              searchable = false;
            if (putOptions.doNotIndexField.filter((item) => fieldName.startsWith(item)).length) {
              searchable = false;
            }
            if (this.isLeaf && ops.stopwords.includes((this.node + "").split("#")[0])) {
              searchable = false;
            }
            if (searchable && this.isLeaf) {
              let key;
              try {
                const parsedJSON = JSON.parse(this.node);
                if (!Array.isArray(parsedJSON))
                  throw new Error();
                key = JSON.stringify([fieldName, parsedJSON]);
              } catch (e2) {
                key = JSON.stringify([fieldName, [this.node]]);
              }
              keys.push(ops.caseSensitive ? key : key.toLowerCase());
            }
          });
          return {
            _id: obj._id,
            keys
          };
        };
        const createMergedReverseIndex = (index, _db3, mode) => {
          const gracefullGet = (key) => new Promise(
            (resolve5, reject) => _db3.get(key).then(resolve5).catch((e2) => resolve5([]))
          );
          const indexKeys = Object.keys(index);
          return Promise.all(
            indexKeys.map((k2) => ["IDX", ...JSON.parse(k2)]).map(gracefullGet)
          ).then(
            (currentValues) => currentValues.map((cur, i2) => {
              const curSet = new Set(cur);
              const deltaSet = new Set(index[indexKeys[i2]]);
              if (mode === "put") {
                return {
                  key: ["IDX", ...JSON.parse(indexKeys[i2])],
                  type: mode,
                  value: [.../* @__PURE__ */ new Set([...curSet, ...deltaSet])].sort()
                };
              } else if (mode === "del") {
                const newSet = [...new Set([...curSet].filter((x2) => !deltaSet.has(x2)))];
                return {
                  key: ["IDX", ...JSON.parse(indexKeys[i2])],
                  type: newSet.length === 0 ? "del" : "put",
                  value: newSet
                };
              }
              return cur;
            })
          );
        };
        const objectIndex = (docs, mode) => docs.map((doc) => ({
          key: ["DOC", doc._id],
          type: mode,
          value: doc._object
        }));
        const reverseIndex = (acc, cur) => {
          cur.keys.forEach((key) => {
            acc[key] = acc[key] || [];
            acc[key].push(cur._id);
          });
          return acc;
        };
        const createDeltaReverseIndex = (docs, putOptions) => docs.map((doc) => invertDoc(doc, putOptions)).reduce(reverseIndex, {});
        const sanitizeID = (id) => {
          if (id === void 0)
            return ++incrementalId;
          if (typeof id === "string")
            return id;
          if (typeof id === "number")
            return id;
        };
        const availableFields = (reverseIndex2) => [...new Set(reverseIndex2.map((item) => item.key[1].split(":")[0]))].map(
          (f2) => ({
            type: "put",
            key: ["FIELD", f2],
            value: f2
          })
        );
        const writer = (docs, _db3, mode, MODE, putOptions) => new Promise((resolve5) => {
          docs = docs.map((doc) => {
            doc._id = sanitizeID(doc._id);
            if (doc._object) {
              doc._object._id = doc._id;
            }
            return doc;
          });
          putOptions = Object.assign(ops, putOptions);
          reader(ops).EXIST(...docs.map((d2) => d2._id)).then(
            (existingDocs) => createMergedReverseIndex(
              createDeltaReverseIndex(docs, putOptions),
              _db3,
              mode
            ).then(
              (mergedReverseIndex) => _db3.batch(
                mergedReverseIndex.concat(putOptions.storeVectors ? objectIndex(docs, mode) : []).concat(availableFields(mergedReverseIndex)),
                (e2) => resolve5(
                  docs.map((doc) => {
                    let status;
                    if (mode === "put") {
                      if (existingDocs.includes(doc._id)) {
                        status = "UPDATED";
                      } else {
                        status = "CREATED";
                      }
                    } else if (mode === "del") {
                      if (doc._object === null) {
                        status = "FAILED";
                      } else {
                        status = "DELETED";
                      }
                    }
                    return {
                      _id: doc._id,
                      operation: MODE,
                      status
                    };
                  })
                )
              )
            )
          );
        });
        const DELETE = (_ids) => reader(ops).OBJECT(_ids.map((_id) => ({ _id }))).then((docs) => writer(docs, ops._db, "del", "DELETE", {})).then(TIMESTAMP_LAST_UPDATED);
        const IMPORT = (index) => ops._db.clear().then(
          () => ops._db.batch(index.map((entry) => Object.assign(entry, { type: "put" })))
        );
        const PUT = (docs, putOptions = {}) => writer(
          docs.map((doc) => ({
            _id: doc._id,
            _object: doc
          })),
          ops._db,
          "put",
          "PUT",
          putOptions
        ).then(TIMESTAMP_LAST_UPDATED);
        const TIMESTAMP_LAST_UPDATED = (passThrough) => ops._db.put(["~LAST_UPDATED"], Date.now()).then(() => passThrough);
        const TIMESTAMP_CREATED = () => ops._db.get(["~CREATED"]).then().catch(
          (e2) => ops._db.put(["~CREATED"], Date.now()).then(TIMESTAMP_LAST_UPDATED)
        );
        return {
          DELETE,
          IMPORT,
          PUT,
          TIMESTAMP_CREATED,
          TIMESTAMP_LAST_UPDATED
        };
      };
    }
  });

  // node_modules/fergies-inverted-index/src/main.js
  var require_main = __commonJS({
    "node_modules/fergies-inverted-index/src/main.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var charwise = require_charwise();
      var encode21 = require_encoding_down();
      var levelup = require_levelup();
      var read8 = require_read();
      var write3 = require_write();
      var flattenMatchArrayInResults = (results) => typeof results === "undefined" ? void 0 : results.map((result) => {
        result._match = result._match.flat(Infinity).map((m2) => typeof m2 === "string" ? JSON.parse(m2) : m2).sort((a2, b2) => {
          if (a2.FIELD < b2.FIELD)
            return -1;
          if (a2.FIELD > b2.FIELD)
            return 1;
          if (a2.VALUE < b2.VALUE)
            return -1;
          if (a2.VALUE > b2.VALUE)
            return 1;
          if (a2.SCORE < b2.SCORE)
            return -1;
          if (a2.SCORE > b2.SCORE)
            return 1;
          return 0;
        });
        return result;
      });
      var initStore = (ops = {}) => new Promise((resolve5, reject) => {
        ops = Object.assign(
          {
            name: "fii",
            tokenAppend: "",
            caseSensitive: true,
            stopwords: [],
            doNotIndexField: [],
            storeVectors: true,
            docExistsSpace: "DOC"
          },
          ops
        );
        return levelup(
          encode21(ops.db(ops.name), {
            keyEncoding: charwise,
            valueEncoding: "json"
          }),
          (err, db) => err ? reject(err) : resolve5(Object.assign(ops, { _db: db }))
        );
      });
      var makeAFii = (ops) => {
        const r2 = read8(ops);
        const w2 = write3(ops);
        return w2.TIMESTAMP_CREATED().then(() => ({
          AGGREGATION_FILTER: r2.AGGREGATION_FILTER,
          AND: (tokens, pipeline) => r2.INTERSECTION(tokens, pipeline).then(flattenMatchArrayInResults),
          BUCKET: r2.BUCKET,
          BUCKETS: r2.BUCKETS,
          CREATED: r2.CREATED,
          DELETE: w2.DELETE,
          DISTINCT: r2.DISTINCT,
          EXIST: r2.EXIST,
          EXPORT: r2.EXPORT,
          FACETS: r2.FACETS,
          FIELDS: r2.FIELDS,
          GET: (tokens, pipeline) => r2.GET(tokens, pipeline).then(flattenMatchArrayInResults),
          IMPORT: w2.IMPORT,
          LAST_UPDATED: r2.LAST_UPDATED,
          MAX: r2.MAX,
          MIN: r2.MIN,
          NOT: (...keys) => r2.SET_SUBTRACTION(...keys).then(flattenMatchArrayInResults),
          OBJECT: r2.OBJECT,
          OR: (tokens, pipeline) => r2.UNION(tokens, pipeline).then((result) => result.union).then(flattenMatchArrayInResults),
          PUT: w2.PUT,
          SORT: r2.SORT,
          STORE: ops._db,
          TIMESTAMP_LAST_UPDATED: w2.TIMESTAMP_LAST_UPDATED,
          parseToken: r2.parseToken
        }));
      };
      module2.exports = (ops) => initStore(ops).then(makeAFii);
    }
  });

  // node_modules/ltgt/index.js
  var require_ltgt = __commonJS({
    "node_modules/ltgt/index.js"(exports2) {
      init_virtual_process_polyfill();
      exports2.compare = function(a2, b2) {
        if (Buffer.isBuffer(a2)) {
          var l2 = Math.min(a2.length, b2.length);
          for (var i2 = 0; i2 < l2; i2++) {
            var cmp = a2[i2] - b2[i2];
            if (cmp)
              return cmp;
          }
          return a2.length - b2.length;
        }
        return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
      };
      function isDef(val) {
        return val !== void 0 && val !== "";
      }
      function has(range, name6) {
        return Object.hasOwnProperty.call(range, name6);
      }
      function hasKey(range, name6) {
        return Object.hasOwnProperty.call(range, name6) && name6;
      }
      var lowerBoundKey = exports2.lowerBoundKey = function(range) {
        return hasKey(range, "gt") || hasKey(range, "gte") || hasKey(range, "min") || (range.reverse ? hasKey(range, "end") : hasKey(range, "start")) || void 0;
      };
      var lowerBound2 = exports2.lowerBound = function(range, def) {
        var k2 = lowerBoundKey(range);
        return k2 ? range[k2] : def;
      };
      var lowerBoundInclusive = exports2.lowerBoundInclusive = function(range) {
        return has(range, "gt") ? false : true;
      };
      var upperBoundInclusive = exports2.upperBoundInclusive = function(range) {
        return has(range, "lt") ? false : true;
      };
      var lowerBoundExclusive = exports2.lowerBoundExclusive = function(range) {
        return !lowerBoundInclusive(range);
      };
      var upperBoundExclusive = exports2.upperBoundExclusive = function(range) {
        return !upperBoundInclusive(range);
      };
      var upperBoundKey = exports2.upperBoundKey = function(range) {
        return hasKey(range, "lt") || hasKey(range, "lte") || hasKey(range, "max") || (range.reverse ? hasKey(range, "start") : hasKey(range, "end")) || void 0;
      };
      var upperBound = exports2.upperBound = function(range, def) {
        var k2 = upperBoundKey(range);
        return k2 ? range[k2] : def;
      };
      exports2.start = function(range, def) {
        return range.reverse ? upperBound(range, def) : lowerBound2(range, def);
      };
      exports2.end = function(range, def) {
        return range.reverse ? lowerBound2(range, def) : upperBound(range, def);
      };
      exports2.startInclusive = function(range) {
        return range.reverse ? upperBoundInclusive(range) : lowerBoundInclusive(range);
      };
      exports2.endInclusive = function(range) {
        return range.reverse ? lowerBoundInclusive(range) : upperBoundInclusive(range);
      };
      function id(e2) {
        return e2;
      }
      exports2.toLtgt = function(range, _range, map, lower, upper) {
        _range = _range || {};
        map = map || id;
        var defaults = arguments.length > 3;
        var lb = exports2.lowerBoundKey(range);
        var ub = exports2.upperBoundKey(range);
        if (lb) {
          if (lb === "gt")
            _range.gt = map(range.gt, false);
          else
            _range.gte = map(range[lb], false);
        } else if (defaults)
          _range.gte = map(lower, false);
        if (ub) {
          if (ub === "lt")
            _range.lt = map(range.lt, true);
          else
            _range.lte = map(range[ub], true);
        } else if (defaults)
          _range.lte = map(upper, true);
        if (range.reverse != null)
          _range.reverse = !!range.reverse;
        if (has(_range, "max"))
          delete _range.max;
        if (has(_range, "min"))
          delete _range.min;
        if (has(_range, "start"))
          delete _range.start;
        if (has(_range, "end"))
          delete _range.end;
        return _range;
      };
      exports2.contains = function(range, key, compare4) {
        compare4 = compare4 || exports2.compare;
        var lb = lowerBound2(range);
        if (isDef(lb)) {
          var cmp = compare4(key, lb);
          if (cmp < 0 || cmp === 0 && lowerBoundExclusive(range))
            return false;
        }
        var ub = upperBound(range);
        if (isDef(ub)) {
          var cmp = compare4(key, ub);
          if (cmp > 0 || cmp === 0 && upperBoundExclusive(range))
            return false;
        }
        return true;
      };
      exports2.filter = function(range, compare4) {
        return function(key) {
          return exports2.contains(range, key, compare4);
        };
      };
    }
  });

  // node_modules/level-js/util/key-range.js
  var require_key_range2 = __commonJS({
    "node_modules/level-js/util/key-range.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var ltgt = require_ltgt();
      var NONE = Symbol("none");
      module2.exports = function createKeyRange(options) {
        const lower = ltgt.lowerBound(options, NONE);
        const upper = ltgt.upperBound(options, NONE);
        const lowerOpen = ltgt.lowerBoundExclusive(options, NONE);
        const upperOpen = ltgt.upperBoundExclusive(options, NONE);
        if (lower !== NONE && upper !== NONE) {
          return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);
        } else if (lower !== NONE) {
          return IDBKeyRange.lowerBound(lower, lowerOpen);
        } else if (upper !== NONE) {
          return IDBKeyRange.upperBound(upper, upperOpen);
        } else {
          return null;
        }
      };
    }
  });

  // node_modules/level-js/util/deserialize.js
  var require_deserialize2 = __commonJS({
    "node_modules/level-js/util/deserialize.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var Buffer3 = require_buffer().Buffer;
      var ta2str = function() {
        if (globalThis.TextDecoder) {
          const decoder = new TextDecoder("utf-8");
          return decoder.decode.bind(decoder);
        } else {
          return function ta2str2(ta) {
            return ta2buf(ta).toString();
          };
        }
      }();
      var ab2str = function() {
        if (globalThis.TextDecoder) {
          const decoder = new TextDecoder("utf-8");
          return decoder.decode.bind(decoder);
        } else {
          return function ab2str2(ab) {
            return Buffer3.from(ab).toString();
          };
        }
      }();
      function ta2buf(ta) {
        const buf2 = Buffer3.from(ta.buffer);
        if (ta.byteLength === ta.buffer.byteLength) {
          return buf2;
        } else {
          return buf2.slice(ta.byteOffset, ta.byteOffset + ta.byteLength);
        }
      }
      module2.exports = function(data, asBuffer) {
        if (data instanceof Uint8Array) {
          return asBuffer ? ta2buf(data) : ta2str(data);
        } else if (data instanceof ArrayBuffer) {
          return asBuffer ? Buffer3.from(data) : ab2str(data);
        } else {
          return asBuffer ? Buffer3.from(String(data)) : String(data);
        }
      };
    }
  });

  // node_modules/level-js/iterator.js
  var require_iterator2 = __commonJS({
    "node_modules/level-js/iterator.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var inherits2 = require_inherits_browser();
      var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
      var createKeyRange = require_key_range2();
      var deserialize = require_deserialize2();
      var noop3 = function() {
      };
      module2.exports = Iterator;
      function Iterator(db, location, options) {
        AbstractIterator.call(this, db);
        this._limit = options.limit;
        this._count = 0;
        this._callback = null;
        this._cache = [];
        this._completed = false;
        this._aborted = false;
        this._error = null;
        this._transaction = null;
        this._keys = options.keys;
        this._values = options.values;
        this._keyAsBuffer = options.keyAsBuffer;
        this._valueAsBuffer = options.valueAsBuffer;
        if (this._limit === 0) {
          this._completed = true;
          return;
        }
        let keyRange;
        try {
          keyRange = createKeyRange(options);
        } catch (e2) {
          this._completed = true;
          return;
        }
        this.createIterator(location, keyRange, options.reverse);
      }
      inherits2(Iterator, AbstractIterator);
      Iterator.prototype.createIterator = function(location, keyRange, reverse) {
        const transaction = this.db.db.transaction([location], "readonly");
        const store = transaction.objectStore(location);
        const req = store.openCursor(keyRange, reverse ? "prev" : "next");
        req.onsuccess = (ev) => {
          const cursor = ev.target.result;
          if (cursor)
            this.onItem(cursor);
        };
        this._transaction = transaction;
        transaction.onabort = () => {
          this.onAbort(this._transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = () => {
          this.onComplete();
        };
      };
      Iterator.prototype.onItem = function(cursor) {
        this._cache.push(cursor.key, cursor.value);
        if (this._limit <= 0 || ++this._count < this._limit) {
          cursor.continue();
        }
        this.maybeNext();
      };
      Iterator.prototype.onAbort = function(err) {
        this._aborted = true;
        this._error = err;
        this.maybeNext();
      };
      Iterator.prototype.onComplete = function() {
        this._completed = true;
        this.maybeNext();
      };
      Iterator.prototype.maybeNext = function() {
        if (this._callback) {
          this._next(this._callback);
          this._callback = null;
        }
      };
      Iterator.prototype._next = function(callback) {
        if (this._aborted) {
          const err = this._error;
          this._error = null;
          this._nextTick(callback, err);
        } else if (this._cache.length > 0) {
          let key = this._cache.shift();
          let value = this._cache.shift();
          if (this._keys && key !== void 0) {
            key = this._deserializeKey(key, this._keyAsBuffer);
          } else {
            key = void 0;
          }
          if (this._values && value !== void 0) {
            value = this._deserializeValue(value, this._valueAsBuffer);
          } else {
            value = void 0;
          }
          this._nextTick(callback, null, key, value);
        } else if (this._completed) {
          this._nextTick(callback);
        } else {
          this._callback = callback;
        }
      };
      Iterator.prototype._deserializeKey = deserialize;
      Iterator.prototype._deserializeValue = deserialize;
      Iterator.prototype._end = function(callback) {
        if (this._aborted || this._completed) {
          return this._nextTick(callback, this._error);
        }
        this.onItem = noop3;
        this.onAbort = callback;
        this.onComplete = callback;
      };
    }
  });

  // node_modules/level-js/util/serialize.js
  var require_serialize = __commonJS({
    "node_modules/level-js/util/serialize.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var Buffer3 = require_buffer().Buffer;
      var str2bin = function() {
        if (globalThis.TextEncoder) {
          const encoder = new TextEncoder("utf-8");
          return encoder.encode.bind(encoder);
        } else {
          return Buffer3.from;
        }
      }();
      module2.exports = function(data, asBuffer) {
        if (asBuffer) {
          return Buffer3.isBuffer(data) ? data : str2bin(String(data));
        } else {
          return String(data);
        }
      };
    }
  });

  // node_modules/level-js/util/support.js
  var require_support = __commonJS({
    "node_modules/level-js/util/support.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var Buffer3 = require_buffer().Buffer;
      exports2.test = function(key) {
        return function test(impl) {
          try {
            impl.cmp(key, 0);
            return true;
          } catch (err) {
            return false;
          }
        };
      };
      exports2.bufferKeys = exports2.test(Buffer3.alloc(0));
    }
  });

  // node_modules/level-js/util/clear.js
  var require_clear2 = __commonJS({
    "node_modules/level-js/util/clear.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = function clear(db, location, keyRange, options, callback) {
        if (options.limit === 0)
          return db._nextTick(callback);
        const transaction = db.db.transaction([location], "readwrite");
        const store = transaction.objectStore(location);
        let count = 0;
        transaction.oncomplete = function() {
          callback();
        };
        transaction.onabort = function() {
          callback(transaction.error || new Error("aborted by user"));
        };
        const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
        const direction = options.reverse ? "prev" : "next";
        store[method](keyRange, direction).onsuccess = function(ev) {
          const cursor = ev.target.result;
          if (cursor) {
            store.delete(cursor.key).onsuccess = function() {
              if (options.limit <= 0 || ++count < options.limit) {
                cursor.continue();
              }
            };
          }
        };
      };
    }
  });

  // node_modules/level-js/index.js
  var require_level_js = __commonJS({
    "node_modules/level-js/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = Level3;
      var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
      var inherits2 = require_inherits_browser();
      var parallel = require_run_parallel_limit();
      var Iterator = require_iterator2();
      var serialize = require_serialize();
      var deserialize = require_deserialize2();
      var support = require_support();
      var clear = require_clear2();
      var createKeyRange = require_key_range2();
      var DEFAULT_PREFIX = "level-js-";
      function Level3(location, opts) {
        if (!(this instanceof Level3))
          return new Level3(location, opts);
        AbstractLevelDOWN.call(this, {
          bufferKeys: support.bufferKeys(indexedDB),
          snapshots: true,
          permanence: true,
          clear: true,
          getMany: true
        });
        opts = opts || {};
        if (typeof location !== "string") {
          throw new Error("constructor requires a location string argument");
        }
        this.location = location;
        this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix;
        this.version = parseInt(opts.version || 1, 10);
      }
      inherits2(Level3, AbstractLevelDOWN);
      Level3.prototype.type = "level-js";
      Level3.prototype._open = function(options, callback) {
        const req = indexedDB.open(this.prefix + this.location, this.version);
        req.onerror = function() {
          callback(req.error || new Error("unknown error"));
        };
        req.onsuccess = () => {
          this.db = req.result;
          callback();
        };
        req.onupgradeneeded = (ev) => {
          const db = ev.target.result;
          if (!db.objectStoreNames.contains(this.location)) {
            db.createObjectStore(this.location);
          }
        };
      };
      Level3.prototype.store = function(mode) {
        const transaction = this.db.transaction([this.location], mode);
        return transaction.objectStore(this.location);
      };
      Level3.prototype.await = function(request, callback) {
        const transaction = request.transaction;
        transaction.onabort = function() {
          callback(transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback(null, request.result);
        };
      };
      Level3.prototype._get = function(key, options, callback) {
        const store = this.store("readonly");
        let req;
        try {
          req = store.get(key);
        } catch (err) {
          return this._nextTick(callback, err);
        }
        this.await(req, function(err, value) {
          if (err)
            return callback(err);
          if (value === void 0) {
            return callback(new Error("NotFound"));
          }
          callback(null, deserialize(value, options.asBuffer));
        });
      };
      Level3.prototype._getMany = function(keys, options, callback) {
        const asBuffer = options.asBuffer;
        const store = this.store("readonly");
        const tasks = keys.map((key) => (next) => {
          let request;
          try {
            request = store.get(key);
          } catch (err) {
            return next(err);
          }
          request.onsuccess = () => {
            const value = request.result;
            next(null, value === void 0 ? value : deserialize(value, asBuffer));
          };
          request.onerror = (ev) => {
            ev.stopPropagation();
            next(request.error);
          };
        });
        parallel(tasks, 16, callback);
      };
      Level3.prototype._del = function(key, options, callback) {
        const store = this.store("readwrite");
        let req;
        try {
          req = store.delete(key);
        } catch (err) {
          return this._nextTick(callback, err);
        }
        this.await(req, callback);
      };
      Level3.prototype._put = function(key, value, options, callback) {
        const store = this.store("readwrite");
        let req;
        try {
          req = store.put(value, key);
        } catch (err) {
          return this._nextTick(callback, err);
        }
        this.await(req, callback);
      };
      Level3.prototype._serializeKey = function(key) {
        return serialize(key, this.supports.bufferKeys);
      };
      Level3.prototype._serializeValue = function(value) {
        return serialize(value, true);
      };
      Level3.prototype._iterator = function(options) {
        return new Iterator(this, this.location, options);
      };
      Level3.prototype._batch = function(operations, options, callback) {
        if (operations.length === 0)
          return this._nextTick(callback);
        const store = this.store("readwrite");
        const transaction = store.transaction;
        let index = 0;
        let error;
        transaction.onabort = function() {
          callback(error || transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback();
        };
        function loop() {
          const op = operations[index++];
          const key = op.key;
          let req;
          try {
            req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
          } catch (err) {
            error = err;
            transaction.abort();
            return;
          }
          if (index < operations.length) {
            req.onsuccess = loop;
          }
        }
        loop();
      };
      Level3.prototype._clear = function(options, callback) {
        let keyRange;
        let req;
        try {
          keyRange = createKeyRange(options);
        } catch (e2) {
          return this._nextTick(callback);
        }
        if (options.limit >= 0) {
          return clear(this, this.location, keyRange, options, callback);
        }
        try {
          const store = this.store("readwrite");
          req = keyRange ? store.delete(keyRange) : store.clear();
        } catch (err) {
          return this._nextTick(callback, err);
        }
        this.await(req, callback);
      };
      Level3.prototype._close = function(callback) {
        this.db.close();
        this._nextTick(callback);
      };
      Level3.prototype.upgrade = function(callback) {
        if (this.status !== "open") {
          return this._nextTick(callback, new Error("cannot upgrade() before open()"));
        }
        const it2 = this.iterator();
        const batchOptions = {};
        const self2 = this;
        it2._deserializeKey = it2._deserializeValue = identity4;
        next();
        function next(err) {
          if (err)
            return finish(err);
          it2.next(each);
        }
        function each(err, key, value) {
          if (err || key === void 0) {
            return finish(err);
          }
          const newKey = self2._serializeKey(deserialize(key, true));
          const newValue = self2._serializeValue(deserialize(value, true));
          self2._batch([
            { type: "del", key },
            { type: "put", key: newKey, value: newValue }
          ], batchOptions, next);
        }
        function finish(err) {
          it2.end(function(err2) {
            callback(err || err2);
          });
        }
        function identity4(data) {
          return data;
        }
      };
      Level3.destroy = function(location, prefix, callback) {
        if (typeof prefix === "function") {
          callback = prefix;
          prefix = DEFAULT_PREFIX;
        }
        const request = indexedDB.deleteDatabase(prefix + location);
        request.onsuccess = function() {
          callback();
        };
        request.onerror = function(err) {
          callback(err);
        };
      };
    }
  });

  // node_modules/fergies-inverted-index/src/browser.js
  var require_browser3 = __commonJS({
    "node_modules/fergies-inverted-index/src/browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var fii = require_main();
      var leveldown = require_level_js();
      module2.exports = (ops) => fii(
        Object.assign(
          {
            db: leveldown
          },
          ops
        )
      );
    }
  });

  // node_modules/term-vector/index.js
  var require_term_vector = __commonJS({
    "node_modules/term-vector/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = function(tokens, ops) {
        ops = Object.assign({}, {
          ngramLengths: [1]
        }, ops);
        const tokenMap = tokens.reduce((acc, cur, i2, src7) => {
          ops.ngramLengths.forEach((ngl) => {
            var ngram = src7.slice(i2, i2 + ngl);
            if (ngram.length !== ngl)
              return;
            cur = JSON.stringify(ngram);
            acc[cur] = acc[cur] || [];
            acc[cur].push(i2);
          });
          return acc;
        }, {});
        return Object.keys(tokenMap).map((t2) => {
          return {
            term: JSON.parse(t2),
            positions: tokenMap[t2]
          };
        }).sort((a2, b2) => a2.term[0] > b2.term[0]);
      };
    }
  });

  // node_modules/ngraminator/dist/ngraminator.umd.js
  var require_ngraminator_umd = __commonJS({
    "node_modules/ngraminator/dist/ngraminator.umd.js"(exports2, module2) {
      init_virtual_process_polyfill();
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.ngrm = {}));
      })(exports2, function(exports3) {
        "use strict";
        const ngraminator = function(inputArray, nGramLengths) {
          return nGramLengths.reduce(
            (acc, cur) => [...getNGramsOfSingleLength(inputArray, cur), ...acc],
            []
          ).sort();
        };
        const getNGramsOfSingleLength = function(inputArray, nGramLength) {
          return inputArray.slice(nGramLength - 1).map((item, i2) => {
            return inputArray.slice(i2, i2 + nGramLength);
          });
        };
        exports3.ngraminator = ngraminator;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    }
  });

  // node_modules/search-index/src/tokenisationPipeline.js
  var require_tokenisationPipeline = __commonJS({
    "node_modules/search-index/src/tokenisationPipeline.js"(exports2) {
      init_virtual_process_polyfill();
      var tv = require_term_vector();
      var { ngraminator } = require_ngraminator_umd();
      var SPLIT = ([tokens, field, ops]) => Promise.resolve([tokens.match(ops.tokenSplitRegex) || [], field, ops]);
      var SKIP = ([tokens, field, ops]) => [
        ops.skipFields.includes(field) ? [] : tokens,
        field,
        ops
      ];
      var LOWCASE = ([tokens, field, ops]) => Promise.resolve([
        tokens.map((t2) => ops.caseSensitive ? t2 : t2.toLowerCase()),
        field,
        ops
      ]);
      var REPLACE = ([tokens, field, ops]) => {
        const { fields, values } = ops.replace;
        const replace = () => tokens.reduce((acc, cur) => [cur, ...acc, ...values[cur] || []], []);
        if (!values)
          return Promise.resolve([tokens, field, ops]);
        if (!fields)
          return Promise.resolve([replace(), field, ops]);
        if (fields.includes(field))
          return Promise.resolve([replace(), field, ops]);
        return Promise.resolve([tokens, field, ops]);
      };
      var NGRAMS = ([tokens, field, ops]) => {
        let { fields, lengths, join = " " } = ops.ngrams;
        if (!fields)
          fields = [field];
        if (lengths) {
          if (fields.includes(field)) {
            return [
              ngraminator(
                tokens.filter((t2) => t2 !== null),
                lengths
              ).map((t2) => t2.join(join)),
              field,
              ops
            ];
          }
        }
        return Promise.resolve([tokens, field, ops]);
      };
      var STOPWORDS = ([tokens, field, ops]) => {
        return [
          tokens.filter((t2) => !ops.stopwords.includes(t2.toLowerCase())),
          field,
          ops
        ];
      };
      var SCORE_TERM_FREQUENCY = ([tokens, field, ops]) => {
        const v2 = tv(tokens);
        const mostTokenOccurances = v2.reduce(
          (acc, cur) => Math.max(cur.positions.length, acc),
          0
        );
        return Promise.resolve([
          v2.map(
            (item) => JSON.stringify([
              item.term[0],
              (item.positions.length / mostTokenOccurances).toFixed(2)
            ])
          ).sort(),
          field,
          ops
        ]);
      };
      exports2.SPY = ([tokens, field, ops]) => {
        console.log("----------------");
        console.log("field ->");
        console.log(field);
        console.log("tokens ->");
        console.log(tokens);
        console.log("----------------");
        return Promise.resolve([tokens, field, ops]);
      };
      exports2.tokenizer = (tokens, field, ops) => SPLIT([tokens, field, ops]).then(SKIP).then(LOWCASE).then(REPLACE).then(NGRAMS).then(STOPWORDS).then(SCORE_TERM_FREQUENCY).then(([tokens2, field2, ops2]) => tokens2);
      exports2.SPLIT = SPLIT;
      exports2.SKIP = SKIP;
      exports2.LOWACASE = LOWCASE;
      exports2.REPLACE = REPLACE;
      exports2.NGRAMS = NGRAMS;
      exports2.STOPWORDS = STOPWORDS;
      exports2.SCORE_TERM_FREQUENCY = SCORE_TERM_FREQUENCY;
    }
  });

  // node_modules/lru-cache/index.js
  var require_lru_cache = __commonJS({
    "node_modules/lru-cache/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
      var hasAbortController = typeof AbortController === "function";
      var AC = hasAbortController ? AbortController : class AbortController {
        constructor() {
          this.signal = new AS();
        }
        abort() {
          this.signal.dispatchEvent("abort");
        }
      };
      var hasAbortSignal = typeof AbortSignal === "function";
      var hasACAbortSignal = typeof AC.AbortSignal === "function";
      var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
        constructor() {
          this.aborted = false;
          this._listeners = [];
        }
        dispatchEvent(type) {
          if (type === "abort") {
            this.aborted = true;
            const e2 = { type, target: this };
            this.onabort(e2);
            this._listeners.forEach((f2) => f2(e2), this);
          }
        }
        onabort() {
        }
        addEventListener(ev, fn) {
          if (ev === "abort") {
            this._listeners.push(fn);
          }
        }
        removeEventListener(ev, fn) {
          if (ev === "abort") {
            this._listeners = this._listeners.filter((f2) => f2 !== fn);
          }
        }
      };
      var warned = /* @__PURE__ */ new Set();
      var deprecatedOption = (opt, instead) => {
        const code8 = `LRU_CACHE_OPTION_${opt}`;
        if (shouldWarn(code8)) {
          warn(code8, `${opt} option`, `options.${instead}`, LRUCache);
        }
      };
      var deprecatedMethod = (method, instead) => {
        const code8 = `LRU_CACHE_METHOD_${method}`;
        if (shouldWarn(code8)) {
          const { prototype } = LRUCache;
          const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, method);
          warn(code8, `${method} method`, `cache.${instead}()`, get2);
        }
      };
      var deprecatedProperty = (field, instead) => {
        const code8 = `LRU_CACHE_PROPERTY_${field}`;
        if (shouldWarn(code8)) {
          const { prototype } = LRUCache;
          const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, field);
          warn(code8, `${field} property`, `cache.${instead}`, get2);
        }
      };
      var emitWarning2 = (...a2) => {
        typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a2) : console.error(...a2);
      };
      var shouldWarn = (code8) => !warned.has(code8);
      var warn = (code8, what, instead, fn) => {
        warned.add(code8);
        const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
        emitWarning2(msg, "DeprecationWarning", code8, fn);
      };
      var isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2);
      var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
      var ZeroArray = class extends Array {
        constructor(size) {
          super(size);
          this.fill(0);
        }
      };
      var Stack = class {
        constructor(max) {
          if (max === 0) {
            return [];
          }
          const UintArray = getUintArray(max);
          this.heap = new UintArray(max);
          this.length = 0;
        }
        push(n2) {
          this.heap[this.length++] = n2;
        }
        pop() {
          return this.heap[--this.length];
        }
      };
      var LRUCache = class {
        constructor(options = {}) {
          const {
            max = 0,
            ttl,
            ttlResolution = 1,
            ttlAutopurge,
            updateAgeOnGet,
            updateAgeOnHas,
            allowStale,
            dispose,
            disposeAfter,
            noDisposeOnSet,
            noUpdateTTL,
            maxSize = 0,
            maxEntrySize = 0,
            sizeCalculation,
            fetchMethod,
            fetchContext,
            noDeleteOnFetchRejection,
            noDeleteOnStaleGet
          } = options;
          const { length: length7, maxAge, stale } = options instanceof LRUCache ? {} : options;
          if (max !== 0 && !isPosInt(max)) {
            throw new TypeError("max option must be a nonnegative integer");
          }
          const UintArray = max ? getUintArray(max) : Array;
          if (!UintArray) {
            throw new Error("invalid max value: " + max);
          }
          this.max = max;
          this.maxSize = maxSize;
          this.maxEntrySize = maxEntrySize || this.maxSize;
          this.sizeCalculation = sizeCalculation || length7;
          if (this.sizeCalculation) {
            if (!this.maxSize && !this.maxEntrySize) {
              throw new TypeError(
                "cannot set sizeCalculation without setting maxSize or maxEntrySize"
              );
            }
            if (typeof this.sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation set to non-function");
            }
          }
          this.fetchMethod = fetchMethod || null;
          if (this.fetchMethod && typeof this.fetchMethod !== "function") {
            throw new TypeError(
              "fetchMethod must be a function if specified"
            );
          }
          this.fetchContext = fetchContext;
          if (!this.fetchMethod && fetchContext !== void 0) {
            throw new TypeError(
              "cannot set fetchContext without fetchMethod"
            );
          }
          this.keyMap = /* @__PURE__ */ new Map();
          this.keyList = new Array(max).fill(null);
          this.valList = new Array(max).fill(null);
          this.next = new UintArray(max);
          this.prev = new UintArray(max);
          this.head = 0;
          this.tail = 0;
          this.free = new Stack(max);
          this.initialFill = 1;
          this.size = 0;
          if (typeof dispose === "function") {
            this.dispose = dispose;
          }
          if (typeof disposeAfter === "function") {
            this.disposeAfter = disposeAfter;
            this.disposed = [];
          } else {
            this.disposeAfter = null;
            this.disposed = null;
          }
          this.noDisposeOnSet = !!noDisposeOnSet;
          this.noUpdateTTL = !!noUpdateTTL;
          this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
          if (this.maxEntrySize !== 0) {
            if (this.maxSize !== 0) {
              if (!isPosInt(this.maxSize)) {
                throw new TypeError(
                  "maxSize must be a positive integer if specified"
                );
              }
            }
            if (!isPosInt(this.maxEntrySize)) {
              throw new TypeError(
                "maxEntrySize must be a positive integer if specified"
              );
            }
            this.initializeSizeTracking();
          }
          this.allowStale = !!allowStale || !!stale;
          this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
          this.updateAgeOnGet = !!updateAgeOnGet;
          this.updateAgeOnHas = !!updateAgeOnHas;
          this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
          this.ttlAutopurge = !!ttlAutopurge;
          this.ttl = ttl || maxAge || 0;
          if (this.ttl) {
            if (!isPosInt(this.ttl)) {
              throw new TypeError(
                "ttl must be a positive integer if specified"
              );
            }
            this.initializeTTLTracking();
          }
          if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
            throw new TypeError(
              "At least one of max, maxSize, or ttl is required"
            );
          }
          if (!this.ttlAutopurge && !this.max && !this.maxSize) {
            const code8 = "LRU_CACHE_UNBOUNDED";
            if (shouldWarn(code8)) {
              warned.add(code8);
              const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
              emitWarning2(msg, "UnboundedCacheWarning", code8, LRUCache);
            }
          }
          if (stale) {
            deprecatedOption("stale", "allowStale");
          }
          if (maxAge) {
            deprecatedOption("maxAge", "ttl");
          }
          if (length7) {
            deprecatedOption("length", "sizeCalculation");
          }
        }
        getRemainingTTL(key) {
          return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
        }
        initializeTTLTracking() {
          this.ttls = new ZeroArray(this.max);
          this.starts = new ZeroArray(this.max);
          this.setItemTTL = (index, ttl, start = perf.now()) => {
            this.starts[index] = ttl !== 0 ? start : 0;
            this.ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
              const t2 = setTimeout(() => {
                if (this.isStale(index)) {
                  this.delete(this.keyList[index]);
                }
              }, ttl + 1);
              if (t2.unref) {
                t2.unref();
              }
            }
          };
          this.updateItemAge = (index) => {
            this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
          };
          let cachedNow = 0;
          const getNow = () => {
            const n2 = perf.now();
            if (this.ttlResolution > 0) {
              cachedNow = n2;
              const t2 = setTimeout(
                () => cachedNow = 0,
                this.ttlResolution
              );
              if (t2.unref) {
                t2.unref();
              }
            }
            return n2;
          };
          this.getRemainingTTL = (key) => {
            const index = this.keyMap.get(key);
            if (index === void 0) {
              return 0;
            }
            return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
          };
          this.isStale = (index) => {
            return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
          };
        }
        updateItemAge(index) {
        }
        setItemTTL(index, ttl, start) {
        }
        isStale(index) {
          return false;
        }
        initializeSizeTracking() {
          this.calculatedSize = 0;
          this.sizes = new ZeroArray(this.max);
          this.removeItemSize = (index) => {
            this.calculatedSize -= this.sizes[index];
            this.sizes[index] = 0;
          };
          this.requireSize = (k2, v2, size, sizeCalculation) => {
            if (this.isBackgroundFetch(v2)) {
              return 0;
            }
            if (!isPosInt(size)) {
              if (sizeCalculation) {
                if (typeof sizeCalculation !== "function") {
                  throw new TypeError("sizeCalculation must be a function");
                }
                size = sizeCalculation(v2, k2);
                if (!isPosInt(size)) {
                  throw new TypeError(
                    "sizeCalculation return invalid (expect positive integer)"
                  );
                }
              } else {
                throw new TypeError(
                  "invalid size value (must be positive integer)"
                );
              }
            }
            return size;
          };
          this.addItemSize = (index, size) => {
            this.sizes[index] = size;
            if (this.maxSize) {
              const maxSize = this.maxSize - this.sizes[index];
              while (this.calculatedSize > maxSize) {
                this.evict(true);
              }
            }
            this.calculatedSize += this.sizes[index];
          };
        }
        removeItemSize(index) {
        }
        addItemSize(index, size) {
        }
        requireSize(k2, v2, size, sizeCalculation) {
          if (size || sizeCalculation) {
            throw new TypeError(
              "cannot set size without setting maxSize or maxEntrySize on cache"
            );
          }
        }
        *indexes({ allowStale = this.allowStale } = {}) {
          if (this.size) {
            for (let i2 = this.tail; true; ) {
              if (!this.isValidIndex(i2)) {
                break;
              }
              if (allowStale || !this.isStale(i2)) {
                yield i2;
              }
              if (i2 === this.head) {
                break;
              } else {
                i2 = this.prev[i2];
              }
            }
          }
        }
        *rindexes({ allowStale = this.allowStale } = {}) {
          if (this.size) {
            for (let i2 = this.head; true; ) {
              if (!this.isValidIndex(i2)) {
                break;
              }
              if (allowStale || !this.isStale(i2)) {
                yield i2;
              }
              if (i2 === this.tail) {
                break;
              } else {
                i2 = this.next[i2];
              }
            }
          }
        }
        isValidIndex(index) {
          return this.keyMap.get(this.keyList[index]) === index;
        }
        *entries() {
          for (const i2 of this.indexes()) {
            yield [this.keyList[i2], this.valList[i2]];
          }
        }
        *rentries() {
          for (const i2 of this.rindexes()) {
            yield [this.keyList[i2], this.valList[i2]];
          }
        }
        *keys() {
          for (const i2 of this.indexes()) {
            yield this.keyList[i2];
          }
        }
        *rkeys() {
          for (const i2 of this.rindexes()) {
            yield this.keyList[i2];
          }
        }
        *values() {
          for (const i2 of this.indexes()) {
            yield this.valList[i2];
          }
        }
        *rvalues() {
          for (const i2 of this.rindexes()) {
            yield this.valList[i2];
          }
        }
        [Symbol.iterator]() {
          return this.entries();
        }
        find(fn, getOptions = {}) {
          for (const i2 of this.indexes()) {
            if (fn(this.valList[i2], this.keyList[i2], this)) {
              return this.get(this.keyList[i2], getOptions);
            }
          }
        }
        forEach(fn, thisp = this) {
          for (const i2 of this.indexes()) {
            fn.call(thisp, this.valList[i2], this.keyList[i2], this);
          }
        }
        rforEach(fn, thisp = this) {
          for (const i2 of this.rindexes()) {
            fn.call(thisp, this.valList[i2], this.keyList[i2], this);
          }
        }
        get prune() {
          deprecatedMethod("prune", "purgeStale");
          return this.purgeStale;
        }
        purgeStale() {
          let deleted = false;
          for (const i2 of this.rindexes({ allowStale: true })) {
            if (this.isStale(i2)) {
              this.delete(this.keyList[i2]);
              deleted = true;
            }
          }
          return deleted;
        }
        dump() {
          const arr = [];
          for (const i2 of this.indexes({ allowStale: true })) {
            const key = this.keyList[i2];
            const v2 = this.valList[i2];
            const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
            const entry = { value };
            if (this.ttls) {
              entry.ttl = this.ttls[i2];
              const age = perf.now() - this.starts[i2];
              entry.start = Math.floor(Date.now() - age);
            }
            if (this.sizes) {
              entry.size = this.sizes[i2];
            }
            arr.unshift([key, entry]);
          }
          return arr;
        }
        load(arr) {
          this.clear();
          for (const [key, entry] of arr) {
            if (entry.start) {
              const age = Date.now() - entry.start;
              entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
          }
        }
        dispose(v2, k2, reason) {
        }
        set(k2, v2, {
          ttl = this.ttl,
          start,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL
        } = {}) {
          size = this.requireSize(k2, v2, size, sizeCalculation);
          if (this.maxEntrySize && size > this.maxEntrySize) {
            this.delete(k2);
            return this;
          }
          let index = this.size === 0 ? void 0 : this.keyMap.get(k2);
          if (index === void 0) {
            index = this.newIndex();
            this.keyList[index] = k2;
            this.valList[index] = v2;
            this.keyMap.set(k2, index);
            this.next[this.tail] = index;
            this.prev[index] = this.tail;
            this.tail = index;
            this.size++;
            this.addItemSize(index, size);
            noUpdateTTL = false;
          } else {
            const oldVal = this.valList[index];
            if (v2 !== oldVal) {
              if (this.isBackgroundFetch(oldVal)) {
                oldVal.__abortController.abort();
              } else {
                if (!noDisposeOnSet) {
                  this.dispose(oldVal, k2, "set");
                  if (this.disposeAfter) {
                    this.disposed.push([oldVal, k2, "set"]);
                  }
                }
              }
              this.removeItemSize(index);
              this.valList[index] = v2;
              this.addItemSize(index, size);
            }
            this.moveToTail(index);
          }
          if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
            this.initializeTTLTracking();
          }
          if (!noUpdateTTL) {
            this.setItemTTL(index, ttl, start);
          }
          if (this.disposeAfter) {
            while (this.disposed.length) {
              this.disposeAfter(...this.disposed.shift());
            }
          }
          return this;
        }
        newIndex() {
          if (this.size === 0) {
            return this.tail;
          }
          if (this.size === this.max && this.max !== 0) {
            return this.evict(false);
          }
          if (this.free.length !== 0) {
            return this.free.pop();
          }
          return this.initialFill++;
        }
        pop() {
          if (this.size) {
            const val = this.valList[this.head];
            this.evict(true);
            return val;
          }
        }
        evict(free) {
          const head = this.head;
          const k2 = this.keyList[head];
          const v2 = this.valList[head];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort();
          } else {
            this.dispose(v2, k2, "evict");
            if (this.disposeAfter) {
              this.disposed.push([v2, k2, "evict"]);
            }
          }
          this.removeItemSize(head);
          if (free) {
            this.keyList[head] = null;
            this.valList[head] = null;
            this.free.push(head);
          }
          this.head = this.next[head];
          this.keyMap.delete(k2);
          this.size--;
          return head;
        }
        has(k2, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
          const index = this.keyMap.get(k2);
          if (index !== void 0) {
            if (!this.isStale(index)) {
              if (updateAgeOnHas) {
                this.updateItemAge(index);
              }
              return true;
            }
          }
          return false;
        }
        peek(k2, { allowStale = this.allowStale } = {}) {
          const index = this.keyMap.get(k2);
          if (index !== void 0 && (allowStale || !this.isStale(index))) {
            const v2 = this.valList[index];
            return this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          }
        }
        backgroundFetch(k2, index, options, context) {
          const v2 = index === void 0 ? void 0 : this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            return v2;
          }
          const ac = new AC();
          const fetchOpts = {
            signal: ac.signal,
            options,
            context
          };
          const cb = (v3) => {
            if (!ac.signal.aborted) {
              this.set(k2, v3, fetchOpts.options);
            }
            return v3;
          };
          const eb = (er) => {
            if (this.valList[index] === p2) {
              const del = !options.noDeleteOnFetchRejection || p2.__staleWhileFetching === void 0;
              if (del) {
                this.delete(k2);
              } else {
                this.valList[index] = p2.__staleWhileFetching;
              }
            }
            if (p2.__returned === p2) {
              throw er;
            }
          };
          const pcall = (res) => res(this.fetchMethod(k2, v2, fetchOpts));
          const p2 = new Promise(pcall).then(cb, eb);
          p2.__abortController = ac;
          p2.__staleWhileFetching = v2;
          p2.__returned = null;
          if (index === void 0) {
            this.set(k2, p2, fetchOpts.options);
            index = this.keyMap.get(k2);
          } else {
            this.valList[index] = p2;
          }
          return p2;
        }
        isBackgroundFetch(p2) {
          return p2 && typeof p2 === "object" && typeof p2.then === "function" && Object.prototype.hasOwnProperty.call(
            p2,
            "__staleWhileFetching"
          ) && Object.prototype.hasOwnProperty.call(p2, "__returned") && (p2.__returned === p2 || p2.__returned === null);
        }
        async fetch(k2, {
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          fetchContext = this.fetchContext,
          forceRefresh = false
        } = {}) {
          if (!this.fetchMethod) {
            return this.get(k2, {
              allowStale,
              updateAgeOnGet,
              noDeleteOnStaleGet
            });
          }
          const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection
          };
          let index = this.keyMap.get(k2);
          if (index === void 0) {
            const p2 = this.backgroundFetch(k2, index, options, fetchContext);
            return p2.__returned = p2;
          } else {
            const v2 = this.valList[index];
            if (this.isBackgroundFetch(v2)) {
              return allowStale && v2.__staleWhileFetching !== void 0 ? v2.__staleWhileFetching : v2.__returned = v2;
            }
            if (!forceRefresh && !this.isStale(index)) {
              this.moveToTail(index);
              if (updateAgeOnGet) {
                this.updateItemAge(index);
              }
              return v2;
            }
            const p2 = this.backgroundFetch(k2, index, options, fetchContext);
            return allowStale && p2.__staleWhileFetching !== void 0 ? p2.__staleWhileFetching : p2.__returned = p2;
          }
        }
        get(k2, {
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet
        } = {}) {
          const index = this.keyMap.get(k2);
          if (index !== void 0) {
            const value = this.valList[index];
            const fetching = this.isBackgroundFetch(value);
            if (this.isStale(index)) {
              if (!fetching) {
                if (!noDeleteOnStaleGet) {
                  this.delete(k2);
                }
                return allowStale ? value : void 0;
              } else {
                return allowStale ? value.__staleWhileFetching : void 0;
              }
            } else {
              if (fetching) {
                return void 0;
              }
              this.moveToTail(index);
              if (updateAgeOnGet) {
                this.updateItemAge(index);
              }
              return value;
            }
          }
        }
        connect(p2, n2) {
          this.prev[n2] = p2;
          this.next[p2] = n2;
        }
        moveToTail(index) {
          if (index !== this.tail) {
            if (index === this.head) {
              this.head = this.next[index];
            } else {
              this.connect(this.prev[index], this.next[index]);
            }
            this.connect(this.tail, index);
            this.tail = index;
          }
        }
        get del() {
          deprecatedMethod("del", "delete");
          return this.delete;
        }
        delete(k2) {
          let deleted = false;
          if (this.size !== 0) {
            const index = this.keyMap.get(k2);
            if (index !== void 0) {
              deleted = true;
              if (this.size === 1) {
                this.clear();
              } else {
                this.removeItemSize(index);
                const v2 = this.valList[index];
                if (this.isBackgroundFetch(v2)) {
                  v2.__abortController.abort();
                } else {
                  this.dispose(v2, k2, "delete");
                  if (this.disposeAfter) {
                    this.disposed.push([v2, k2, "delete"]);
                  }
                }
                this.keyMap.delete(k2);
                this.keyList[index] = null;
                this.valList[index] = null;
                if (index === this.tail) {
                  this.tail = this.prev[index];
                } else if (index === this.head) {
                  this.head = this.next[index];
                } else {
                  this.next[this.prev[index]] = this.next[index];
                  this.prev[this.next[index]] = this.prev[index];
                }
                this.size--;
                this.free.push(index);
              }
            }
          }
          if (this.disposed) {
            while (this.disposed.length) {
              this.disposeAfter(...this.disposed.shift());
            }
          }
          return deleted;
        }
        clear() {
          for (const index of this.rindexes({ allowStale: true })) {
            const v2 = this.valList[index];
            if (this.isBackgroundFetch(v2)) {
              v2.__abortController.abort();
            } else {
              const k2 = this.keyList[index];
              this.dispose(v2, k2, "delete");
              if (this.disposeAfter) {
                this.disposed.push([v2, k2, "delete"]);
              }
            }
          }
          this.keyMap.clear();
          this.valList.fill(null);
          this.keyList.fill(null);
          if (this.ttls) {
            this.ttls.fill(0);
            this.starts.fill(0);
          }
          if (this.sizes) {
            this.sizes.fill(0);
          }
          this.head = 0;
          this.tail = 0;
          this.initialFill = 1;
          this.free.length = 0;
          this.calculatedSize = 0;
          this.size = 0;
          if (this.disposed) {
            while (this.disposed.length) {
              this.disposeAfter(...this.disposed.shift());
            }
          }
        }
        get reset() {
          deprecatedMethod("reset", "clear");
          return this.clear;
        }
        get length() {
          deprecatedProperty("length", "size");
          return this.size;
        }
        static get AbortController() {
          return AC;
        }
        static get AbortSignal() {
          return AS;
        }
      };
      module2.exports = LRUCache;
    }
  });

  // node_modules/search-index/src/read.js
  var require_read2 = __commonJS({
    "node_modules/search-index/src/read.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = (ops, cache2) => {
        const ALL_DOCUMENTS = (limit) => new Promise((resolve5, reject) => {
          const result = [];
          ops.fii.STORE.createReadStream({
            gte: ["DOC_RAW", null],
            lte: ["DOC_RAW", void 0],
            limit
          }).on(
            "data",
            (d2) => result.push({
              _id: d2.value._id,
              _doc: d2.value
            })
          ).on("end", () => resolve5(result));
        });
        const DOCUMENTS = (...requestedDocs) => requestedDocs.length ? Promise.all(
          requestedDocs.map(
            (_id) => ops.fii.STORE.get(["DOC_RAW", _id]).catch((e2) => null)
          )
        ) : ALL_DOCUMENTS();
        const DICTIONARY = (token) => DISTINCT(token).then(
          (results) => Array.from(
            results.reduce((acc, cur) => acc.add(cur.VALUE), /* @__PURE__ */ new Set())
          ).sort(
            (a2, b2) => (a2 + "").localeCompare(b2 + "", void 0, {
              numeric: true,
              sensitivity: "base"
            })
          )
        );
        const DISTINCT = (...tokens) => ops.fii.DISTINCT(...tokens).then((result) => {
          return [
            ...result.reduce(
              (acc, cur) => acc.add(
                JSON.stringify(
                  Object.assign(cur, {
                    VALUE: cur.VALUE
                  })
                )
              ),
              /* @__PURE__ */ new Set()
            )
          ].map(JSON.parse);
        });
        const FACETS = (...tokens) => ops.fii.FACETS(...tokens).then(
          (result) => [
            ...result.reduce(
              (acc, cur) => acc.add(
                JSON.stringify(
                  Object.assign(cur, {
                    VALUE: cur.VALUE
                  })
                )
              ),
              /* @__PURE__ */ new Set()
            )
          ].map(JSON.parse)
        );
        const PAGE = (results, options) => {
          options = Object.assign(
            {
              NUMBER: 0,
              SIZE: 20
            },
            options || {}
          );
          const start = options.NUMBER * options.SIZE;
          const end = start + options.SIZE || void 0;
          return results.slice(start, end);
        };
        const SCORE = (results, scoreOps = {}) => {
          const filterFields = (item) => {
            if (!scoreOps.FIELDS)
              return true;
            return scoreOps.FIELDS.includes(item.FIELD);
          };
          scoreOps = Object.assign(
            {
              TYPE: "TFIDF"
            },
            scoreOps
          );
          if (scoreOps.TYPE === "TFIDF") {
            return DOCUMENT_COUNT().then(
              (docCount) => results.map((result, _3, resultSet) => {
                const idf = Math.log((docCount + 1) / resultSet.length);
                result._score = +result._match.filter(filterFields).reduce((acc, cur) => acc + idf * +cur.SCORE, 0).toFixed(2);
                return result;
              })
            );
          }
          if (scoreOps.TYPE === "PRODUCT") {
            return new Promise(
              (resolve5) => resolve5(
                results.map((r2) => {
                  r2._score = +r2._match.filter(filterFields).reduce((acc, cur) => acc * +cur.SCORE, 1).toFixed(2);
                  return r2;
                })
              )
            );
          }
          if (scoreOps.TYPE === "CONCAT") {
            return new Promise(
              (resolve5) => resolve5(
                results.map((r2) => {
                  r2._score = r2._match.filter(filterFields).reduce((acc, cur) => acc + cur.SCORE, "");
                  return r2;
                })
              )
            );
          }
          if (scoreOps.TYPE === "SUM") {
            return new Promise(
              (resolve5) => resolve5(
                results.map((r2) => {
                  r2._score = +r2._match.filter(filterFields).reduce((acc, cur) => acc + +cur.SCORE, 0).toFixed(2);
                  return r2;
                })
              )
            );
          }
          if (scoreOps.TYPE === "VALUE") {
            return new Promise(
              (resolve5) => resolve5(
                results.map((r2) => {
                  r2._score = r2._match.filter(filterFields).reduce((acc, cur) => acc + cur.VALUE, "");
                  return r2;
                })
              )
            );
          }
        };
        const SEARCH = (q2, qops) => {
          return parseJsonQuery(
            {
              AND: [...q2]
            },
            Object.assign(
              {
                SCORE: {
                  TYPE: "TFIDF"
                },
                SORT: true
              },
              qops
            )
          );
        };
        const SORT = (results, options) => {
          options = Object.assign(
            {
              DIRECTION: "DESCENDING",
              TYPE: "NUMERIC"
            },
            options || {}
          );
          const sortFunction = {
            NUMERIC: {
              DESCENDING: (a2, b2) => +b2._score - +a2._score,
              ASCENDING: (a2, b2) => +a2._score - +b2._score
            },
            ALPHABETIC: {
              DESCENDING: (a2, b2) => {
                if (a2._score < b2._score)
                  return 1;
                if (a2._score > b2._score)
                  return -1;
                return 0;
              },
              ASCENDING: (a2, b2) => {
                if (a2._score < b2._score)
                  return -1;
                if (a2._score > b2._score)
                  return 1;
                return 0;
              }
            }
          };
          return results.sort((a2, b2) => {
            if (a2._id < b2._id)
              return -1;
            if (a2._id > b2._id)
              return 1;
            return 0;
          }).sort(sortFunction[options.TYPE][options.DIRECTION]);
        };
        const DOCUMENT_COUNT = () => ops.fii.STORE.get(["DOCUMENT_COUNT"]);
        const WEIGHT = (results, weights) => results.map((r2) => {
          r2._match = r2._match.map((m2) => {
            weights.forEach((w2) => {
              let doWeighting = false;
              if (w2.FIELD && w2.VALUE) {
                if (w2.FIELD === m2.FIELD && w2.VALUE === m2.VALUE) {
                  doWeighting = true;
                }
              } else if (w2.FIELD) {
                if (w2.FIELD === m2.FIELD) {
                  doWeighting = true;
                }
              } else if (w2.VALUE) {
                if (w2.VALUE === m2.VALUE) {
                  doWeighting = true;
                }
              }
              if (doWeighting)
                m2.SCORE = (w2.WEIGHT * +m2.SCORE).toFixed(2);
            });
            return m2;
          });
          return r2;
        });
        const parseJsonQuery = (q2, options = {}) => {
          const runQuery = (cmd) => {
            if (typeof cmd === "string" || typeof cmd === "number") {
              return ops.fii.GET(cmd, options.PIPELINE);
            }
            if (cmd.FIELD)
              return ops.fii.GET(cmd);
            if (cmd.VALUE)
              return ops.fii.GET(cmd);
            if (cmd.AND)
              return ops.fii.AND(cmd.AND.map(runQuery), options.PIPELINE);
            if (cmd.GET)
              return ops.fii.GET(cmd.GET, options.PIPELINE);
            if (cmd.NOT) {
              return ops.fii.NOT(runQuery(cmd.NOT.INCLUDE), runQuery(cmd.NOT.EXCLUDE));
            }
            if (cmd.OR)
              return ops.fii.OR(cmd.OR.map(runQuery), options.PIPELINE);
            if (cmd.ALL_DOCUMENTS)
              return ALL_DOCUMENTS(cmd.ALL_DOCUMENTS);
          };
          const formatResults = (result) => result.RESULT ? Object.assign(result, {
            RESULT_LENGTH: result.RESULT.length
          }) : {
            RESULT: result,
            RESULT_LENGTH: result.length
          };
          const appendDocuments = (result) => options.DOCUMENTS ? DOCUMENTS(...result.RESULT.map((doc) => doc._id)).then(
            (documents) => Object.assign(result, {
              RESULT: result.RESULT.map(
                (doc, i2) => Object.assign(doc, {
                  _doc: documents[i2]
                })
              )
            })
          ) : result;
          const score = (result) => options.SCORE ? SCORE(result.RESULT, options.SCORE).then(
            (scoredResult) => Object.assign(result, {
              RESULT: scoredResult
            })
          ) : result;
          const sort = (result) => Object.assign(
            result,
            options.SORT ? {
              RESULT: SORT(result.RESULT, options.SORT)
            } : {}
          );
          const buckets = (result) => options.BUCKETS ? ops.fii.BUCKETS(...options.BUCKETS).then(
            (bkts) => Object.assign(result, {
              BUCKETS: ops.fii.AGGREGATION_FILTER(bkts, result.RESULT)
            })
          ) : result;
          const facets = (result) => {
            if (!options.FACETS)
              return result;
            if (!result.RESULT.length) {
              return Object.assign(result, {
                FACETS: []
              });
            }
            if (q2.ALL_DOCUMENTS) {
              return FACETS(...options.FACETS).then(
                (fcts) => Object.assign(result, {
                  FACETS: fcts
                })
              );
            }
            return FACETS(...options.FACETS).then(
              (fcts) => Object.assign(result, {
                FACETS: ops.fii.AGGREGATION_FILTER(fcts, result.RESULT)
              })
            );
          };
          const page = (result) => Object.assign(
            result,
            options.PAGE ? { RESULT: PAGE(result.RESULT, options.PAGE) } : {}
          );
          const weight = (result) => options.WEIGHT ? Object.assign(
            { RESULT: WEIGHT(result.RESULT, options.WEIGHT) },
            result
          ) : result;
          return runQuery(q2).then(formatResults).then(buckets).then(facets).then(weight).then(score).then(sort).then(page).then(appendDocuments);
        };
        const tryCache = (q2, cacheKey) => new Promise((resolve5) => {
          cacheKey = JSON.stringify(cacheKey);
          return cache2.has(cacheKey) ? resolve5(cache2.get(cacheKey)) : q2.then((res) => cache2.set(cacheKey, res)).then(() => resolve5(cache2.get(cacheKey)));
        });
        return {
          ALL_DOCUMENTS,
          DICTIONARY: (token) => tryCache(DICTIONARY(token), { DICTIONARY: token || null }),
          DISTINCT,
          DOCUMENTS: (...docs) => tryCache(DOCUMENTS(...docs), {
            DOCUMENTS: docs
          }),
          DOCUMENT_COUNT,
          FACETS,
          PAGE,
          QUERY: (q2, qops) => tryCache(parseJsonQuery(q2, qops), { QUERY: [q2, qops] }),
          SCORE,
          SEARCH: (q2, qops) => tryCache(SEARCH(q2, qops), { SEARCH: [q2, qops] }),
          SORT
        };
      };
    }
  });

  // node_modules/search-index/src/DocumentProcessor.js
  var require_DocumentProcessor = __commonJS({
    "node_modules/search-index/src/DocumentProcessor.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = (ops) => {
        const isObject2 = (item) => typeof item === "object" && item !== null && !Array.isArray(item);
        const isString2 = (item) => typeof item === "string" || item instanceof String;
        const isArray3 = (item) => Array.isArray(item);
        const isEmptyObject = (item) => item && Object.keys(item).length === 0 && Object.getPrototypeOf(item) === Object.prototype;
        const processValueArray = (arr) => Promise.all(arr.map(processValueUnknownType));
        const processValueObject = (obj) => new Promise(async (resolve5) => {
          const acc = {};
          for (const key in obj) {
            acc[key] = await processValueUnknownType(obj[key], key, ops);
          }
          return resolve5(acc);
        });
        const processValueUnknownType = (unknown, key) => new Promise(async (resolve5) => {
          if (unknown === null)
            return resolve5(JSON.stringify([null, "1.00"]));
          if (isEmptyObject(unknown))
            return resolve5(JSON.stringify([[], "1.00"]));
          if (Number.isInteger(unknown)) {
            return resolve5(JSON.stringify([unknown, unknown]));
          }
          if (isString2(unknown))
            return resolve5(ops.tokenizer(unknown, key, ops));
          if (isObject2(unknown))
            return resolve5(processValueObject(unknown));
          if (isArray3(unknown))
            return resolve5(processValueArray(unknown));
          return resolve5(unknown);
        });
        const processDocument = async (doc) => new Promise(async (resolve5) => {
          if (isString2(doc))
            doc = { body: doc };
          if (!Object.prototype.hasOwnProperty.call(doc, "_id")) {
            doc._id = ops.idGenerator.next().value;
          }
          const acc = {};
          for (const key in doc) {
            if (key === "_id") {
              acc[key] = doc[key];
              continue;
            }
            acc[key] = await processValueUnknownType(doc[key], key);
          }
          return resolve5(acc);
        });
        return {
          processDocuments: (docs) => Promise.all(docs.map(processDocument))
        };
      };
    }
  });

  // node_modules/search-index/src/write.js
  var require_write2 = __commonJS({
    "node_modules/search-index/src/write.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var DocumentProcessor = require_DocumentProcessor();
      module2.exports = (ops, cache2, queue3) => {
        const incrementDocCount = (increment) => ops.fii.STORE.get(["DOCUMENT_COUNT"]).then((count) => ops.fii.STORE.put(["DOCUMENT_COUNT"], +count + increment)).catch(
          (e2) => ops.fii.STORE.put(["DOCUMENT_COUNT"], increment)
        );
        const decrementDocCount = (increment) => ops.fii.STORE.get(["DOCUMENT_COUNT"]).then(
          (count) => ops.fii.STORE.put(["DOCUMENT_COUNT"], +count - increment)
        );
        const _PUT = (docs, putOptions) => {
          cache2.clear();
          putOptions = Object.assign(ops, putOptions);
          return DocumentProcessor(ops).processDocuments(docs).then((vectors) => {
            return ops.fii.PUT(vectors, putOptions).then((result) => {
              return Promise.all([
                _PUT_RAW(
                  docs,
                  result.map((r2) => r2._id),
                  !ops.storeRawDocs
                ),
                incrementDocCount(result.filter((r2) => r2.status === "CREATED").length)
              ]).then(() => result);
            });
          });
        };
        const _PUT_RAW = (docs, ids, dontStoreValue) => {
          cache2.clear();
          return Promise.all(
            docs.map(
              (doc, i2) => ops.fii.STORE.put(["DOC_RAW", ids[i2]], dontStoreValue ? {} : doc)
            )
          ).then(
            (result) => docs.map((doc, i2) => ({
              _id: ids[i2],
              status: "OK",
              operation: "_PUT_RAW"
            }))
          );
        };
        const _DELETE = (_ids) => ops.fii.DELETE(_ids).then((result) => {
          cache2.clear();
          const deleted = result.filter((d2) => d2.status === "DELETED");
          return Promise.all([
            Promise.all(deleted.map((r2) => ops.fii.STORE.del(["DOC_RAW", r2._id]))),
            decrementDocCount(deleted.length)
          ]).then(() => result);
        });
        const _FLUSH = () => ops.fii.STORE.clear().then(() => {
          cache2.clear();
          const timestamp2 = Date.now();
          return ops.fii.STORE.batch([
            { type: "put", key: ["~CREATED"], value: timestamp2 },
            { type: "put", key: ["~LAST_UPDATED"], value: timestamp2 },
            { type: "put", key: ["DOCUMENT_COUNT"], value: 0 }
          ]);
        }).then(() => true);
        return {
          DELETE: (...docIds) => _DELETE(docIds),
          FLUSH: _FLUSH,
          IMPORT: (index) => {
            cache2.clear();
            return Promise.resolve(ops.fii.IMPORT(index));
          },
          PUT: (docs, pops) => queue3.add(() => _PUT(docs, pops)),
          PUT_RAW: _PUT_RAW,
          _INCREMENT_DOC_COUNT: incrementDocCount
        };
      };
    }
  });

  // node_modules/search-index/package.json
  var require_package = __commonJS({
    "node_modules/search-index/package.json"(exports2, module2) {
      module2.exports = {
        name: "search-index",
        version: "3.1.3",
        description: "A network resilient, persistent full-text search library for the browser and Node.js",
        keywords: [
          "search",
          "elasticsearch",
          "elastic",
          "lunr.js",
          "flexsearch",
          "norch",
          "solr"
        ],
        engines: {
          node: ">=12"
        },
        main: "src/node.js",
        browser: "src/browser.js",
        files: [
          "dist",
          "src"
        ],
        directories: {
          lib: "src"
        },
        scripts: {
          build: "npm run empty-sandbox && rm -rf ./dist/* && webpack && cp dist/search-index-$npm_package_version.js dist/search-index.js",
          "demo-export": "node demo/generate-index/export.js",
          "demo-fetch": "node demo/generate-index/fetch.js",
          "demo-process": "node demo/generate-index/process.js",
          "demo-rebuild": "npm run demo-fetch && npm run demo-process && npm run demo-export && npm run demo-link-lib",
          "demo-start": "http-server -c-1 demo & open-cli http://127.0.0.1:8080",
          "demo-link-lib": "cd demo/lib &&  ln -sf ../../dist/search-index.js && cd ../../",
          "empty-sandbox": "rm -rf fii && rm -rf test/sandbox && mkdir test/sandbox",
          lint: "standard --fix test/src/* src/* demo/src/* demo/generate-index/*.js",
          test: "npm run empty-sandbox && npm run test-node && npm run test-browser && npm run lint",
          "test-browser": "npm run build && cat test/sandbox/browser-tests.js | tape-run",
          "test-node": "npm run empty-sandbox && tape test/src/*-test.js",
          toc: "doctoc docs/API.md --title '# API Documentation for search-index' && doctoc docs/FAQ.md --title '# FAQ'"
        },
        repository: {
          type: "git",
          url: "git+https://github.com/fergiemcdowall/search-index.git"
        },
        author: "Fergus McDowall",
        license: "MIT",
        bugs: {
          url: "https://github.com/fergiemcdowall/search-index/issues"
        },
        homepage: "https://fergiemcdowall.github.io/search-index/",
        devDependencies: {
          assert: "^2.0.0",
          doctoc: "^2.2.0",
          fuzzyset: "1.0.5",
          "http-server": "14.1.0",
          "level-out": "^1.0.1",
          memdown: "^6.1.1",
          "open-cli": "^7.0.1",
          path: "^0.12.7",
          "path-browserify": "^1.0.1",
          process: "^0.11.10",
          standard: "^17.0.0",
          stemmer: "^1.0.5",
          stopword: "^2.0.2",
          "stream-browserify": "^3.0.0",
          tape: "^5.5.3",
          "tape-run": "^10.0.0",
          webpack: "^5.72.0",
          "webpack-cli": "^4.9.2",
          "world-bank-dataset": "^1.0.0"
        },
        dependencies: {
          "fergies-inverted-index": "10.0.6",
          "level-js": "^6.1.0",
          leveldown: "^6.1.1",
          "lru-cache": "^7.9.0",
          ngraminator: "^3.0.1",
          "p-queue": "^7.2.0",
          "term-vector": "^1.0.0"
        }
      };
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once4) {
        this.fn = fn;
        this.context = context;
        this.once = once4 || false;
      }
      function addListener4(emitter, event, fn, context, once4) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once4), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames2() {
        var names = [], events, name6;
        if (this._eventsCount === 0)
          return names;
        for (name6 in events = this._events) {
          if (has.call(events, name6))
            names.push(prefix ? name6.slice(1) : name6);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners2(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
          ee2[i2] = handlers[i2].fn;
        }
        return ee2;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount2(event) {
        var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
        if (!listeners2)
          return 0;
        if (listeners2.fn)
          return 1;
        return listeners2.length;
      };
      EventEmitter3.prototype.emit = function emit4(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners2 = this._events[evt], len = arguments.length, args, i2;
        if (listeners2.fn) {
          if (listeners2.once)
            this.removeListener(event, listeners2.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners2.fn.call(listeners2.context), true;
            case 2:
              return listeners2.fn.call(listeners2.context, a1), true;
            case 3:
              return listeners2.fn.call(listeners2.context, a1, a2), true;
            case 4:
              return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
            case 5:
              return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
            case 6:
              return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners2.fn.apply(listeners2.context, args);
        } else {
          var length7 = listeners2.length, j2;
          for (i2 = 0; i2 < length7; i2++) {
            if (listeners2[i2].once)
              this.removeListener(event, listeners2[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners2[i2].fn.call(listeners2[i2].context);
                break;
              case 2:
                listeners2[i2].fn.call(listeners2[i2].context, a1);
                break;
              case 3:
                listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
                break;
              case 4:
                listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners2[i2].fn.apply(listeners2[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on3(event, fn, context) {
        return addListener4(this, event, fn, context, false);
      };
      EventEmitter3.prototype.once = function once4(event, fn, context) {
        return addListener4(this, event, fn, context, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener4(event, fn, context, once4) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners2 = this._events[evt];
        if (listeners2.fn) {
          if (listeners2.fn === fn && (!once4 || listeners2.once) && (!context || listeners2.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length7 = listeners2.length; i2 < length7; i2++) {
            if (listeners2[i2].fn !== fn || once4 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
              events.push(listeners2[i2]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners4(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter3;
      }
    }
  });

  // node_modules/p-timeout/index.js
  function pTimeout(promise, milliseconds, fallback, options) {
    let timer;
    const cancelablePromise = new Promise((resolve5, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        resolve5(promise);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason(signal));
        });
      }
      timer = options.customTimers.setTimeout.call(void 0, () => {
        if (typeof fallback === "function") {
          try {
            resolve5(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError2);
      }, milliseconds);
      (async () => {
        try {
          resolve5(await promise);
        } catch (error) {
          reject(error);
        } finally {
          options.customTimers.clearTimeout.call(void 0, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = void 0;
    };
    return cancelablePromise;
  }
  var TimeoutError, AbortError, getDOMException, getAbortedReason;
  var init_p_timeout = __esm({
    "node_modules/p-timeout/index.js"() {
      init_virtual_process_polyfill();
      TimeoutError = class extends Error {
        constructor(message) {
          super(message);
          this.name = "TimeoutError";
        }
      };
      AbortError = class extends Error {
        constructor(message) {
          super();
          this.name = "AbortError";
          this.message = message;
        }
      };
      getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
      getAbortedReason = (signal) => {
        const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
        return reason instanceof Error ? reason : getDOMException(reason);
      };
    }
  });

  // node_modules/p-queue/dist/lower-bound.js
  function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
      const step = Math.trunc(count / 2);
      let it2 = first + step;
      if (comparator(array[it2], value) <= 0) {
        first = ++it2;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first;
  }
  var init_lower_bound = __esm({
    "node_modules/p-queue/dist/lower-bound.js"() {
      init_virtual_process_polyfill();
    }
  });

  // node_modules/p-queue/dist/priority-queue.js
  var __classPrivateFieldGet, _PriorityQueue_queue, PriorityQueue;
  var init_priority_queue = __esm({
    "node_modules/p-queue/dist/priority-queue.js"() {
      init_virtual_process_polyfill();
      init_lower_bound();
      __classPrivateFieldGet = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      PriorityQueue = class {
        constructor() {
          _PriorityQueue_queue.set(this, []);
        }
        enqueue(run, options) {
          options = {
            priority: 0,
            ...options
          };
          const element = {
            priority: options.priority,
            run
          };
          if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
            __classPrivateFieldGet(this, _PriorityQueue_queue, "f").push(element);
            return;
          }
          const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, "f"), element, (a2, b2) => b2.priority - a2.priority);
          __classPrivateFieldGet(this, _PriorityQueue_queue, "f").splice(index, 0, element);
        }
        dequeue() {
          const item = __classPrivateFieldGet(this, _PriorityQueue_queue, "f").shift();
          return item === null || item === void 0 ? void 0 : item.run;
        }
        filter(options) {
          return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
        }
        get size() {
          return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").length;
        }
      };
      _PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/p-queue/dist/index.js
  var dist_exports = {};
  __export(dist_exports, {
    AbortError: () => AbortError2,
    default: () => PQueue
  });
  var import_eventemitter3, __classPrivateFieldSet, __classPrivateFieldGet2, _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pendingCount, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_emitEvents, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_onEvent, timeoutError, AbortError2, PQueue;
  var init_dist = __esm({
    "node_modules/p-queue/dist/index.js"() {
      init_virtual_process_polyfill();
      import_eventemitter3 = __toESM(require_eventemitter3(), 1);
      init_p_timeout();
      init_priority_queue();
      __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      timeoutError = new TimeoutError();
      AbortError2 = class extends Error {
      };
      PQueue = class extends import_eventemitter3.default {
        constructor(options) {
          var _a, _b, _c, _d;
          super();
          _PQueue_instances.add(this);
          _PQueue_carryoverConcurrencyCount.set(this, void 0);
          _PQueue_isIntervalIgnored.set(this, void 0);
          _PQueue_intervalCount.set(this, 0);
          _PQueue_intervalCap.set(this, void 0);
          _PQueue_interval.set(this, void 0);
          _PQueue_intervalEnd.set(this, 0);
          _PQueue_intervalId.set(this, void 0);
          _PQueue_timeoutId.set(this, void 0);
          _PQueue_queue.set(this, void 0);
          _PQueue_queueClass.set(this, void 0);
          _PQueue_pendingCount.set(this, 0);
          _PQueue_concurrency.set(this, void 0);
          _PQueue_isPaused.set(this, void 0);
          _PQueue_throwOnTimeout.set(this, void 0);
          Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          options = {
            carryoverConcurrencyCount: false,
            intervalCap: Number.POSITIVE_INFINITY,
            interval: 0,
            concurrency: Number.POSITIVE_INFINITY,
            autoStart: true,
            queueClass: PriorityQueue,
            ...options
          };
          if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
            throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
          }
          if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
            throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
          }
          __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
          __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
          __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
          __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
          __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
          __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
          this.concurrency = options.concurrency;
          this.timeout = options.timeout;
          __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
          __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
        }
        get concurrency() {
          return __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
        }
        set concurrency(newConcurrency) {
          if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
            throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
          }
          __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
        }
        async add(fn, options = {}) {
          return new Promise((resolve5, reject) => {
            const run = async () => {
              var _a;
              var _b, _c;
              __classPrivateFieldSet(this, _PQueue_pendingCount, (_b = __classPrivateFieldGet2(this, _PQueue_pendingCount, "f"), _b++, _b), "f");
              __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet2(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
              try {
                if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
                  reject(new AbortError2("The task was aborted."));
                  return;
                }
                const operation = this.timeout === void 0 && options.timeout === void 0 ? fn({ signal: options.signal }) : pTimeout(Promise.resolve(fn({ signal: options.signal })), options.timeout === void 0 ? this.timeout : options.timeout, () => {
                  if (options.throwOnTimeout === void 0 ? __classPrivateFieldGet2(this, _PQueue_throwOnTimeout, "f") : options.throwOnTimeout) {
                    reject(timeoutError);
                  }
                  return void 0;
                });
                const result = await operation;
                resolve5(result);
                this.emit("completed", result);
              } catch (error) {
                reject(error);
                this.emit("error", error);
              }
              __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_next).call(this);
            };
            __classPrivateFieldGet2(this, _PQueue_queue, "f").enqueue(run, options);
            __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
            this.emit("add");
          });
        }
        async addAll(functions, options) {
          return Promise.all(functions.map(async (function_) => this.add(function_, options)));
        }
        start() {
          if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
            return this;
          }
          __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
          return this;
        }
        pause() {
          __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
        }
        clear() {
          __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet2(this, _PQueue_queueClass, "f"))(), "f");
        }
        async onEmpty() {
          if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
            return;
          }
          await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
        }
        async onSizeLessThan(limit) {
          if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit) {
            return;
          }
          await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit);
        }
        async onIdle() {
          if (__classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
            return;
          }
          await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
        }
        get size() {
          return __classPrivateFieldGet2(this, _PQueue_queue, "f").size;
        }
        sizeBy(options) {
          return __classPrivateFieldGet2(this, _PQueue_queue, "f").filter(options).length;
        }
        get pending() {
          return __classPrivateFieldGet2(this, _PQueue_pendingCount, "f");
        }
        get isPaused() {
          return __classPrivateFieldGet2(this, _PQueue_isPaused, "f");
        }
      };
      _PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pendingCount = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
        return __classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet2(this, _PQueue_intervalCap, "f");
      }, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
        return __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") < __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
      }, _PQueue_next = function _PQueue_next2() {
        var _a;
        __classPrivateFieldSet(this, _PQueue_pendingCount, (_a = __classPrivateFieldGet2(this, _PQueue_pendingCount, "f"), _a--, _a), "f");
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
        this.emit("next");
      }, _PQueue_emitEvents = function _PQueue_emitEvents2() {
        this.emit("empty");
        if (__classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0) {
          this.emit("idle");
        }
      }, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
        __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
      }, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
        const now = Date.now();
        if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f") === void 0) {
          const delay = __classPrivateFieldGet2(this, _PQueue_intervalEnd, "f") - now;
          if (delay < 0) {
            __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") : 0, "f");
          } else {
            if (__classPrivateFieldGet2(this, _PQueue_timeoutId, "f") === void 0) {
              __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
                __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
              }, delay), "f");
            }
            return true;
          }
        }
        return false;
      }, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
        if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
          if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
            clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
          }
          __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_emitEvents).call(this);
          return false;
        }
        if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
          const canInitializeInterval = !__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
          if (__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
            const job = __classPrivateFieldGet2(this, _PQueue_queue, "f").dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
            }
            return true;
          }
        }
        return false;
      }, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
        if (__classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalId, "f") !== void 0) {
          return;
        }
        __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
        }, __classPrivateFieldGet2(this, _PQueue_interval, "f")), "f");
        __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet2(this, _PQueue_interval, "f"), "f");
      }, _PQueue_onInterval = function _PQueue_onInterval2() {
        if (__classPrivateFieldGet2(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
          clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
          __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
        }
        __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") : 0, "f");
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
      }, _PQueue_processQueue = function _PQueue_processQueue2() {
        while (__classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
        }
      }, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter) {
        return new Promise((resolve5) => {
          const listener = () => {
            if (filter && !filter()) {
              return;
            }
            this.off(event, listener);
            resolve5();
          };
          this.on(event, listener);
        });
      };
    }
  });

  // node_modules/search-index/src/main.js
  var require_main2 = __commonJS({
    "node_modules/search-index/src/main.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var fii = require_browser3();
      var tp = require_tokenisationPipeline();
      var LRU = require_lru_cache();
      var reader = require_read2();
      var writer = require_write2();
      var packageJSON = require_package();
      var makeASearchIndex = (ops) => new Promise(async (resolve5) => {
        const cache2 = new LRU({
          max: 1e3
        });
        const queue3 = new (await Promise.resolve().then(() => (init_dist(), dist_exports))).default({ concurrency: 1 });
        const w2 = writer(ops, cache2, queue3);
        const r2 = reader(ops, cache2);
        return w2._INCREMENT_DOC_COUNT(0).then(
          () => resolve5({
            _AND: ops.fii.AND,
            _BUCKET: ops.fii.BUCKET,
            _GET: ops.fii.GET,
            _NOT: ops.fii.NOT,
            _OR: ops.fii.OR,
            _CACHE: cache2,
            _PAGE: r2.PAGE,
            _SCORE: r2.SCORE,
            _SEARCH: r2.SEARCH,
            _SORT: r2.SORT,
            DELETE: w2.DELETE,
            FLUSH: w2.FLUSH,
            IMPORT: w2.IMPORT,
            PUT: w2.PUT,
            PUT_RAW: w2.PUT_RAW,
            TOKENIZATION_PIPELINE_STAGES: tp,
            ALL_DOCUMENTS: r2.ALL_DOCUMENTS,
            BUCKETS: ops.fii.BUCKETS,
            CREATED: ops.fii.CREATED,
            DICTIONARY: r2.DICTIONARY,
            DISTINCT: r2.DISTINCT,
            DOCUMENTS: r2.DOCUMENTS,
            DOCUMENT_COUNT: r2.DOCUMENT_COUNT,
            EXPORT: ops.fii.EXPORT,
            FACETS: r2.FACETS,
            FIELDS: ops.fii.FIELDS,
            INDEX: ops.fii,
            LAST_UPDATED: ops.fii.LAST_UPDATED,
            MAX: ops.fii.MAX,
            MIN: ops.fii.MIN,
            QUERY: r2.QUERY,
            SEARCH: r2.SEARCH
          })
        );
      });
      var initIndex = (ops = {}) => new Promise((resolve5, reject) => {
        ops = Object.assign(
          {
            cacheLength: 1e3,
            caseSensitive: false,
            docExistsSpace: "DOC_RAW",
            idGenerator: function* generateId() {
              let i2 = 0;
              while (true) {
                yield Date.now() + "-" + i2++;
              }
            }(),
            skipFields: [],
            ngrams: {},
            replace: {},
            storeRawDocs: true,
            stopwords: [],
            storeVectors: true,
            tokenAppend: "#",
            tokenSplitRegex: /[\p{L}\d]+/gu,
            tokenizer: tp.tokenizer
          },
          ops
        );
        return fii(ops).then(
          (aNewFii) => resolve5(
            Object.assign(
              {
                fii: aNewFii
              },
              ops
            )
          )
        );
      });
      var validateVersion = (si) => new Promise((resolve5, reject) => {
        const key = ["CREATED_WITH"];
        const version8 = "search-index@" + packageJSON.version;
        return si.INDEX.STORE.get(key).then(
          (v2) => version8 === v2 ? resolve5() : reject(
            new Error(
              "This index was created with " + v2 + ", you are running " + version8
            )
          )
        ).catch((e2) => si.INDEX.STORE.put(key, version8).then(resolve5));
      });
      module2.exports = (ops) => initIndex(ops).then(makeASearchIndex).then((si) => validateVersion(si).then(() => si));
    }
  });

  // node_modules/search-index/src/browser.js
  var require_browser4 = __commonJS({
    "node_modules/search-index/src/browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var si = require_main2();
      var leveldown = require_level_js();
      module2.exports = (ops) => si(
        Object.assign(
          {
            db: leveldown
          },
          ops
        )
      );
    }
  });

  // node_modules/jsbi/dist/jsbi-umd.js
  var require_jsbi_umd = __commonJS({
    "node_modules/jsbi/dist/jsbi-umd.js"(exports2, module2) {
      init_virtual_process_polyfill();
      (function(e2, t2) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e2 = e2 || self, e2.JSBI = t2());
      })(exports2, function() {
        "use strict";
        var e2 = Math.imul, t2 = Math.clz32;
        function i2(e3) {
          "@babel/helpers - typeof";
          return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, i2(e3);
        }
        function _3(e3, t3) {
          if (!(e3 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        }
        function n2(e3, t3) {
          for (var _4, n3 = 0; n3 < t3.length; n3++)
            _4 = t3[n3], _4.enumerable = _4.enumerable || false, _4.configurable = true, "value" in _4 && (_4.writable = true), Object.defineProperty(e3, _4.key, _4);
        }
        function l2(e3, t3, i3) {
          return t3 && n2(e3.prototype, t3), i3 && n2(e3, i3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
        }
        function g2(e3, t3) {
          if ("function" != typeof t3 && null !== t3)
            throw new TypeError("Super expression must either be null or a function");
          e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && u2(e3, t3);
        }
        function a2(e3) {
          return a2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, a2(e3);
        }
        function u2(e3, t3) {
          return u2 = Object.setPrototypeOf || function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, u2(e3, t3);
        }
        function s2() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }
        function r2() {
          return r2 = s2() ? Reflect.construct : function(e3, t3, i3) {
            var _4 = [null];
            _4.push.apply(_4, t3);
            var n3 = Function.bind.apply(e3, _4), l3 = new n3();
            return i3 && u2(l3, i3.prototype), l3;
          }, r2.apply(null, arguments);
        }
        function d2(e3) {
          return -1 !== Function.toString.call(e3).indexOf("[native code]");
        }
        function h2(e3) {
          var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return h2 = function(e4) {
            function i3() {
              return r2(e4, arguments, a2(this).constructor);
            }
            if (null === e4 || !d2(e4))
              return e4;
            if ("function" != typeof e4)
              throw new TypeError("Super expression must either be null or a function");
            if ("undefined" != typeof t3) {
              if (t3.has(e4))
                return t3.get(e4);
              t3.set(e4, i3);
            }
            return i3.prototype = Object.create(e4.prototype, { constructor: { value: i3, enumerable: false, writable: true, configurable: true } }), u2(i3, e4);
          }, h2(e3);
        }
        function b2(e3) {
          if (void 0 === e3)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e3;
        }
        function m2(e3, t3) {
          if (t3 && ("object" == typeof t3 || "function" == typeof t3))
            return t3;
          if (void 0 !== t3)
            throw new TypeError("Derived constructors may only return object or undefined");
          return b2(e3);
        }
        function c2(e3) {
          var t3 = s2();
          return function() {
            var i3, _4 = a2(e3);
            if (t3) {
              var n3 = a2(this).constructor;
              i3 = Reflect.construct(_4, arguments, n3);
            } else
              i3 = _4.apply(this, arguments);
            return m2(this, i3);
          };
        }
        function v2(e3, t3) {
          return y2(e3) || f2(e3, t3) || D2(e3, t3) || k2();
        }
        function y2(e3) {
          if (Array.isArray(e3))
            return e3;
        }
        function f2(e3, t3) {
          var i3 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (null != i3) {
            var _4, n3, l3 = [], g3 = true, o2 = false;
            try {
              for (i3 = i3.call(e3); !(g3 = (_4 = i3.next()).done) && (l3.push(_4.value), !(t3 && l3.length === t3)); g3 = true)
                ;
            } catch (e4) {
              o2 = true, n3 = e4;
            } finally {
              try {
                g3 || null == i3["return"] || i3["return"]();
              } finally {
                if (o2)
                  throw n3;
              }
            }
            return l3;
          }
        }
        function D2(e3, t3) {
          if (e3) {
            if ("string" == typeof e3)
              return p2(e3, t3);
            var i3 = Object.prototype.toString.call(e3).slice(8, -1);
            return "Object" === i3 && e3.constructor && (i3 = e3.constructor.name), "Map" === i3 || "Set" === i3 ? Array.from(e3) : "Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? p2(e3, t3) : void 0;
          }
        }
        function p2(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var _4 = 0, n3 = Array(t3); _4 < t3; _4++)
            n3[_4] = e3[_4];
          return n3;
        }
        function k2() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function B2(e3, t3) {
          var _4 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (!_4) {
            if (Array.isArray(e3) || (_4 = D2(e3)) || t3 && e3 && "number" == typeof e3.length) {
              _4 && (e3 = _4);
              var n3 = 0, l3 = function() {
              };
              return { s: l3, n: function() {
                return n3 >= e3.length ? { done: true } : { done: false, value: e3[n3++] };
              }, e: function(t4) {
                throw t4;
              }, f: l3 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var g3, a3 = true, u3 = false;
          return { s: function() {
            _4 = _4.call(e3);
          }, n: function() {
            var e4 = _4.next();
            return a3 = e4.done, e4;
          }, e: function(t4) {
            u3 = true, g3 = t4;
          }, f: function() {
            try {
              a3 || null == _4.return || _4.return();
            } finally {
              if (u3)
                throw g3;
            }
          } };
        }
        var S2 = function(e3) {
          var t3 = Math.abs, n3 = Math.max, o2 = Math.floor;
          function a3(e4, t4) {
            var i3;
            if (_3(this, a3), i3 = u3.call(this, e4), i3.sign = t4, Object.setPrototypeOf(b2(i3), a3.prototype), e4 > a3.__kMaxLength)
              throw new RangeError("Maximum BigInt size exceeded");
            return i3;
          }
          g2(a3, e3);
          var u3 = c2(a3);
          return l2(a3, [{ key: "toDebugString", value: function() {
            var e4, t4 = ["BigInt["], i3 = B2(this);
            try {
              for (i3.s(); !(e4 = i3.n()).done; ) {
                var _4 = e4.value;
                t4.push((_4 ? (_4 >>> 0).toString(16) : _4) + ", ");
              }
            } catch (e5) {
              i3.e(e5);
            } finally {
              i3.f();
            }
            return t4.push("]"), t4.join("");
          } }, { key: "toString", value: function() {
            var e4 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10;
            if (2 > e4 || 36 < e4)
              throw new RangeError("toString() radix argument must be between 2 and 36");
            return 0 === this.length ? "0" : 0 == (e4 & e4 - 1) ? a3.__toStringBasePowerOfTwo(this, e4) : a3.__toStringGeneric(this, e4, false);
          } }, { key: "valueOf", value: function() {
            throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
          } }, { key: "__copy", value: function() {
            for (var e4 = new a3(this.length, this.sign), t4 = 0; t4 < this.length; t4++)
              e4[t4] = this[t4];
            return e4;
          } }, { key: "__trim", value: function() {
            for (var e4 = this.length, t4 = this[e4 - 1]; 0 === t4; )
              e4--, t4 = this[e4 - 1], this.pop();
            return 0 === e4 && (this.sign = false), this;
          } }, { key: "__initializeDigits", value: function() {
            for (var e4 = 0; e4 < this.length; e4++)
              this[e4] = 0;
          } }, { key: "__clzmsd", value: function() {
            return a3.__clz30(this.__digit(this.length - 1));
          } }, { key: "__inplaceMultiplyAdd", value: function(e4, t4, _4) {
            _4 > this.length && (_4 = this.length);
            for (var n4 = 32767 & e4, l3 = e4 >>> 15, g3 = 0, o3 = t4, u4 = 0; u4 < _4; u4++) {
              var s3 = this.__digit(u4), r3 = 32767 & s3, d3 = s3 >>> 15, h3 = a3.__imul(r3, n4), b3 = a3.__imul(r3, l3), m3 = a3.__imul(d3, n4), c3 = a3.__imul(d3, l3), v3 = o3 + h3 + g3;
              g3 = v3 >>> 30, v3 &= 1073741823, v3 += ((32767 & b3) << 15) + ((32767 & m3) << 15), g3 += v3 >>> 30, o3 = c3 + (b3 >>> 15) + (m3 >>> 15), this.__setDigit(u4, 1073741823 & v3);
            }
            if (0 !== g3 || 0 !== o3)
              throw new Error("implementation bug");
          } }, { key: "__inplaceAdd", value: function(e4, t4, _4) {
            for (var n4, l3 = 0, g3 = 0; g3 < _4; g3++)
              n4 = this.__halfDigit(t4 + g3) + e4.__halfDigit(g3) + l3, l3 = n4 >>> 15, this.__setHalfDigit(t4 + g3, 32767 & n4);
            return l3;
          } }, { key: "__inplaceSub", value: function(e4, t4, _4) {
            var n4 = 0;
            if (1 & t4) {
              t4 >>= 1;
              for (var l3 = this.__digit(t4), g3 = 32767 & l3, o3 = 0; o3 < _4 - 1 >>> 1; o3++) {
                var a4 = e4.__digit(o3), u4 = (l3 >>> 15) - (32767 & a4) - n4;
                n4 = 1 & u4 >>> 15, this.__setDigit(t4 + o3, (32767 & u4) << 15 | 32767 & g3), l3 = this.__digit(t4 + o3 + 1), g3 = (32767 & l3) - (a4 >>> 15) - n4, n4 = 1 & g3 >>> 15;
              }
              var s3 = e4.__digit(o3), r3 = (l3 >>> 15) - (32767 & s3) - n4;
              n4 = 1 & r3 >>> 15, this.__setDigit(t4 + o3, (32767 & r3) << 15 | 32767 & g3);
              if (t4 + o3 + 1 >= this.length)
                throw new RangeError("out of bounds");
              0 == (1 & _4) && (l3 = this.__digit(t4 + o3 + 1), g3 = (32767 & l3) - (s3 >>> 15) - n4, n4 = 1 & g3 >>> 15, this.__setDigit(t4 + e4.length, 1073709056 & l3 | 32767 & g3));
            } else {
              t4 >>= 1;
              for (var d3 = 0; d3 < e4.length - 1; d3++) {
                var h3 = this.__digit(t4 + d3), b3 = e4.__digit(d3), m3 = (32767 & h3) - (32767 & b3) - n4;
                n4 = 1 & m3 >>> 15;
                var c3 = (h3 >>> 15) - (b3 >>> 15) - n4;
                n4 = 1 & c3 >>> 15, this.__setDigit(t4 + d3, (32767 & c3) << 15 | 32767 & m3);
              }
              var v3 = this.__digit(t4 + d3), y3 = e4.__digit(d3), f3 = (32767 & v3) - (32767 & y3) - n4;
              n4 = 1 & f3 >>> 15;
              var D3 = 0;
              0 == (1 & _4) && (D3 = (v3 >>> 15) - (y3 >>> 15) - n4, n4 = 1 & D3 >>> 15), this.__setDigit(t4 + d3, (32767 & D3) << 15 | 32767 & f3);
            }
            return n4;
          } }, { key: "__inplaceRightShift", value: function(e4) {
            if (0 !== e4) {
              for (var t4, _4 = this.__digit(0) >>> e4, n4 = this.length - 1, l3 = 0; l3 < n4; l3++)
                t4 = this.__digit(l3 + 1), this.__setDigit(l3, 1073741823 & t4 << 30 - e4 | _4), _4 = t4 >>> e4;
              this.__setDigit(n4, _4);
            }
          } }, { key: "__digit", value: function(e4) {
            return this[e4];
          } }, { key: "__unsignedDigit", value: function(e4) {
            return this[e4] >>> 0;
          } }, { key: "__setDigit", value: function(e4, t4) {
            this[e4] = 0 | t4;
          } }, { key: "__setDigitGrow", value: function(e4, t4) {
            this[e4] = 0 | t4;
          } }, { key: "__halfDigitLength", value: function() {
            var e4 = this.length;
            return 32767 >= this.__unsignedDigit(e4 - 1) ? 2 * e4 - 1 : 2 * e4;
          } }, { key: "__halfDigit", value: function(e4) {
            return 32767 & this[e4 >>> 1] >>> 15 * (1 & e4);
          } }, { key: "__setHalfDigit", value: function(e4, t4) {
            var i3 = e4 >>> 1, _4 = this.__digit(i3), n4 = 1 & e4 ? 32767 & _4 | t4 << 15 : 1073709056 & _4 | 32767 & t4;
            this.__setDigit(i3, n4);
          } }], [{ key: "BigInt", value: function(e4) {
            var t4 = Number.isFinite;
            if ("number" == typeof e4) {
              if (0 === e4)
                return a3.__zero();
              if (a3.__isOneDigitInt(e4))
                return 0 > e4 ? a3.__oneDigit(-e4, true) : a3.__oneDigit(e4, false);
              if (!t4(e4) || o2(e4) !== e4)
                throw new RangeError("The number " + e4 + " cannot be converted to BigInt because it is not an integer");
              return a3.__fromDouble(e4);
            }
            if ("string" == typeof e4) {
              var _4 = a3.__fromString(e4);
              if (null === _4)
                throw new SyntaxError("Cannot convert " + e4 + " to a BigInt");
              return _4;
            }
            if ("boolean" == typeof e4)
              return true === e4 ? a3.__oneDigit(1, false) : a3.__zero();
            if ("object" === i2(e4)) {
              if (e4.constructor === a3)
                return e4;
              var n4 = a3.__toPrimitive(e4);
              return a3.BigInt(n4);
            }
            throw new TypeError("Cannot convert " + e4 + " to a BigInt");
          } }, { key: "toNumber", value: function(e4) {
            var t4 = e4.length;
            if (0 === t4)
              return 0;
            if (1 === t4) {
              var i3 = e4.__unsignedDigit(0);
              return e4.sign ? -i3 : i3;
            }
            var _4 = e4.__digit(t4 - 1), n4 = a3.__clz30(_4), l3 = 30 * t4 - n4;
            if (1024 < l3)
              return e4.sign ? -Infinity : 1 / 0;
            var g3 = l3 - 1, o3 = _4, u4 = t4 - 1, s3 = n4 + 3, r3 = 32 === s3 ? 0 : o3 << s3;
            r3 >>>= 12;
            var d3 = s3 - 12, h3 = 12 <= s3 ? 0 : o3 << 20 + s3, b3 = 20 + s3;
            for (0 < d3 && 0 < u4 && (u4--, o3 = e4.__digit(u4), r3 |= o3 >>> 30 - d3, h3 = o3 << d3 + 2, b3 = d3 + 2); 0 < b3 && 0 < u4; )
              u4--, o3 = e4.__digit(u4), h3 |= 30 <= b3 ? o3 << b3 - 30 : o3 >>> 30 - b3, b3 -= 30;
            var m3 = a3.__decideRounding(e4, b3, u4, o3);
            if ((1 === m3 || 0 === m3 && 1 == (1 & h3)) && (h3 = h3 + 1 >>> 0, 0 === h3 && (r3++, 0 != r3 >>> 20 && (r3 = 0, g3++, 1023 < g3))))
              return e4.sign ? -Infinity : 1 / 0;
            var c3 = e4.sign ? -2147483648 : 0;
            return g3 = g3 + 1023 << 20, a3.__kBitConversionInts[1] = c3 | g3 | r3, a3.__kBitConversionInts[0] = h3, a3.__kBitConversionDouble[0];
          } }, { key: "unaryMinus", value: function(e4) {
            if (0 === e4.length)
              return e4;
            var t4 = e4.__copy();
            return t4.sign = !e4.sign, t4;
          } }, { key: "bitwiseNot", value: function(e4) {
            return e4.sign ? a3.__absoluteSubOne(e4).__trim() : a3.__absoluteAddOne(e4, true);
          } }, { key: "exponentiate", value: function(e4, t4) {
            if (t4.sign)
              throw new RangeError("Exponent must be positive");
            if (0 === t4.length)
              return a3.__oneDigit(1, false);
            if (0 === e4.length)
              return e4;
            if (1 === e4.length && 1 === e4.__digit(0))
              return e4.sign && 0 == (1 & t4.__digit(0)) ? a3.unaryMinus(e4) : e4;
            if (1 < t4.length)
              throw new RangeError("BigInt too big");
            var i3 = t4.__unsignedDigit(0);
            if (1 === i3)
              return e4;
            if (i3 >= a3.__kMaxLengthBits)
              throw new RangeError("BigInt too big");
            if (1 === e4.length && 2 === e4.__digit(0)) {
              var _4 = 1 + (0 | i3 / 30), n4 = e4.sign && 0 != (1 & i3), l3 = new a3(_4, n4);
              l3.__initializeDigits();
              var g3 = 1 << i3 % 30;
              return l3.__setDigit(_4 - 1, g3), l3;
            }
            var o3 = null, u4 = e4;
            for (0 != (1 & i3) && (o3 = e4), i3 >>= 1; 0 !== i3; i3 >>= 1)
              u4 = a3.multiply(u4, u4), 0 != (1 & i3) && (null === o3 ? o3 = u4 : o3 = a3.multiply(o3, u4));
            return o3;
          } }, { key: "multiply", value: function(e4, t4) {
            if (0 === e4.length)
              return e4;
            if (0 === t4.length)
              return t4;
            var _4 = e4.length + t4.length;
            30 <= e4.__clzmsd() + t4.__clzmsd() && _4--;
            var n4 = new a3(_4, e4.sign !== t4.sign);
            n4.__initializeDigits();
            for (var l3 = 0; l3 < e4.length; l3++)
              a3.__multiplyAccumulate(t4, e4.__digit(l3), n4, l3);
            return n4.__trim();
          } }, { key: "divide", value: function(e4, t4) {
            if (0 === t4.length)
              throw new RangeError("Division by zero");
            if (0 > a3.__absoluteCompare(e4, t4))
              return a3.__zero();
            var i3, _4 = e4.sign !== t4.sign, n4 = t4.__unsignedDigit(0);
            if (1 === t4.length && 32767 >= n4) {
              if (1 === n4)
                return _4 === e4.sign ? e4 : a3.unaryMinus(e4);
              i3 = a3.__absoluteDivSmall(e4, n4, null);
            } else
              i3 = a3.__absoluteDivLarge(e4, t4, true, false);
            return i3.sign = _4, i3.__trim();
          } }, { key: "remainder", value: function i3(e4, t4) {
            if (0 === t4.length)
              throw new RangeError("Division by zero");
            if (0 > a3.__absoluteCompare(e4, t4))
              return e4;
            var _4 = t4.__unsignedDigit(0);
            if (1 === t4.length && 32767 >= _4) {
              if (1 === _4)
                return a3.__zero();
              var n4 = a3.__absoluteModSmall(e4, _4);
              return 0 === n4 ? a3.__zero() : a3.__oneDigit(n4, e4.sign);
            }
            var i4 = a3.__absoluteDivLarge(e4, t4, false, true);
            return i4.sign = e4.sign, i4.__trim();
          } }, { key: "add", value: function(e4, t4) {
            var i3 = e4.sign;
            return i3 === t4.sign ? a3.__absoluteAdd(e4, t4, i3) : 0 <= a3.__absoluteCompare(e4, t4) ? a3.__absoluteSub(e4, t4, i3) : a3.__absoluteSub(t4, e4, !i3);
          } }, { key: "subtract", value: function(e4, t4) {
            var i3 = e4.sign;
            return i3 === t4.sign ? 0 <= a3.__absoluteCompare(e4, t4) ? a3.__absoluteSub(e4, t4, i3) : a3.__absoluteSub(t4, e4, !i3) : a3.__absoluteAdd(e4, t4, i3);
          } }, { key: "leftShift", value: function(e4, t4) {
            return 0 === t4.length || 0 === e4.length ? e4 : t4.sign ? a3.__rightShiftByAbsolute(e4, t4) : a3.__leftShiftByAbsolute(e4, t4);
          } }, { key: "signedRightShift", value: function(e4, t4) {
            return 0 === t4.length || 0 === e4.length ? e4 : t4.sign ? a3.__leftShiftByAbsolute(e4, t4) : a3.__rightShiftByAbsolute(e4, t4);
          } }, { key: "unsignedRightShift", value: function() {
            throw new TypeError("BigInts have no unsigned right shift; use >> instead");
          } }, { key: "lessThan", value: function(e4, t4) {
            return 0 > a3.__compareToBigInt(e4, t4);
          } }, { key: "lessThanOrEqual", value: function(e4, t4) {
            return 0 >= a3.__compareToBigInt(e4, t4);
          } }, { key: "greaterThan", value: function(e4, t4) {
            return 0 < a3.__compareToBigInt(e4, t4);
          } }, { key: "greaterThanOrEqual", value: function(e4, t4) {
            return 0 <= a3.__compareToBigInt(e4, t4);
          } }, { key: "equal", value: function(e4, t4) {
            if (e4.sign !== t4.sign)
              return false;
            if (e4.length !== t4.length)
              return false;
            for (var _4 = 0; _4 < e4.length; _4++)
              if (e4.__digit(_4) !== t4.__digit(_4))
                return false;
            return true;
          } }, { key: "notEqual", value: function(e4, t4) {
            return !a3.equal(e4, t4);
          } }, { key: "bitwiseAnd", value: function(e4, t4) {
            if (!e4.sign && !t4.sign)
              return a3.__absoluteAnd(e4, t4).__trim();
            if (e4.sign && t4.sign) {
              var i3 = n3(e4.length, t4.length) + 1, _4 = a3.__absoluteSubOne(e4, i3), l3 = a3.__absoluteSubOne(t4);
              return _4 = a3.__absoluteOr(_4, l3, _4), a3.__absoluteAddOne(_4, true, _4).__trim();
            }
            if (e4.sign) {
              var g3 = [t4, e4];
              e4 = g3[0], t4 = g3[1];
            }
            return a3.__absoluteAndNot(e4, a3.__absoluteSubOne(t4)).__trim();
          } }, { key: "bitwiseXor", value: function(e4, t4) {
            if (!e4.sign && !t4.sign)
              return a3.__absoluteXor(e4, t4).__trim();
            if (e4.sign && t4.sign) {
              var i3 = n3(e4.length, t4.length), _4 = a3.__absoluteSubOne(e4, i3), l3 = a3.__absoluteSubOne(t4);
              return a3.__absoluteXor(_4, l3, _4).__trim();
            }
            var g3 = n3(e4.length, t4.length) + 1;
            if (e4.sign) {
              var o3 = [t4, e4];
              e4 = o3[0], t4 = o3[1];
            }
            var u4 = a3.__absoluteSubOne(t4, g3);
            return u4 = a3.__absoluteXor(u4, e4, u4), a3.__absoluteAddOne(u4, true, u4).__trim();
          } }, { key: "bitwiseOr", value: function(e4, t4) {
            var i3 = n3(e4.length, t4.length);
            if (!e4.sign && !t4.sign)
              return a3.__absoluteOr(e4, t4).__trim();
            if (e4.sign && t4.sign) {
              var _4 = a3.__absoluteSubOne(e4, i3), l3 = a3.__absoluteSubOne(t4);
              return _4 = a3.__absoluteAnd(_4, l3, _4), a3.__absoluteAddOne(_4, true, _4).__trim();
            }
            if (e4.sign) {
              var g3 = [t4, e4];
              e4 = g3[0], t4 = g3[1];
            }
            var o3 = a3.__absoluteSubOne(t4, i3);
            return o3 = a3.__absoluteAndNot(o3, e4, o3), a3.__absoluteAddOne(o3, true, o3).__trim();
          } }, { key: "asIntN", value: function(e4, t4) {
            if (0 === t4.length)
              return t4;
            if (e4 = o2(e4), 0 > e4)
              throw new RangeError("Invalid value: not (convertible to) a safe integer");
            if (0 === e4)
              return a3.__zero();
            if (e4 >= a3.__kMaxLengthBits)
              return t4;
            var _4 = 0 | (e4 + 29) / 30;
            if (t4.length < _4)
              return t4;
            var l3 = t4.__unsignedDigit(_4 - 1), g3 = 1 << (e4 - 1) % 30;
            if (t4.length === _4 && l3 < g3)
              return t4;
            if (!((l3 & g3) === g3))
              return a3.__truncateToNBits(e4, t4);
            if (!t4.sign)
              return a3.__truncateAndSubFromPowerOfTwo(e4, t4, true);
            if (0 == (l3 & g3 - 1)) {
              for (var u4 = _4 - 2; 0 <= u4; u4--)
                if (0 !== t4.__digit(u4))
                  return a3.__truncateAndSubFromPowerOfTwo(e4, t4, false);
              return t4.length === _4 && l3 === g3 ? t4 : a3.__truncateToNBits(e4, t4);
            }
            return a3.__truncateAndSubFromPowerOfTwo(e4, t4, false);
          } }, { key: "asUintN", value: function(e4, t4) {
            if (0 === t4.length)
              return t4;
            if (e4 = o2(e4), 0 > e4)
              throw new RangeError("Invalid value: not (convertible to) a safe integer");
            if (0 === e4)
              return a3.__zero();
            if (t4.sign) {
              if (e4 > a3.__kMaxLengthBits)
                throw new RangeError("BigInt too big");
              return a3.__truncateAndSubFromPowerOfTwo(e4, t4, false);
            }
            if (e4 >= a3.__kMaxLengthBits)
              return t4;
            var i3 = 0 | (e4 + 29) / 30;
            if (t4.length < i3)
              return t4;
            var _4 = e4 % 30;
            if (t4.length == i3) {
              if (0 === _4)
                return t4;
              var l3 = t4.__digit(i3 - 1);
              if (0 == l3 >>> _4)
                return t4;
            }
            return a3.__truncateToNBits(e4, t4);
          } }, { key: "ADD", value: function(e4, t4) {
            if (e4 = a3.__toPrimitive(e4), t4 = a3.__toPrimitive(t4), "string" == typeof e4)
              return "string" != typeof t4 && (t4 = t4.toString()), e4 + t4;
            if ("string" == typeof t4)
              return e4.toString() + t4;
            if (e4 = a3.__toNumeric(e4), t4 = a3.__toNumeric(t4), a3.__isBigInt(e4) && a3.__isBigInt(t4))
              return a3.add(e4, t4);
            if ("number" == typeof e4 && "number" == typeof t4)
              return e4 + t4;
            throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
          } }, { key: "LT", value: function(e4, t4) {
            return a3.__compare(e4, t4, 0);
          } }, { key: "LE", value: function(e4, t4) {
            return a3.__compare(e4, t4, 1);
          } }, { key: "GT", value: function(e4, t4) {
            return a3.__compare(e4, t4, 2);
          } }, { key: "GE", value: function(e4, t4) {
            return a3.__compare(e4, t4, 3);
          } }, { key: "EQ", value: function(e4, t4) {
            for (; ; ) {
              if (a3.__isBigInt(e4))
                return a3.__isBigInt(t4) ? a3.equal(e4, t4) : a3.EQ(t4, e4);
              if ("number" == typeof e4) {
                if (a3.__isBigInt(t4))
                  return a3.__equalToNumber(t4, e4);
                if ("object" !== i2(t4))
                  return e4 == t4;
                t4 = a3.__toPrimitive(t4);
              } else if ("string" == typeof e4) {
                if (a3.__isBigInt(t4))
                  return e4 = a3.__fromString(e4), null !== e4 && a3.equal(e4, t4);
                if ("object" !== i2(t4))
                  return e4 == t4;
                t4 = a3.__toPrimitive(t4);
              } else if ("boolean" == typeof e4) {
                if (a3.__isBigInt(t4))
                  return a3.__equalToNumber(t4, +e4);
                if ("object" !== i2(t4))
                  return e4 == t4;
                t4 = a3.__toPrimitive(t4);
              } else if ("symbol" === i2(e4)) {
                if (a3.__isBigInt(t4))
                  return false;
                if ("object" !== i2(t4))
                  return e4 == t4;
                t4 = a3.__toPrimitive(t4);
              } else if ("object" === i2(e4)) {
                if ("object" === i2(t4) && t4.constructor !== a3)
                  return e4 == t4;
                e4 = a3.__toPrimitive(e4);
              } else
                return e4 == t4;
            }
          } }, { key: "NE", value: function(e4, t4) {
            return !a3.EQ(e4, t4);
          } }, { key: "DataViewGetBigInt64", value: function(e4, t4) {
            var i3 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2];
            return a3.asIntN(64, a3.DataViewGetBigUint64(e4, t4, i3));
          } }, { key: "DataViewGetBigUint64", value: function(e4, t4) {
            var i3 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2], _4 = i3 ? [4, 0] : [0, 4], n4 = v2(_4, 2), g3 = n4[0], o3 = n4[1], l3 = e4.getUint32(t4 + g3, i3), u4 = e4.getUint32(t4 + o3, i3), s3 = new a3(3, false);
            return s3.__setDigit(0, 1073741823 & u4), s3.__setDigit(1, (268435455 & l3) << 2 | u4 >>> 30), s3.__setDigit(2, l3 >>> 28), s3.__trim();
          } }, { key: "DataViewSetBigInt64", value: function(e4, t4, i3) {
            var _4 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3];
            a3.DataViewSetBigUint64(e4, t4, i3, _4);
          } }, { key: "DataViewSetBigUint64", value: function(e4, t4, i3) {
            var _4 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3];
            i3 = a3.asUintN(64, i3);
            var n4 = 0, g3 = 0;
            if (0 < i3.length && (g3 = i3.__digit(0), 1 < i3.length)) {
              var o3 = i3.__digit(1);
              g3 |= o3 << 30, n4 = o3 >>> 2, 2 < i3.length && (n4 |= i3.__digit(2) << 28);
            }
            var u4 = _4 ? [4, 0] : [0, 4], s3 = v2(u4, 2), r3 = s3[0], d3 = s3[1];
            e4.setUint32(t4 + r3, n4, _4), e4.setUint32(t4 + d3, g3, _4);
          } }, { key: "__zero", value: function() {
            return new a3(0, false);
          } }, { key: "__oneDigit", value: function(e4, t4) {
            var i3 = new a3(1, t4);
            return i3.__setDigit(0, e4), i3;
          } }, { key: "__decideRounding", value: function(e4, t4, i3, _4) {
            if (0 < t4)
              return -1;
            var n4;
            if (0 > t4)
              n4 = -t4 - 1;
            else {
              if (0 === i3)
                return -1;
              i3--, _4 = e4.__digit(i3), n4 = 29;
            }
            var l3 = 1 << n4;
            if (0 == (_4 & l3))
              return -1;
            if (l3 -= 1, 0 != (_4 & l3))
              return 1;
            for (; 0 < i3; )
              if (i3--, 0 !== e4.__digit(i3))
                return 1;
            return 0;
          } }, { key: "__fromDouble", value: function(e4) {
            a3.__kBitConversionDouble[0] = e4;
            var t4, i3 = 2047 & a3.__kBitConversionInts[1] >>> 20, _4 = i3 - 1023, n4 = (0 | _4 / 30) + 1, l3 = new a3(n4, 0 > e4), g3 = 1048575 & a3.__kBitConversionInts[1] | 1048576, o3 = a3.__kBitConversionInts[0], u4 = 20, s3 = _4 % 30, r3 = 0;
            if (s3 < u4) {
              var d3 = u4 - s3;
              r3 = d3 + 32, t4 = g3 >>> d3, g3 = g3 << 32 - d3 | o3 >>> d3, o3 <<= 32 - d3;
            } else if (s3 === u4)
              r3 = 32, t4 = g3, g3 = o3, o3 = 0;
            else {
              var h3 = s3 - u4;
              r3 = 32 - h3, t4 = g3 << h3 | o3 >>> 32 - h3, g3 = o3 << h3, o3 = 0;
            }
            l3.__setDigit(n4 - 1, t4);
            for (var b3 = n4 - 2; 0 <= b3; b3--)
              0 < r3 ? (r3 -= 30, t4 = g3 >>> 2, g3 = g3 << 30 | o3 >>> 2, o3 <<= 30) : t4 = 0, l3.__setDigit(b3, t4);
            return l3.__trim();
          } }, { key: "__isWhitespace", value: function(e4) {
            return !!(13 >= e4 && 9 <= e4) || (159 >= e4 ? 32 == e4 : 131071 >= e4 ? 160 == e4 || 5760 == e4 : 196607 >= e4 ? (e4 &= 131071, 10 >= e4 || 40 == e4 || 41 == e4 || 47 == e4 || 95 == e4 || 4096 == e4) : 65279 == e4);
          } }, { key: "__fromString", value: function(e4) {
            var t4 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i3 = 0, _4 = e4.length, n4 = 0;
            if (n4 === _4)
              return a3.__zero();
            for (var l3 = e4.charCodeAt(n4); a3.__isWhitespace(l3); ) {
              if (++n4 === _4)
                return a3.__zero();
              l3 = e4.charCodeAt(n4);
            }
            if (43 === l3) {
              if (++n4 === _4)
                return null;
              l3 = e4.charCodeAt(n4), i3 = 1;
            } else if (45 === l3) {
              if (++n4 === _4)
                return null;
              l3 = e4.charCodeAt(n4), i3 = -1;
            }
            if (0 === t4) {
              if (t4 = 10, 48 === l3) {
                if (++n4 === _4)
                  return a3.__zero();
                if (l3 = e4.charCodeAt(n4), 88 === l3 || 120 === l3) {
                  if (t4 = 16, ++n4 === _4)
                    return null;
                  l3 = e4.charCodeAt(n4);
                } else if (79 === l3 || 111 === l3) {
                  if (t4 = 8, ++n4 === _4)
                    return null;
                  l3 = e4.charCodeAt(n4);
                } else if (66 === l3 || 98 === l3) {
                  if (t4 = 2, ++n4 === _4)
                    return null;
                  l3 = e4.charCodeAt(n4);
                }
              }
            } else if (16 === t4 && 48 === l3) {
              if (++n4 === _4)
                return a3.__zero();
              if (l3 = e4.charCodeAt(n4), 88 === l3 || 120 === l3) {
                if (++n4 === _4)
                  return null;
                l3 = e4.charCodeAt(n4);
              }
            }
            if (0 !== i3 && 10 !== t4)
              return null;
            for (; 48 === l3; ) {
              if (++n4 === _4)
                return a3.__zero();
              l3 = e4.charCodeAt(n4);
            }
            var g3 = _4 - n4, o3 = a3.__kMaxBitsPerChar[t4], u4 = a3.__kBitsPerCharTableMultiplier - 1;
            if (g3 > 1073741824 / o3)
              return null;
            var s3 = o3 * g3 + u4 >>> a3.__kBitsPerCharTableShift, r3 = new a3(0 | (s3 + 29) / 30, false), h3 = 10 > t4 ? t4 : 10, b3 = 10 < t4 ? t4 - 10 : 0;
            if (0 == (t4 & t4 - 1)) {
              o3 >>= a3.__kBitsPerCharTableShift;
              var c3 = [], v3 = [], y3 = false;
              do {
                for (var f3, D3 = 0, p3 = 0; ; ) {
                  if (f3 = void 0, l3 - 48 >>> 0 < h3)
                    f3 = l3 - 48;
                  else if ((32 | l3) - 97 >>> 0 < b3)
                    f3 = (32 | l3) - 87;
                  else {
                    y3 = true;
                    break;
                  }
                  if (p3 += o3, D3 = D3 << o3 | f3, ++n4 === _4) {
                    y3 = true;
                    break;
                  }
                  if (l3 = e4.charCodeAt(n4), 30 < p3 + o3)
                    break;
                }
                c3.push(D3), v3.push(p3);
              } while (!y3);
              a3.__fillFromParts(r3, c3, v3);
            } else {
              r3.__initializeDigits();
              var k3 = false, B3 = 0;
              do {
                for (var S3, C2 = 0, I2 = 1; ; ) {
                  if (S3 = void 0, l3 - 48 >>> 0 < h3)
                    S3 = l3 - 48;
                  else if ((32 | l3) - 97 >>> 0 < b3)
                    S3 = (32 | l3) - 87;
                  else {
                    k3 = true;
                    break;
                  }
                  var A2 = I2 * t4;
                  if (1073741823 < A2)
                    break;
                  if (I2 = A2, C2 = C2 * t4 + S3, B3++, ++n4 === _4) {
                    k3 = true;
                    break;
                  }
                  l3 = e4.charCodeAt(n4);
                }
                u4 = 30 * a3.__kBitsPerCharTableMultiplier - 1;
                var m3 = 0 | (o3 * B3 + u4 >>> a3.__kBitsPerCharTableShift) / 30;
                r3.__inplaceMultiplyAdd(I2, C2, m3);
              } while (!k3);
            }
            if (n4 !== _4) {
              if (!a3.__isWhitespace(l3))
                return null;
              for (n4++; n4 < _4; n4++)
                if (l3 = e4.charCodeAt(n4), !a3.__isWhitespace(l3))
                  return null;
            }
            return r3.sign = -1 === i3, r3.__trim();
          } }, { key: "__fillFromParts", value: function(e4, t4, _4) {
            for (var n4 = 0, l3 = 0, g3 = 0, o3 = t4.length - 1; 0 <= o3; o3--) {
              var a4 = t4[o3], u4 = _4[o3];
              l3 |= a4 << g3, g3 += u4, 30 === g3 ? (e4.__setDigit(n4++, l3), g3 = 0, l3 = 0) : 30 < g3 && (e4.__setDigit(n4++, 1073741823 & l3), g3 -= 30, l3 = a4 >>> u4 - g3);
            }
            if (0 !== l3) {
              if (n4 >= e4.length)
                throw new Error("implementation bug");
              e4.__setDigit(n4++, l3);
            }
            for (; n4 < e4.length; n4++)
              e4.__setDigit(n4, 0);
          } }, { key: "__toStringBasePowerOfTwo", value: function(e4, t4) {
            var _4 = e4.length, n4 = t4 - 1;
            n4 = (85 & n4 >>> 1) + (85 & n4), n4 = (51 & n4 >>> 2) + (51 & n4), n4 = (15 & n4 >>> 4) + (15 & n4);
            var l3 = n4, g3 = t4 - 1, o3 = e4.__digit(_4 - 1), u4 = a3.__clz30(o3), s3 = 0 | (30 * _4 - u4 + l3 - 1) / l3;
            if (e4.sign && s3++, 268435456 < s3)
              throw new Error("string too long");
            for (var r3 = Array(s3), d3 = s3 - 1, h3 = 0, b3 = 0, m3 = 0; m3 < _4 - 1; m3++) {
              var c3 = e4.__digit(m3), v3 = (h3 | c3 << b3) & g3;
              r3[d3--] = a3.__kConversionChars[v3];
              var y3 = l3 - b3;
              for (h3 = c3 >>> y3, b3 = 30 - y3; b3 >= l3; )
                r3[d3--] = a3.__kConversionChars[h3 & g3], h3 >>>= l3, b3 -= l3;
            }
            var f3 = (h3 | o3 << b3) & g3;
            for (r3[d3--] = a3.__kConversionChars[f3], h3 = o3 >>> l3 - b3; 0 !== h3; )
              r3[d3--] = a3.__kConversionChars[h3 & g3], h3 >>>= l3;
            if (e4.sign && (r3[d3--] = "-"), -1 !== d3)
              throw new Error("implementation bug");
            return r3.join("");
          } }, { key: "__toStringGeneric", value: function(e4, t4, _4) {
            var n4 = e4.length;
            if (0 === n4)
              return "";
            if (1 === n4) {
              var l3 = e4.__unsignedDigit(0).toString(t4);
              return false === _4 && e4.sign && (l3 = "-" + l3), l3;
            }
            var g3 = 30 * n4 - a3.__clz30(e4.__digit(n4 - 1)), o3 = a3.__kMaxBitsPerChar[t4], u4 = o3 - 1, s3 = g3 * a3.__kBitsPerCharTableMultiplier;
            s3 += u4 - 1, s3 = 0 | s3 / u4;
            var r3, d3, h3 = s3 + 1 >> 1, b3 = a3.exponentiate(a3.__oneDigit(t4, false), a3.__oneDigit(h3, false)), m3 = b3.__unsignedDigit(0);
            if (1 === b3.length && 32767 >= m3) {
              r3 = new a3(e4.length, false), r3.__initializeDigits();
              for (var c3, v3 = 0, y3 = 2 * e4.length - 1; 0 <= y3; y3--)
                c3 = v3 << 15 | e4.__halfDigit(y3), r3.__setHalfDigit(y3, 0 | c3 / m3), v3 = 0 | c3 % m3;
              d3 = v3.toString(t4);
            } else {
              var f3 = a3.__absoluteDivLarge(e4, b3, true, true);
              r3 = f3.quotient;
              var D3 = f3.remainder.__trim();
              d3 = a3.__toStringGeneric(D3, t4, true);
            }
            r3.__trim();
            for (var p3 = a3.__toStringGeneric(r3, t4, true); d3.length < h3; )
              d3 = "0" + d3;
            return false === _4 && e4.sign && (p3 = "-" + p3), p3 + d3;
          } }, { key: "__unequalSign", value: function(e4) {
            return e4 ? -1 : 1;
          } }, { key: "__absoluteGreater", value: function(e4) {
            return e4 ? -1 : 1;
          } }, { key: "__absoluteLess", value: function(e4) {
            return e4 ? 1 : -1;
          } }, { key: "__compareToBigInt", value: function(e4, t4) {
            var i3 = e4.sign;
            if (i3 !== t4.sign)
              return a3.__unequalSign(i3);
            var _4 = a3.__absoluteCompare(e4, t4);
            return 0 < _4 ? a3.__absoluteGreater(i3) : 0 > _4 ? a3.__absoluteLess(i3) : 0;
          } }, { key: "__compareToNumber", value: function(e4, i3) {
            if (a3.__isOneDigitInt(i3)) {
              var _4 = e4.sign, n4 = 0 > i3;
              if (_4 !== n4)
                return a3.__unequalSign(_4);
              if (0 === e4.length) {
                if (n4)
                  throw new Error("implementation bug");
                return 0 === i3 ? 0 : -1;
              }
              if (1 < e4.length)
                return a3.__absoluteGreater(_4);
              var l3 = t3(i3), g3 = e4.__unsignedDigit(0);
              return g3 > l3 ? a3.__absoluteGreater(_4) : g3 < l3 ? a3.__absoluteLess(_4) : 0;
            }
            return a3.__compareToDouble(e4, i3);
          } }, { key: "__compareToDouble", value: function(e4, t4) {
            if (t4 !== t4)
              return t4;
            if (t4 === 1 / 0)
              return -1;
            if (t4 === -Infinity)
              return 1;
            var i3 = e4.sign;
            if (i3 !== 0 > t4)
              return a3.__unequalSign(i3);
            if (0 === t4)
              throw new Error("implementation bug: should be handled elsewhere");
            if (0 === e4.length)
              return -1;
            a3.__kBitConversionDouble[0] = t4;
            var _4 = 2047 & a3.__kBitConversionInts[1] >>> 20;
            if (2047 == _4)
              throw new Error("implementation bug: handled elsewhere");
            var n4 = _4 - 1023;
            if (0 > n4)
              return a3.__absoluteGreater(i3);
            var l3 = e4.length, g3 = e4.__digit(l3 - 1), o3 = a3.__clz30(g3), u4 = 30 * l3 - o3, s3 = n4 + 1;
            if (u4 < s3)
              return a3.__absoluteLess(i3);
            if (u4 > s3)
              return a3.__absoluteGreater(i3);
            var r3 = 1048576 | 1048575 & a3.__kBitConversionInts[1], d3 = a3.__kBitConversionInts[0], h3 = 20, b3 = 29 - o3;
            if (b3 !== (0 | (u4 - 1) % 30))
              throw new Error("implementation bug");
            var m3, c3 = 0;
            if (b3 < h3) {
              var v3 = h3 - b3;
              c3 = v3 + 32, m3 = r3 >>> v3, r3 = r3 << 32 - v3 | d3 >>> v3, d3 <<= 32 - v3;
            } else if (b3 === h3)
              c3 = 32, m3 = r3, r3 = d3, d3 = 0;
            else {
              var y3 = b3 - h3;
              c3 = 32 - y3, m3 = r3 << y3 | d3 >>> 32 - y3, r3 = d3 << y3, d3 = 0;
            }
            if (g3 >>>= 0, m3 >>>= 0, g3 > m3)
              return a3.__absoluteGreater(i3);
            if (g3 < m3)
              return a3.__absoluteLess(i3);
            for (var f3 = l3 - 2; 0 <= f3; f3--) {
              0 < c3 ? (c3 -= 30, m3 = r3 >>> 2, r3 = r3 << 30 | d3 >>> 2, d3 <<= 30) : m3 = 0;
              var D3 = e4.__unsignedDigit(f3);
              if (D3 > m3)
                return a3.__absoluteGreater(i3);
              if (D3 < m3)
                return a3.__absoluteLess(i3);
            }
            if (0 !== r3 || 0 !== d3) {
              if (0 === c3)
                throw new Error("implementation bug");
              return a3.__absoluteLess(i3);
            }
            return 0;
          } }, { key: "__equalToNumber", value: function(e4, i3) {
            return a3.__isOneDigitInt(i3) ? 0 === i3 ? 0 === e4.length : 1 === e4.length && e4.sign === 0 > i3 && e4.__unsignedDigit(0) === t3(i3) : 0 === a3.__compareToDouble(e4, i3);
          } }, { key: "__comparisonResultToBool", value: function(e4, t4) {
            return 0 === t4 ? 0 > e4 : 1 === t4 ? 0 >= e4 : 2 === t4 ? 0 < e4 : 3 === t4 ? 0 <= e4 : void 0;
          } }, { key: "__compare", value: function(e4, t4, i3) {
            if (e4 = a3.__toPrimitive(e4), t4 = a3.__toPrimitive(t4), "string" == typeof e4 && "string" == typeof t4)
              switch (i3) {
                case 0:
                  return e4 < t4;
                case 1:
                  return e4 <= t4;
                case 2:
                  return e4 > t4;
                case 3:
                  return e4 >= t4;
              }
            if (a3.__isBigInt(e4) && "string" == typeof t4)
              return t4 = a3.__fromString(t4), null !== t4 && a3.__comparisonResultToBool(a3.__compareToBigInt(e4, t4), i3);
            if ("string" == typeof e4 && a3.__isBigInt(t4))
              return e4 = a3.__fromString(e4), null !== e4 && a3.__comparisonResultToBool(a3.__compareToBigInt(e4, t4), i3);
            if (e4 = a3.__toNumeric(e4), t4 = a3.__toNumeric(t4), a3.__isBigInt(e4)) {
              if (a3.__isBigInt(t4))
                return a3.__comparisonResultToBool(a3.__compareToBigInt(e4, t4), i3);
              if ("number" != typeof t4)
                throw new Error("implementation bug");
              return a3.__comparisonResultToBool(a3.__compareToNumber(e4, t4), i3);
            }
            if ("number" != typeof e4)
              throw new Error("implementation bug");
            if (a3.__isBigInt(t4))
              return a3.__comparisonResultToBool(a3.__compareToNumber(t4, e4), 2 ^ i3);
            if ("number" != typeof t4)
              throw new Error("implementation bug");
            return 0 === i3 ? e4 < t4 : 1 === i3 ? e4 <= t4 : 2 === i3 ? e4 > t4 : 3 === i3 ? e4 >= t4 : void 0;
          } }, { key: "__absoluteAdd", value: function(e4, t4, _4) {
            if (e4.length < t4.length)
              return a3.__absoluteAdd(t4, e4, _4);
            if (0 === e4.length)
              return e4;
            if (0 === t4.length)
              return e4.sign === _4 ? e4 : a3.unaryMinus(e4);
            var n4 = e4.length;
            (0 === e4.__clzmsd() || t4.length === e4.length && 0 === t4.__clzmsd()) && n4++;
            for (var l3, g3 = new a3(n4, _4), o3 = 0, u4 = 0; u4 < t4.length; u4++)
              l3 = e4.__digit(u4) + t4.__digit(u4) + o3, o3 = l3 >>> 30, g3.__setDigit(u4, 1073741823 & l3);
            for (; u4 < e4.length; u4++) {
              var s3 = e4.__digit(u4) + o3;
              o3 = s3 >>> 30, g3.__setDigit(u4, 1073741823 & s3);
            }
            return u4 < g3.length && g3.__setDigit(u4, o3), g3.__trim();
          } }, { key: "__absoluteSub", value: function(e4, t4, _4) {
            if (0 === e4.length)
              return e4;
            if (0 === t4.length)
              return e4.sign === _4 ? e4 : a3.unaryMinus(e4);
            for (var n4, l3 = new a3(e4.length, _4), g3 = 0, o3 = 0; o3 < t4.length; o3++)
              n4 = e4.__digit(o3) - t4.__digit(o3) - g3, g3 = 1 & n4 >>> 30, l3.__setDigit(o3, 1073741823 & n4);
            for (; o3 < e4.length; o3++) {
              var u4 = e4.__digit(o3) - g3;
              g3 = 1 & u4 >>> 30, l3.__setDigit(o3, 1073741823 & u4);
            }
            return l3.__trim();
          } }, { key: "__absoluteAddOne", value: function(e4, t4) {
            var _4 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length;
            null === _4 ? _4 = new a3(n4, t4) : _4.sign = t4;
            for (var l3, g3 = 1, o3 = 0; o3 < n4; o3++)
              l3 = e4.__digit(o3) + g3, g3 = l3 >>> 30, _4.__setDigit(o3, 1073741823 & l3);
            return 0 !== g3 && _4.__setDigitGrow(n4, 1), _4;
          } }, { key: "__absoluteSubOne", value: function(e4, t4) {
            var _4 = e4.length;
            t4 = t4 || _4;
            for (var n4, l3 = new a3(t4, false), g3 = 1, o3 = 0; o3 < _4; o3++)
              n4 = e4.__digit(o3) - g3, g3 = 1 & n4 >>> 30, l3.__setDigit(o3, 1073741823 & n4);
            if (0 !== g3)
              throw new Error("implementation bug");
            for (var u4 = _4; u4 < t4; u4++)
              l3.__setDigit(u4, 0);
            return l3;
          } }, { key: "__absoluteAnd", value: function(e4, t4) {
            var _4 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
            if (n4 < l3) {
              g3 = n4;
              var o3 = e4, u4 = n4;
              e4 = t4, n4 = l3, t4 = o3, l3 = u4;
            }
            var s3 = g3;
            null === _4 ? _4 = new a3(s3, false) : s3 = _4.length;
            for (var r3 = 0; r3 < g3; r3++)
              _4.__setDigit(r3, e4.__digit(r3) & t4.__digit(r3));
            for (; r3 < s3; r3++)
              _4.__setDigit(r3, 0);
            return _4;
          } }, { key: "__absoluteAndNot", value: function(e4, t4) {
            var _4 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
            n4 < l3 && (g3 = n4);
            var o3 = n4;
            null === _4 ? _4 = new a3(o3, false) : o3 = _4.length;
            for (var u4 = 0; u4 < g3; u4++)
              _4.__setDigit(u4, e4.__digit(u4) & ~t4.__digit(u4));
            for (; u4 < n4; u4++)
              _4.__setDigit(u4, e4.__digit(u4));
            for (; u4 < o3; u4++)
              _4.__setDigit(u4, 0);
            return _4;
          } }, { key: "__absoluteOr", value: function(e4, t4) {
            var _4 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
            if (n4 < l3) {
              g3 = n4;
              var o3 = e4, u4 = n4;
              e4 = t4, n4 = l3, t4 = o3, l3 = u4;
            }
            var s3 = n4;
            null === _4 ? _4 = new a3(s3, false) : s3 = _4.length;
            for (var r3 = 0; r3 < g3; r3++)
              _4.__setDigit(r3, e4.__digit(r3) | t4.__digit(r3));
            for (; r3 < n4; r3++)
              _4.__setDigit(r3, e4.__digit(r3));
            for (; r3 < s3; r3++)
              _4.__setDigit(r3, 0);
            return _4;
          } }, { key: "__absoluteXor", value: function(e4, t4) {
            var _4 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
            if (n4 < l3) {
              g3 = n4;
              var o3 = e4, u4 = n4;
              e4 = t4, n4 = l3, t4 = o3, l3 = u4;
            }
            var s3 = n4;
            null === _4 ? _4 = new a3(s3, false) : s3 = _4.length;
            for (var r3 = 0; r3 < g3; r3++)
              _4.__setDigit(r3, e4.__digit(r3) ^ t4.__digit(r3));
            for (; r3 < n4; r3++)
              _4.__setDigit(r3, e4.__digit(r3));
            for (; r3 < s3; r3++)
              _4.__setDigit(r3, 0);
            return _4;
          } }, { key: "__absoluteCompare", value: function(e4, t4) {
            var _4 = e4.length - t4.length;
            if (0 != _4)
              return _4;
            for (var n4 = e4.length - 1; 0 <= n4 && e4.__digit(n4) === t4.__digit(n4); )
              n4--;
            return 0 > n4 ? 0 : e4.__unsignedDigit(n4) > t4.__unsignedDigit(n4) ? 1 : -1;
          } }, { key: "__multiplyAccumulate", value: function(e4, t4, _4, n4) {
            if (0 !== t4) {
              for (var l3 = 32767 & t4, g3 = t4 >>> 15, o3 = 0, u4 = 0, s3 = 0; s3 < e4.length; s3++, n4++) {
                var r3 = _4.__digit(n4), d3 = e4.__digit(s3), h3 = 32767 & d3, b3 = d3 >>> 15, m3 = a3.__imul(h3, l3), c3 = a3.__imul(h3, g3), v3 = a3.__imul(b3, l3), y3 = a3.__imul(b3, g3);
                r3 += u4 + m3 + o3, o3 = r3 >>> 30, r3 &= 1073741823, r3 += ((32767 & c3) << 15) + ((32767 & v3) << 15), o3 += r3 >>> 30, u4 = y3 + (c3 >>> 15) + (v3 >>> 15), _4.__setDigit(n4, 1073741823 & r3);
              }
              for (; 0 !== o3 || 0 !== u4; n4++) {
                var f3 = _4.__digit(n4);
                f3 += o3 + u4, u4 = 0, o3 = f3 >>> 30, _4.__setDigit(n4, 1073741823 & f3);
              }
            }
          } }, { key: "__internalMultiplyAdd", value: function(e4, t4, _4, l3, g3) {
            for (var o3 = _4, u4 = 0, s3 = 0; s3 < l3; s3++) {
              var d3 = e4.__digit(s3), h3 = a3.__imul(32767 & d3, t4), b3 = a3.__imul(d3 >>> 15, t4), m3 = h3 + ((32767 & b3) << 15) + u4 + o3;
              o3 = m3 >>> 30, u4 = b3 >>> 15, g3.__setDigit(s3, 1073741823 & m3);
            }
            if (g3.length > l3)
              for (g3.__setDigit(l3++, o3 + u4); l3 < g3.length; )
                g3.__setDigit(l3++, 0);
            else if (0 !== o3 + u4)
              throw new Error("implementation bug");
          } }, { key: "__absoluteDivSmall", value: function(e4, t4) {
            var _4 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
            null === _4 && (_4 = new a3(e4.length, false));
            for (var n4 = 0, l3 = 2 * e4.length - 1; 0 <= l3; l3 -= 2) {
              var g3 = (n4 << 15 | e4.__halfDigit(l3)) >>> 0, o3 = 0 | g3 / t4;
              n4 = 0 | g3 % t4, g3 = (n4 << 15 | e4.__halfDigit(l3 - 1)) >>> 0;
              var u4 = 0 | g3 / t4;
              n4 = 0 | g3 % t4, _4.__setDigit(l3 >>> 1, o3 << 15 | u4);
            }
            return _4;
          } }, { key: "__absoluteModSmall", value: function(e4, t4) {
            for (var _4, n4 = 0, l3 = 2 * e4.length - 1; 0 <= l3; l3--)
              _4 = (n4 << 15 | e4.__halfDigit(l3)) >>> 0, n4 = 0 | _4 % t4;
            return n4;
          } }, { key: "__absoluteDivLarge", value: function(e4, t4, i3, _4) {
            var l3 = t4.__halfDigitLength(), n4 = t4.length, g3 = e4.__halfDigitLength() - l3, o3 = null;
            i3 && (o3 = new a3(g3 + 2 >>> 1, false), o3.__initializeDigits());
            var s3 = new a3(l3 + 2 >>> 1, false);
            s3.__initializeDigits();
            var r3 = a3.__clz15(t4.__halfDigit(l3 - 1));
            0 < r3 && (t4 = a3.__specialLeftShift(t4, r3, 0));
            for (var d3 = a3.__specialLeftShift(e4, r3, 1), u4 = t4.__halfDigit(l3 - 1), h3 = 0, b3 = g3; 0 <= b3; b3--) {
              var m3 = 32767, v3 = d3.__halfDigit(b3 + l3);
              if (v3 !== u4) {
                var y3 = (v3 << 15 | d3.__halfDigit(b3 + l3 - 1)) >>> 0;
                m3 = 0 | y3 / u4;
                for (var f3 = 0 | y3 % u4, D3 = t4.__halfDigit(l3 - 2), p3 = d3.__halfDigit(b3 + l3 - 2); a3.__imul(m3, D3) >>> 0 > (f3 << 16 | p3) >>> 0 && (m3--, f3 += u4, !(32767 < f3)); )
                  ;
              }
              a3.__internalMultiplyAdd(t4, m3, 0, n4, s3);
              var k3 = d3.__inplaceSub(s3, b3, l3 + 1);
              0 !== k3 && (k3 = d3.__inplaceAdd(t4, b3, l3), d3.__setHalfDigit(b3 + l3, 32767 & d3.__halfDigit(b3 + l3) + k3), m3--), i3 && (1 & b3 ? h3 = m3 << 15 : o3.__setDigit(b3 >>> 1, h3 | m3));
            }
            if (_4)
              return d3.__inplaceRightShift(r3), i3 ? { quotient: o3, remainder: d3 } : d3;
            if (i3)
              return o3;
            throw new Error("unreachable");
          } }, { key: "__clz15", value: function(e4) {
            return a3.__clz30(e4) - 15;
          } }, { key: "__specialLeftShift", value: function(e4, t4, _4) {
            var l3 = e4.length, n4 = new a3(l3 + _4, false);
            if (0 === t4) {
              for (var g3 = 0; g3 < l3; g3++)
                n4.__setDigit(g3, e4.__digit(g3));
              return 0 < _4 && n4.__setDigit(l3, 0), n4;
            }
            for (var o3, u4 = 0, s3 = 0; s3 < l3; s3++)
              o3 = e4.__digit(s3), n4.__setDigit(s3, 1073741823 & o3 << t4 | u4), u4 = o3 >>> 30 - t4;
            return 0 < _4 && n4.__setDigit(l3, u4), n4;
          } }, { key: "__leftShiftByAbsolute", value: function(e4, t4) {
            var _4 = a3.__toShiftAmount(t4);
            if (0 > _4)
              throw new RangeError("BigInt too big");
            var n4 = 0 | _4 / 30, l3 = _4 % 30, g3 = e4.length, o3 = 0 !== l3 && 0 != e4.__digit(g3 - 1) >>> 30 - l3, u4 = g3 + n4 + (o3 ? 1 : 0), s3 = new a3(u4, e4.sign);
            if (0 === l3) {
              for (var r3 = 0; r3 < n4; r3++)
                s3.__setDigit(r3, 0);
              for (; r3 < u4; r3++)
                s3.__setDigit(r3, e4.__digit(r3 - n4));
            } else {
              for (var h3 = 0, b3 = 0; b3 < n4; b3++)
                s3.__setDigit(b3, 0);
              for (var m3, c3 = 0; c3 < g3; c3++)
                m3 = e4.__digit(c3), s3.__setDigit(c3 + n4, 1073741823 & m3 << l3 | h3), h3 = m3 >>> 30 - l3;
              if (o3)
                s3.__setDigit(g3 + n4, h3);
              else if (0 !== h3)
                throw new Error("implementation bug");
            }
            return s3.__trim();
          } }, { key: "__rightShiftByAbsolute", value: function(e4, t4) {
            var _4 = e4.length, n4 = e4.sign, l3 = a3.__toShiftAmount(t4);
            if (0 > l3)
              return a3.__rightShiftByMaximum(n4);
            var g3 = 0 | l3 / 30, o3 = l3 % 30, u4 = _4 - g3;
            if (0 >= u4)
              return a3.__rightShiftByMaximum(n4);
            var s3 = false;
            if (n4) {
              if (0 != (e4.__digit(g3) & (1 << o3) - 1))
                s3 = true;
              else
                for (var r3 = 0; r3 < g3; r3++)
                  if (0 !== e4.__digit(r3)) {
                    s3 = true;
                    break;
                  }
            }
            if (s3 && 0 === o3) {
              var h3 = e4.__digit(_4 - 1);
              0 == ~h3 && u4++;
            }
            var b3 = new a3(u4, n4);
            if (0 === o3) {
              b3.__setDigit(u4 - 1, 0);
              for (var m3 = g3; m3 < _4; m3++)
                b3.__setDigit(m3 - g3, e4.__digit(m3));
            } else {
              for (var c3, v3 = e4.__digit(g3) >>> o3, y3 = _4 - g3 - 1, f3 = 0; f3 < y3; f3++)
                c3 = e4.__digit(f3 + g3 + 1), b3.__setDigit(f3, 1073741823 & c3 << 30 - o3 | v3), v3 = c3 >>> o3;
              b3.__setDigit(y3, v3);
            }
            return s3 && (b3 = a3.__absoluteAddOne(b3, true, b3)), b3.__trim();
          } }, { key: "__rightShiftByMaximum", value: function(e4) {
            return e4 ? a3.__oneDigit(1, true) : a3.__zero();
          } }, { key: "__toShiftAmount", value: function(e4) {
            if (1 < e4.length)
              return -1;
            var t4 = e4.__unsignedDigit(0);
            return t4 > a3.__kMaxLengthBits ? -1 : t4;
          } }, { key: "__toPrimitive", value: function(e4) {
            var t4 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "default";
            if ("object" !== i2(e4))
              return e4;
            if (e4.constructor === a3)
              return e4;
            if ("undefined" != typeof Symbol && "symbol" === i2(Symbol.toPrimitive)) {
              var _4 = e4[Symbol.toPrimitive];
              if (_4) {
                var n4 = _4(t4);
                if ("object" !== i2(n4))
                  return n4;
                throw new TypeError("Cannot convert object to primitive value");
              }
            }
            var l3 = e4.valueOf;
            if (l3) {
              var g3 = l3.call(e4);
              if ("object" !== i2(g3))
                return g3;
            }
            var o3 = e4.toString;
            if (o3) {
              var u4 = o3.call(e4);
              if ("object" !== i2(u4))
                return u4;
            }
            throw new TypeError("Cannot convert object to primitive value");
          } }, { key: "__toNumeric", value: function(e4) {
            return a3.__isBigInt(e4) ? e4 : +e4;
          } }, { key: "__isBigInt", value: function(e4) {
            return "object" === i2(e4) && null !== e4 && e4.constructor === a3;
          } }, { key: "__truncateToNBits", value: function(e4, t4) {
            for (var _4 = 0 | (e4 + 29) / 30, n4 = new a3(_4, t4.sign), l3 = _4 - 1, g3 = 0; g3 < l3; g3++)
              n4.__setDigit(g3, t4.__digit(g3));
            var o3 = t4.__digit(l3);
            if (0 != e4 % 30) {
              var u4 = 32 - e4 % 30;
              o3 = o3 << u4 >>> u4;
            }
            return n4.__setDigit(l3, o3), n4.__trim();
          } }, { key: "__truncateAndSubFromPowerOfTwo", value: function(e4, t4, _4) {
            for (var n4 = Math.min, l3, g3 = 0 | (e4 + 29) / 30, o3 = new a3(g3, _4), u4 = 0, s3 = g3 - 1, d3 = 0, h3 = n4(s3, t4.length); u4 < h3; u4++)
              l3 = 0 - t4.__digit(u4) - d3, d3 = 1 & l3 >>> 30, o3.__setDigit(u4, 1073741823 & l3);
            for (; u4 < s3; u4++)
              o3.__setDigit(u4, 0 | 1073741823 & -d3);
            var b3, m3 = s3 < t4.length ? t4.__digit(s3) : 0, c3 = e4 % 30;
            if (0 === c3)
              b3 = 0 - m3 - d3, b3 &= 1073741823;
            else {
              var v3 = 32 - c3;
              m3 = m3 << v3 >>> v3;
              var y3 = 1 << 32 - v3;
              b3 = y3 - m3 - d3, b3 &= y3 - 1;
            }
            return o3.__setDigit(s3, b3), o3.__trim();
          } }, { key: "__digitPow", value: function(e4, t4) {
            for (var i3 = 1; 0 < t4; )
              1 & t4 && (i3 *= e4), t4 >>>= 1, e4 *= e4;
            return i3;
          } }, { key: "__isOneDigitInt", value: function(e4) {
            return (1073741823 & e4) === e4;
          } }]), a3;
        }(h2(Array));
        return S2.__kMaxLength = 33554432, S2.__kMaxLengthBits = S2.__kMaxLength << 5, S2.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], S2.__kBitsPerCharTableShift = 5, S2.__kBitsPerCharTableMultiplier = 1 << S2.__kBitsPerCharTableShift, S2.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], S2.__kBitConversionBuffer = new ArrayBuffer(8), S2.__kBitConversionDouble = new Float64Array(S2.__kBitConversionBuffer), S2.__kBitConversionInts = new Int32Array(S2.__kBitConversionBuffer), S2.__clz30 = t2 ? function(e3) {
          return t2(e3) - 2;
        } : function(e3) {
          var t3 = Math.LN2, i3 = Math.log;
          return 0 === e3 ? 30 : 0 | 29 - (0 | i3(e3 >>> 0) / t3);
        }, S2.__imul = e2 || function(e3, t3) {
          return 0 | e3 * t3;
        }, S2;
      });
    }
  });

  // node_modules/err-code/index.js
  var require_err_code = __commonJS({
    "node_modules/err-code/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      function assign(obj, props) {
        for (const key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
          });
        }
        return obj;
      }
      function createError(err, code8, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code8 === "object") {
          props = code8;
          code8 = "";
        }
        if (code8) {
          props.code = code8;
        }
        try {
          return assign(err, props);
        } catch (_3) {
          props.message = err.message;
          props.stack = err.stack;
          const ErrClass = function() {
          };
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          const output = assign(new ErrClass(), props);
          return output;
        }
      }
      module2.exports = createError;
    }
  });

  // node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
        while (index < arguments.length)
          params[offset++] = arguments[index++];
        return new Promise(function executor(resolve5, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve5.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "node_modules/@protobufjs/base64/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var base643 = exports2;
      base643.length = function length7(string2) {
        var p2 = string2.length;
        if (!p2)
          return 0;
        var n2 = 0;
        while (--p2 % 4 > 1 && string2.charAt(p2) === "=")
          ++n2;
        return Math.ceil(string2.length * 3) / 4 - n2;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i2 = 0; i2 < 64; )
        s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
      var i2;
      base643.encode = function encode21(buffer2, start, end) {
        var parts = null, chunk = [];
        var i3 = 0, j2 = 0, t2;
        while (start < end) {
          var b2 = buffer2[start++];
          switch (j2) {
            case 0:
              chunk[i3++] = b64[b2 >> 2];
              t2 = (b2 & 3) << 4;
              j2 = 1;
              break;
            case 1:
              chunk[i3++] = b64[t2 | b2 >> 4];
              t2 = (b2 & 15) << 2;
              j2 = 2;
              break;
            case 2:
              chunk[i3++] = b64[t2 | b2 >> 6];
              chunk[i3++] = b64[b2 & 63];
              j2 = 0;
              break;
          }
          if (i3 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i3 = 0;
          }
        }
        if (j2) {
          chunk[i3++] = b64[t2];
          chunk[i3++] = 61;
          if (j2 === 1)
            chunk[i3++] = 61;
        }
        if (parts) {
          if (i3)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i3));
      };
      var invalidEncoding = "invalid encoding";
      base643.decode = function decode32(string2, buffer2, offset) {
        var start = offset;
        var j2 = 0, t2;
        for (var i3 = 0; i3 < string2.length; ) {
          var c2 = string2.charCodeAt(i3++);
          if (c2 === 61 && j2 > 1)
            break;
          if ((c2 = s64[c2]) === void 0)
            throw Error(invalidEncoding);
          switch (j2) {
            case 0:
              t2 = c2;
              j2 = 1;
              break;
            case 1:
              buffer2[offset++] = t2 << 2 | (c2 & 48) >> 4;
              t2 = c2;
              j2 = 2;
              break;
            case 2:
              buffer2[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
              t2 = c2;
              j2 = 3;
              break;
            case 3:
              buffer2[offset++] = (t2 & 3) << 6 | c2;
              j2 = 0;
              break;
          }
        }
        if (j2 === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base643.test = function test(string2) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
      };
    }
  });

  // node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = EventEmitter3;
      function EventEmitter3() {
        this._listeners = {};
      }
      EventEmitter3.prototype.on = function on3(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter3.prototype.off = function off3(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners2 = this._listeners[evt];
            for (var i2 = 0; i2 < listeners2.length; )
              if (listeners2[i2].fn === fn)
                listeners2.splice(i2, 1);
              else
                ++i2;
          }
        }
        return this;
      };
      EventEmitter3.prototype.emit = function emit4(evt) {
        var listeners2 = this._listeners[evt];
        if (listeners2) {
          var args = [], i2 = 1;
          for (; i2 < arguments.length; )
            args.push(arguments[i2++]);
          for (i2 = 0; i2 < listeners2.length; )
            listeners2[i2].fn.apply(listeners2[i2++].ctx, args);
        }
        return this;
      };
    }
  });

  // node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "node_modules/@protobufjs/float/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = factory(factory);
      function factory(exports3) {
        if (typeof Float32Array !== "undefined")
          (function() {
            var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
            function writeFloat_f32_cpy(val, buf2, pos) {
              f32[0] = val;
              buf2[pos] = f8b[0];
              buf2[pos + 1] = f8b[1];
              buf2[pos + 2] = f8b[2];
              buf2[pos + 3] = f8b[3];
            }
            function writeFloat_f32_rev(val, buf2, pos) {
              f32[0] = val;
              buf2[pos] = f8b[3];
              buf2[pos + 1] = f8b[2];
              buf2[pos + 2] = f8b[1];
              buf2[pos + 3] = f8b[0];
            }
            exports3.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
            exports3.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
            function readFloat_f32_cpy(buf2, pos) {
              f8b[0] = buf2[pos];
              f8b[1] = buf2[pos + 1];
              f8b[2] = buf2[pos + 2];
              f8b[3] = buf2[pos + 3];
              return f32[0];
            }
            function readFloat_f32_rev(buf2, pos) {
              f8b[3] = buf2[pos];
              f8b[2] = buf2[pos + 1];
              f8b[1] = buf2[pos + 2];
              f8b[0] = buf2[pos + 3];
              return f32[0];
            }
            exports3.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
            exports3.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
          })();
        else
          (function() {
            function writeFloat_ieee754(writeUint, val, buf2, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0)
                writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos);
              else if (isNaN(val))
                writeUint(2143289344, buf2, pos);
              else if (val > 34028234663852886e22)
                writeUint((sign << 31 | 2139095040) >>> 0, buf2, pos);
              else if (val < 11754943508222875e-54)
                writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
              else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
              }
            }
            exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
            function readFloat_ieee754(readUint, buf2, pos) {
              var uint = readUint(buf2, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
              return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }
            exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })();
        if (typeof Float64Array !== "undefined")
          (function() {
            var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
            function writeDouble_f64_cpy(val, buf2, pos) {
              f64[0] = val;
              buf2[pos] = f8b[0];
              buf2[pos + 1] = f8b[1];
              buf2[pos + 2] = f8b[2];
              buf2[pos + 3] = f8b[3];
              buf2[pos + 4] = f8b[4];
              buf2[pos + 5] = f8b[5];
              buf2[pos + 6] = f8b[6];
              buf2[pos + 7] = f8b[7];
            }
            function writeDouble_f64_rev(val, buf2, pos) {
              f64[0] = val;
              buf2[pos] = f8b[7];
              buf2[pos + 1] = f8b[6];
              buf2[pos + 2] = f8b[5];
              buf2[pos + 3] = f8b[4];
              buf2[pos + 4] = f8b[3];
              buf2[pos + 5] = f8b[2];
              buf2[pos + 6] = f8b[1];
              buf2[pos + 7] = f8b[0];
            }
            exports3.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
            exports3.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
            function readDouble_f64_cpy(buf2, pos) {
              f8b[0] = buf2[pos];
              f8b[1] = buf2[pos + 1];
              f8b[2] = buf2[pos + 2];
              f8b[3] = buf2[pos + 3];
              f8b[4] = buf2[pos + 4];
              f8b[5] = buf2[pos + 5];
              f8b[6] = buf2[pos + 6];
              f8b[7] = buf2[pos + 7];
              return f64[0];
            }
            function readDouble_f64_rev(buf2, pos) {
              f8b[7] = buf2[pos];
              f8b[6] = buf2[pos + 1];
              f8b[5] = buf2[pos + 2];
              f8b[4] = buf2[pos + 3];
              f8b[3] = buf2[pos + 4];
              f8b[2] = buf2[pos + 5];
              f8b[1] = buf2[pos + 6];
              f8b[0] = buf2[pos + 7];
              return f64[0];
            }
            exports3.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
            exports3.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
          })();
        else
          (function() {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0) {
                writeUint(0, buf2, pos + off0);
                writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos + off1);
              } else if (isNaN(val)) {
                writeUint(0, buf2, pos + off0);
                writeUint(2146959360, buf2, pos + off1);
              } else if (val > 17976931348623157e292) {
                writeUint(0, buf2, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf2, pos + off1);
              } else {
                var mantissa;
                if (val < 22250738585072014e-324) {
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf2, pos + off0);
                  writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024)
                    exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                  writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
                }
              }
            }
            exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
            exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
            function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
              var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
              var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
            }
            exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
            exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
          })();
        return exports3;
      }
      function writeUintLE(val, buf2, pos) {
        buf2[pos] = val & 255;
        buf2[pos + 1] = val >>> 8 & 255;
        buf2[pos + 2] = val >>> 16 & 255;
        buf2[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf2, pos) {
        buf2[pos] = val >>> 24;
        buf2[pos + 1] = val >>> 16 & 255;
        buf2[pos + 2] = val >>> 8 & 255;
        buf2[pos + 3] = val & 255;
      }
      function readUintLE(buf2, pos) {
        return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf2, pos) {
        return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
      }
    }
  });

  // node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      init_virtual_process_polyfill();
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e2) {
        }
        return null;
      }
    }
  });

  // node_modules/@protobufjs/utf8/index.js
  var require_utf8 = __commonJS({
    "node_modules/@protobufjs/utf8/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var utf8 = exports2;
      utf8.length = function utf8_length(string2) {
        var len = 0, c2 = 0;
        for (var i2 = 0; i2 < string2.length; ++i2) {
          c2 = string2.charCodeAt(i2);
          if (c2 < 128)
            len += 1;
          else if (c2 < 2048)
            len += 2;
          else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
            ++i2;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf8.read = function utf8_read(buffer2, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i2 = 0, t2;
        while (start < end) {
          t2 = buffer2[start++];
          if (t2 < 128)
            chunk[i2++] = t2;
          else if (t2 > 191 && t2 < 224)
            chunk[i2++] = (t2 & 31) << 6 | buffer2[start++] & 63;
          else if (t2 > 239 && t2 < 365) {
            t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
            chunk[i2++] = 55296 + (t2 >> 10);
            chunk[i2++] = 56320 + (t2 & 1023);
          } else
            chunk[i2++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
          if (i2 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i2 = 0;
          }
        }
        if (parts) {
          if (i2)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i2));
      };
      utf8.write = function utf8_write(string2, buffer2, offset) {
        var start = offset, c1, c2;
        for (var i2 = 0; i2 < string2.length; ++i2) {
          c1 = string2.charCodeAt(i2);
          if (c1 < 128) {
            buffer2[offset++] = c1;
          } else if (c1 < 2048) {
            buffer2[offset++] = c1 >> 6 | 192;
            buffer2[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
            ++i2;
            buffer2[offset++] = c1 >> 18 | 240;
            buffer2[offset++] = c1 >> 12 & 63 | 128;
            buffer2[offset++] = c1 >> 6 & 63 | 128;
            buffer2[offset++] = c1 & 63 | 128;
          } else {
            buffer2[offset++] = c1 >> 12 | 224;
            buffer2[offset++] = c1 >> 6 & 63 | 128;
            buffer2[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    }
  });

  // node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = pool;
      function pool(alloc3, slice3, size) {
        var SIZE = size || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size2) {
          if (size2 < 1 || size2 > MAX)
            return alloc3(size2);
          if (offset + size2 > SIZE) {
            slab = alloc3(SIZE);
            offset = 0;
          }
          var buf2 = slice3.call(slab, offset, offset += size2);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf2;
        };
      }
    }
  });

  // node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = LongBits;
      var util = require_minimal();
      function LongBits(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero = LongBits.zero = new LongBits(0, 0);
      zero.toNumber = function() {
        return 0;
      };
      zero.zzEncode = zero.zzDecode = function() {
        return this;
      };
      zero.length = function() {
        return 1;
      };
      var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits.fromNumber = function fromNumber(value) {
        if (value === 0)
          return zero;
        var sign = value < 0;
        if (sign)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits(lo, hi);
      };
      LongBits.from = function from12(value) {
        if (typeof value === "number")
          return LongBits.fromNumber(value);
        if (util.isString(value)) {
          if (util.Long)
            value = util.Long.fromString(value);
          else
            return LongBits.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
      };
      LongBits.prototype.toNumber = function toNumber(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits.prototype.toLong = function toLong(unsigned) {
        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits.fromHash = function fromHash(hash) {
        if (hash === zeroHash)
          return zero;
        return new LongBits(
          (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
          (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
        );
      };
      LongBits.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          this.lo >>> 8 & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24,
          this.hi & 255,
          this.hi >>> 8 & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
        );
      };
      LongBits.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.length = function length7() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "node_modules/protobufjs/src/util/minimal.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var util = exports2;
      util.asPromise = require_aspromise();
      util.base64 = require_base64();
      util.EventEmitter = require_eventemitter();
      util.float = require_float();
      util.inquire = require_inquire();
      util.utf8 = require_utf8();
      util.pool = require_pool();
      util.LongBits = require_longbits();
      util.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
      util.global = util.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
      util.emptyArray = Object.freeze ? Object.freeze([]) : [];
      util.emptyObject = Object.freeze ? Object.freeze({}) : {};
      util.isInteger = Number.isInteger || function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util.isString = function isString2(value) {
        return typeof value === "string" || value instanceof String;
      };
      util.isObject = function isObject2(value) {
        return value && typeof value === "object";
      };
      util.isset = util.isSet = function isSet(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util.Buffer = function() {
        try {
          var Buffer3 = util.inquire("buffer").Buffer;
          return Buffer3.prototype.utf8Write ? Buffer3 : null;
        } catch (e2) {
          return null;
        }
      }();
      util._Buffer_from = null;
      util._Buffer_allocUnsafe = null;
      util.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
      util.key2Re = /^true|false|0|1$/;
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util.longToHash = function longToHash(value) {
        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
      };
      util.longFromHash = function longFromHash(hash, unsigned) {
        var bits = util.LongBits.fromHash(hash);
        if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge(dst, src7, ifNotSet) {
        for (var keys = Object.keys(src7), i2 = 0; i2 < keys.length; ++i2)
          if (dst[keys[i2]] === void 0 || !ifNotSet)
            dst[keys[i2]] = src7[keys[i2]];
        return dst;
      }
      util.merge = merge;
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name6) {
        function CustomError(message, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge(this, properties);
        }
        (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
        Object.defineProperty(CustomError.prototype, "name", { get: function() {
          return name6;
        } });
        CustomError.prototype.toString = function toString6() {
          return this.name + ": " + this.message;
        };
        return CustomError;
      }
      util.newError = newError;
      util.ProtocolError = newError("ProtocolError");
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          fieldMap[fieldNames[i2]] = 1;
        return function() {
          for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
            if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
              return keys[i3];
        };
      };
      util.oneOfSetter = function setOneOf(fieldNames) {
        return function(name6) {
          for (var i2 = 0; i2 < fieldNames.length; ++i2)
            if (fieldNames[i2] !== name6)
              delete this[fieldNames[i2]];
        };
      };
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util._configure = function() {
        var Buffer3 = util.Buffer;
        if (!Buffer3) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        util._Buffer_from = Buffer3.from !== Uint8Array.from && Buffer3.from || function Buffer_from(value, encoding) {
          return new Buffer3(value, encoding);
        };
        util._Buffer_allocUnsafe = Buffer3.allocUnsafe || function Buffer_allocUnsafe(size) {
          return new Buffer3(size);
        };
      };
    }
  });

  // node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "node_modules/protobufjs/src/writer.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = Writer;
      var util = require_minimal();
      var BufferWriter;
      var LongBits = util.LongBits;
      var base643 = util.base64;
      var utf8 = util.utf8;
      function Op(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop3() {
      }
      function State(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op(noop3, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create8 = function create9() {
        return util.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create8();
      Writer.alloc = function alloc3(size) {
        return new util.Array(size);
      };
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
      Writer.prototype._push = function push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte(val, buf2, pos) {
        buf2[pos] = val & 255;
      }
      function writeVarint32(val, buf2, pos) {
        while (val > 127) {
          buf2[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf2[pos] = val;
      }
      function VarintOp(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp.prototype = Object.create(Op.prototype);
      VarintOp.prototype.fn = writeVarint32;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
          value
        )).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint64(val, buf2, pos) {
        while (val.hi) {
          buf2[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf2[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf2[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits.from(value);
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits.from(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
      };
      function writeFixed32(val, buf2, pos) {
        buf2[pos] = val & 255;
        buf2[pos + 1] = val >>> 8 & 255;
        buf2[pos + 2] = val >>> 16 & 255;
        buf2[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits.from(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };
      var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytes_for(val, buf2, pos) {
        for (var i2 = 0; i2 < val.length; ++i2)
          buf2[pos + i2] = val[i2];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte, 1, 0);
        if (util.isString(value)) {
          var buf2 = Writer.alloc(len = base643.length(value));
          base643.decode(value, buf2, 0);
          value = buf2;
        }
        return this.uint32(len)._push(writeBytes, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf8.length(value);
        return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
      };
      Writer.prototype.fork = function fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop3, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(noop3, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf2, pos);
          pos += head.len;
          head = head.next;
        }
        return buf2;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create8();
        BufferWriter._configure();
      };
    }
  });

  // node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
          buf2.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf2, pos) {
          if (val.copy)
            val.copy(buf2, pos, 0, val.length);
          else
            for (var i2 = 0; i2 < val.length; )
              buf2[pos++] = val[i2++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value))
          value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer(val, buf2, pos) {
        if (val.length < 40)
          util.utf8.write(val, buf2, pos);
        else if (buf2.utf8Write)
          buf2.utf8Write(val, pos);
        else
          buf2.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "node_modules/protobufjs/src/reader.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = Reader;
      var util = require_minimal();
      var BufferReader;
      var LongBits = util.LongBits;
      var utf8 = util.utf8;
      function indexOutOfRange(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer2) {
        this.buf = buffer2;
        this.pos = 0;
        this.len = buffer2.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
        if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
          return new Reader(buffer2);
        throw Error("illegal buffer");
      } : function create_array2(buffer2) {
        if (Array.isArray(buffer2))
          return new Reader(buffer2);
        throw Error("illegal buffer");
      };
      var create8 = function create9() {
        return util.Buffer ? function create_buffer_setup(buffer2) {
          return (Reader.create = function create_buffer(buffer3) {
            return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
          })(buffer2);
        } : create_array;
      };
      Reader.create = create8();
      Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
      Reader.prototype.uint32 = function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
          }
          return value;
        };
      }();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits(0, 0);
        var i2 = 0;
        if (this.len - this.pos > 4) {
          for (; i2 < 4; ++i2) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i2 = 0;
        } else {
          for (; i2 < 3; ++i2) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i2 < 5; ++i2) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i2 < 5; ++i2) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf2, end) {
        return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length7 = this.uint32(), start = this.pos, end = this.pos + length7;
        if (end > this.len)
          throw indexOutOfRange(this, length7);
        this.pos += length7;
        if (Array.isArray(this.buf))
          return this.buf.slice(start, end);
        return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes = this.bytes();
        return utf8.read(bytes, 0, bytes.length);
      };
      Reader.prototype.skip = function skip(length7) {
        if (typeof length7 === "number") {
          if (this.pos + length7 > this.len)
            throw indexOutOfRange(this, length7);
          this.pos += length7;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create8();
        BufferReader._configure();
        var fn = util.Long ? "toLong" : "toNumber";
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util = require_minimal();
      function BufferReader(buffer2) {
        Reader.call(this, buffer2);
      }
      BufferReader._configure = function() {
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = Service;
      var util = require_minimal();
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
        if (!request)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(
            method,
            requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self2.emit("error", err, method);
                return callback(err);
              }
              if (response === null) {
                self2.end(true);
                return void 0;
              }
              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err2) {
                  self2.emit("error", err2, method);
                  return callback(err2);
                }
              }
              self2.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "node_modules/protobufjs/src/rpc.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var rpc = exports2;
      rpc.Service = require_service();
    }
  });

  // node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "node_modules/protobufjs/src/roots.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = {};
    }
  });

  // node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "node_modules/protobufjs/src/index-minimal.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var protobuf = exports2;
      protobuf.build = "minimal";
      protobuf.Writer = require_writer();
      protobuf.BufferWriter = require_writer_buffer();
      protobuf.Reader = require_reader();
      protobuf.BufferReader = require_reader_buffer();
      protobuf.util = require_minimal();
      protobuf.rpc = require_rpc();
      protobuf.roots = require_roots();
      protobuf.configure = configure;
      function configure() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }
      configure();
    }
  });

  // node_modules/protobufjs/minimal.js
  var require_minimal2 = __commonJS({
    "node_modules/protobufjs/minimal.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = require_index_minimal();
    }
  });

  // node_modules/sparse-array/index.js
  var require_sparse_array = __commonJS({
    "node_modules/sparse-array/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var BITS_PER_BYTE = 7;
      module2.exports = class SparseArray {
        constructor() {
          this._bitArrays = [];
          this._data = [];
          this._length = 0;
          this._changedLength = false;
          this._changedData = false;
        }
        set(index, value) {
          let pos = this._internalPositionFor(index, false);
          if (value === void 0) {
            if (pos !== -1) {
              this._unsetInternalPos(pos);
              this._unsetBit(index);
              this._changedLength = true;
              this._changedData = true;
            }
          } else {
            let needsSort = false;
            if (pos === -1) {
              pos = this._data.length;
              this._setBit(index);
              this._changedData = true;
            } else {
              needsSort = true;
            }
            this._setInternalPos(pos, index, value, needsSort);
            this._changedLength = true;
          }
        }
        unset(index) {
          this.set(index, void 0);
        }
        get(index) {
          this._sortData();
          const pos = this._internalPositionFor(index, true);
          if (pos === -1) {
            return void 0;
          }
          return this._data[pos][1];
        }
        push(value) {
          this.set(this.length, value);
          return this.length;
        }
        get length() {
          this._sortData();
          if (this._changedLength) {
            const last2 = this._data[this._data.length - 1];
            this._length = last2 ? last2[0] + 1 : 0;
            this._changedLength = false;
          }
          return this._length;
        }
        forEach(iterator) {
          let i2 = 0;
          while (i2 < this.length) {
            iterator(this.get(i2), i2, this);
            i2++;
          }
        }
        map(iterator) {
          let i2 = 0;
          let mapped = new Array(this.length);
          while (i2 < this.length) {
            mapped[i2] = iterator(this.get(i2), i2, this);
            i2++;
          }
          return mapped;
        }
        reduce(reducer, initialValue) {
          let i2 = 0;
          let acc = initialValue;
          while (i2 < this.length) {
            const value = this.get(i2);
            acc = reducer(acc, value, i2);
            i2++;
          }
          return acc;
        }
        find(finder) {
          let i2 = 0, found, last2;
          while (i2 < this.length && !found) {
            last2 = this.get(i2);
            found = finder(last2);
            i2++;
          }
          return found ? last2 : void 0;
        }
        _internalPositionFor(index, noCreate) {
          const bytePos = this._bytePosFor(index, noCreate);
          if (bytePos >= this._bitArrays.length) {
            return -1;
          }
          const byte = this._bitArrays[bytePos];
          const bitPos = index - bytePos * BITS_PER_BYTE;
          const exists = (byte & 1 << bitPos) > 0;
          if (!exists) {
            return -1;
          }
          const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
          const mask = ~(4294967295 << bitPos + 1);
          const bytePopCount = popCount(byte & mask);
          const arrayPos = previousPopCount + bytePopCount - 1;
          return arrayPos;
        }
        _bytePosFor(index, noCreate) {
          const bytePos = Math.floor(index / BITS_PER_BYTE);
          const targetLength = bytePos + 1;
          while (!noCreate && this._bitArrays.length < targetLength) {
            this._bitArrays.push(0);
          }
          return bytePos;
        }
        _setBit(index) {
          const bytePos = this._bytePosFor(index, false);
          this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
        }
        _unsetBit(index) {
          const bytePos = this._bytePosFor(index, false);
          this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
        }
        _setInternalPos(pos, index, value, needsSort) {
          const data = this._data;
          const elem = [index, value];
          if (needsSort) {
            this._sortData();
            data[pos] = elem;
          } else {
            if (data.length) {
              if (data[data.length - 1][0] >= index) {
                data.push(elem);
              } else if (data[0][0] <= index) {
                data.unshift(elem);
              } else {
                const randomIndex = Math.round(data.length / 2);
                this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
              }
            } else {
              this._data.push(elem);
            }
            this._changedData = true;
            this._changedLength = true;
          }
        }
        _unsetInternalPos(pos) {
          this._data.splice(pos, 1);
        }
        _sortData() {
          if (this._changedData) {
            this._data.sort(sortInternal);
          }
          this._changedData = false;
        }
        bitField() {
          const bytes = [];
          let pendingBitsForResultingByte = 8;
          let pendingBitsForNewByte = 0;
          let resultingByte = 0;
          let newByte;
          const pending = this._bitArrays.slice();
          while (pending.length || pendingBitsForNewByte) {
            if (pendingBitsForNewByte === 0) {
              newByte = pending.shift();
              pendingBitsForNewByte = 7;
            }
            const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
            const mask = ~(255 << usingBits);
            const masked = newByte & mask;
            resultingByte |= masked << 8 - pendingBitsForResultingByte;
            newByte = newByte >>> usingBits;
            pendingBitsForNewByte -= usingBits;
            pendingBitsForResultingByte -= usingBits;
            if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
              bytes.push(resultingByte);
              resultingByte = 0;
              pendingBitsForResultingByte = 8;
            }
          }
          for (var i2 = bytes.length - 1; i2 > 0; i2--) {
            const value = bytes[i2];
            if (value === 0) {
              bytes.pop();
            } else {
              break;
            }
          }
          return bytes;
        }
        compactArray() {
          this._sortData();
          return this._data.map(valueOnly);
        }
      };
      function popCountReduce(count, byte) {
        return count + popCount(byte);
      }
      function popCount(_v) {
        let v2 = _v;
        v2 = v2 - (v2 >> 1 & 1431655765);
        v2 = (v2 & 858993459) + (v2 >> 2 & 858993459);
        return (v2 + (v2 >> 4) & 252645135) * 16843009 >> 24;
      }
      function sortInternal(a2, b2) {
        return a2[0] - b2[0];
      }
      function valueOnly(elem) {
        return elem[1];
      }
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/vendor/base-x.js
  function base4(ALPHABET, name6) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
      BASE_MAP[j2] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET.length; i2++) {
      var x2 = ALPHABET.charAt(i2);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode21(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length7 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length7) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        pbegin++;
      }
      var it2 = size - length7;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length7 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length7) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length7;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j3 = zeroes;
      while (it4 !== size) {
        vch[j3++] = b256[it4++];
      }
      return vch;
    }
    function decode32(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name6} character`);
    }
    return {
      encode: encode21,
      decodeUnsafe,
      decode: decode32
    };
  }
  var src4, _brrp__multiformats_scope_baseX4, base_x_default4;
  var init_base_x = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/vendor/base-x.js"() {
      init_virtual_process_polyfill();
      src4 = base4;
      _brrp__multiformats_scope_baseX4 = src4;
      base_x_default4 = _brrp__multiformats_scope_baseX4;
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bytes.js
  var empty4, equals8, coerce4, fromString3, toString4;
  var init_bytes = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bytes.js"() {
      init_virtual_process_polyfill();
      empty4 = new Uint8Array(0);
      equals8 = (aa, bb) => {
        if (aa === bb)
          return true;
        if (aa.byteLength !== bb.byteLength) {
          return false;
        }
        for (let ii = 0; ii < aa.byteLength; ii++) {
          if (aa[ii] !== bb[ii]) {
            return false;
          }
        }
        return true;
      };
      coerce4 = (o2) => {
        if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
          return o2;
        if (o2 instanceof ArrayBuffer)
          return new Uint8Array(o2);
        if (ArrayBuffer.isView(o2)) {
          return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
        }
        throw new Error("Unknown type, must be binary type");
      };
      fromString3 = (str) => new TextEncoder().encode(str);
      toString4 = (b2) => new TextDecoder().decode(b2);
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base.js
  var Encoder5, Decoder4, ComposedDecoder4, or4, Codec4, from6, baseX4, decode18, encode12, rfc46484;
  var init_base = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base.js"() {
      init_virtual_process_polyfill();
      init_base_x();
      init_bytes();
      Encoder5 = class {
        constructor(name6, prefix, baseEncode) {
          this.name = name6;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes) {
          if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      Decoder4 = class {
        constructor(name6, prefix, baseDecode) {
          this.name = name6;
          this.prefix = prefix;
          if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefix.codePointAt(0);
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder) {
          return or4(this, decoder);
        }
      };
      ComposedDecoder4 = class {
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder) {
          return or4(this, decoder);
        }
        decode(input) {
          const prefix = input[0];
          const decoder = this.decoders[prefix];
          if (decoder) {
            return decoder.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      or4 = (left, right) => new ComposedDecoder4({
        ...left.decoders || { [left.prefix]: left },
        ...right.decoders || { [right.prefix]: right }
      });
      Codec4 = class {
        constructor(name6, prefix, baseEncode, baseDecode) {
          this.name = name6;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder5(name6, prefix, baseEncode);
          this.decoder = new Decoder4(name6, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
      from6 = ({ name: name6, prefix, encode: encode21, decode: decode32 }) => new Codec4(name6, prefix, encode21, decode32);
      baseX4 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
        const { encode: encode21, decode: decode32 } = base_x_default4(alphabet2, name6);
        return from6({
          prefix,
          name: name6,
          encode: encode21,
          decode: (text) => coerce4(decode32(text))
        });
      };
      decode18 = (string2, alphabet2, bitsPerChar, name6) => {
        const codes = {};
        for (let i2 = 0; i2 < alphabet2.length; ++i2) {
          codes[alphabet2[i2]] = i2;
        }
        let end = string2.length;
        while (string2[end - 1] === "=") {
          --end;
        }
        const out = new Uint8Array(end * bitsPerChar / 8 | 0);
        let bits = 0;
        let buffer2 = 0;
        let written = 0;
        for (let i2 = 0; i2 < end; ++i2) {
          const value = codes[string2[i2]];
          if (value === void 0) {
            throw new SyntaxError(`Non-${name6} character`);
          }
          buffer2 = buffer2 << bitsPerChar | value;
          bits += bitsPerChar;
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer2 >> bits;
          }
        }
        if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
          throw new SyntaxError("Unexpected end of data");
        }
        return out;
      };
      encode12 = (data, alphabet2, bitsPerChar) => {
        const pad2 = alphabet2[alphabet2.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";
        let bits = 0;
        let buffer2 = 0;
        for (let i2 = 0; i2 < data.length; ++i2) {
          buffer2 = buffer2 << 8 | data[i2];
          bits += 8;
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet2[mask & buffer2 >> bits];
          }
        }
        if (bits) {
          out += alphabet2[mask & buffer2 << bitsPerChar - bits];
        }
        if (pad2) {
          while (out.length * bitsPerChar & 7) {
            out += "=";
          }
        }
        return out;
      };
      rfc46484 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
        return from6({
          prefix,
          name: name6,
          encode(input) {
            return encode12(input, alphabet2, bitsPerChar);
          },
          decode(input) {
            return decode18(input, alphabet2, bitsPerChar, name6);
          }
        });
      };
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/identity.js
  var identity_exports = {};
  __export(identity_exports, {
    identity: () => identity2
  });
  var identity2;
  var init_identity = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/identity.js"() {
      init_virtual_process_polyfill();
      init_base();
      init_bytes();
      identity2 = from6({
        prefix: "\0",
        name: "identity",
        encode: (buf2) => toString4(buf2),
        decode: (str) => fromString3(str)
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base2.js
  var base2_exports = {};
  __export(base2_exports, {
    base2: () => base22
  });
  var base22;
  var init_base2 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base2.js"() {
      init_virtual_process_polyfill();
      init_base();
      base22 = rfc46484({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base8.js
  var base8_exports = {};
  __export(base8_exports, {
    base8: () => base8
  });
  var base8;
  var init_base8 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base8.js"() {
      init_virtual_process_polyfill();
      init_base();
      base8 = rfc46484({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base10.js
  var base10_exports = {};
  __export(base10_exports, {
    base10: () => base10
  });
  var base10;
  var init_base10 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base10.js"() {
      init_virtual_process_polyfill();
      init_base();
      base10 = baseX4({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base16.js
  var base16_exports = {};
  __export(base16_exports, {
    base16: () => base16,
    base16upper: () => base16upper
  });
  var base16, base16upper;
  var init_base16 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base16.js"() {
      init_virtual_process_polyfill();
      init_base();
      base16 = rfc46484({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      });
      base16upper = rfc46484({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base32.js
  var base32_exports = {};
  __export(base32_exports, {
    base32: () => base324,
    base32hex: () => base32hex4,
    base32hexpad: () => base32hexpad4,
    base32hexpadupper: () => base32hexpadupper4,
    base32hexupper: () => base32hexupper4,
    base32pad: () => base32pad4,
    base32padupper: () => base32padupper4,
    base32upper: () => base32upper4,
    base32z: () => base32z4
  });
  var base324, base32upper4, base32pad4, base32padupper4, base32hex4, base32hexupper4, base32hexpad4, base32hexpadupper4, base32z4;
  var init_base32 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base32.js"() {
      init_virtual_process_polyfill();
      init_base();
      base324 = rfc46484({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      base32upper4 = rfc46484({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      base32pad4 = rfc46484({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      base32padupper4 = rfc46484({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      base32hex4 = rfc46484({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      base32hexupper4 = rfc46484({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      base32hexpad4 = rfc46484({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      base32hexpadupper4 = rfc46484({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      base32z4 = rfc46484({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base36.js
  var base36_exports = {};
  __export(base36_exports, {
    base36: () => base36,
    base36upper: () => base36upper
  });
  var base36, base36upper;
  var init_base36 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base36.js"() {
      init_virtual_process_polyfill();
      init_base();
      base36 = baseX4({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      });
      base36upper = baseX4({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base58.js
  var base58_exports = {};
  __export(base58_exports, {
    base58btc: () => base58btc4,
    base58flickr: () => base58flickr4
  });
  var base58btc4, base58flickr4;
  var init_base58 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base58.js"() {
      init_virtual_process_polyfill();
      init_base();
      base58btc4 = baseX4({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      base58flickr4 = baseX4({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base64.js
  var base64_exports = {};
  __export(base64_exports, {
    base64: () => base642,
    base64pad: () => base64pad2,
    base64url: () => base64url2,
    base64urlpad: () => base64urlpad2
  });
  var base642, base64pad2, base64url2, base64urlpad2;
  var init_base64 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base64.js"() {
      init_virtual_process_polyfill();
      init_base();
      base642 = rfc46484({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      });
      base64pad2 = rfc46484({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      });
      base64url2 = rfc46484({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      });
      base64urlpad2 = rfc46484({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base256emoji.js
  var base256emoji_exports = {};
  __export(base256emoji_exports, {
    base256emoji: () => base256emoji
  });
  function encode13(data) {
    return data.reduce((p2, c2) => {
      p2 += alphabetBytesToChars[c2];
      return p2;
    }, "");
  }
  function decode19(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === void 0) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
  var init_base256emoji = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base256emoji.js"() {
      init_virtual_process_polyfill();
      init_base();
      alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
      alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
        p2[i2] = c2;
        return p2;
      }, []);
      alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
        p2[c2.codePointAt(0)] = i2;
        return p2;
      }, []);
      base256emoji = from6({
        prefix: "\u{1F680}",
        name: "base256emoji",
        encode: encode13,
        decode: decode19
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/vendor/varint.js
  function encode14(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT4) {
      out[offset++] = num & 255 | MSB4;
      num /= 128;
    }
    while (num & MSBALL4) {
      out[offset++] = num & 255 | MSB4;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode14.bytes = offset - oldOffset + 1;
    return out;
  }
  function read5(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
    do {
      if (counter >= l2) {
        read5.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b2 = buf2[counter++];
      res += shift < 28 ? (b2 & REST$14) << shift : (b2 & REST$14) * Math.pow(2, shift);
      shift += 7;
    } while (b2 >= MSB$14);
    read5.bytes = counter - offset;
    return res;
  }
  var encode_14, MSB4, REST4, MSBALL4, INT4, decode20, MSB$14, REST$14, N14, N24, N34, N44, N54, N64, N74, N84, N94, length4, varint4, _brrp_varint4, varint_default4;
  var init_varint = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/vendor/varint.js"() {
      init_virtual_process_polyfill();
      encode_14 = encode14;
      MSB4 = 128;
      REST4 = 127;
      MSBALL4 = ~REST4;
      INT4 = Math.pow(2, 31);
      decode20 = read5;
      MSB$14 = 128;
      REST$14 = 127;
      N14 = Math.pow(2, 7);
      N24 = Math.pow(2, 14);
      N34 = Math.pow(2, 21);
      N44 = Math.pow(2, 28);
      N54 = Math.pow(2, 35);
      N64 = Math.pow(2, 42);
      N74 = Math.pow(2, 49);
      N84 = Math.pow(2, 56);
      N94 = Math.pow(2, 63);
      length4 = function(value) {
        return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
      };
      varint4 = {
        encode: encode_14,
        decode: decode20,
        encodingLength: length4
      };
      _brrp_varint4 = varint4;
      varint_default4 = _brrp_varint4;
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/varint.js
  var decode21, encodeTo4, encodingLength4;
  var init_varint2 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/varint.js"() {
      init_virtual_process_polyfill();
      init_varint();
      decode21 = (data, offset = 0) => {
        const code8 = varint_default4.decode(data, offset);
        return [
          code8,
          varint_default4.decode.bytes
        ];
      };
      encodeTo4 = (int, target, offset = 0) => {
        varint_default4.encode(int, target, offset);
        return target;
      };
      encodingLength4 = (int) => {
        return varint_default4.encodingLength(int);
      };
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/digest.js
  var create4, decode22, equals9, Digest4;
  var init_digest = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/digest.js"() {
      init_virtual_process_polyfill();
      init_bytes();
      init_varint2();
      create4 = (code8, digest3) => {
        const size = digest3.byteLength;
        const sizeOffset = encodingLength4(code8);
        const digestOffset = sizeOffset + encodingLength4(size);
        const bytes = new Uint8Array(digestOffset + size);
        encodeTo4(code8, bytes, 0);
        encodeTo4(size, bytes, sizeOffset);
        bytes.set(digest3, digestOffset);
        return new Digest4(code8, size, digest3, bytes);
      };
      decode22 = (multihash) => {
        const bytes = coerce4(multihash);
        const [code8, sizeOffset] = decode21(bytes);
        const [size, digestOffset] = decode21(bytes.subarray(sizeOffset));
        const digest3 = bytes.subarray(sizeOffset + digestOffset);
        if (digest3.byteLength !== size) {
          throw new Error("Incorrect length");
        }
        return new Digest4(code8, size, digest3, bytes);
      };
      equals9 = (a2, b2) => {
        if (a2 === b2) {
          return true;
        } else {
          return a2.code === b2.code && a2.size === b2.size && equals8(a2.bytes, b2.bytes);
        }
      };
      Digest4 = class {
        constructor(code8, size, digest3, bytes) {
          this.code = code8;
          this.size = size;
          this.digest = digest3;
          this.bytes = bytes;
        }
      };
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/hasher.js
  var from7, Hasher2;
  var init_hasher = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/hasher.js"() {
      init_virtual_process_polyfill();
      init_digest();
      from7 = ({ name: name6, code: code8, encode: encode21 }) => new Hasher2(name6, code8, encode21);
      Hasher2 = class {
        constructor(name6, code8, encode21) {
          this.name = name6;
          this.code = code8;
          this.encode = encode21;
        }
        digest(input) {
          if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest3) => create4(this.code, digest3));
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/sha2-browser.js
  var sha2_browser_exports = {};
  __export(sha2_browser_exports, {
    sha256: () => sha256,
    sha512: () => sha512
  });
  var sha, sha256, sha512;
  var init_sha2_browser = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
      init_virtual_process_polyfill();
      init_hasher();
      sha = (name6) => async (data) => new Uint8Array(await crypto.subtle.digest(name6, data));
      sha256 = from7({
        name: "sha2-256",
        code: 18,
        encode: sha("SHA-256")
      });
      sha512 = from7({
        name: "sha2-512",
        code: 19,
        encode: sha("SHA-512")
      });
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/identity.js
  var identity_exports2 = {};
  __export(identity_exports2, {
    identity: () => identity3
  });
  var code6, name4, encode15, digest2, identity3;
  var init_identity2 = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/identity.js"() {
      init_virtual_process_polyfill();
      init_bytes();
      init_digest();
      code6 = 0;
      name4 = "identity";
      encode15 = coerce4;
      digest2 = (input) => create4(code6, encode15(input));
      identity3 = {
        code: code6,
        name: name4,
        encode: encode15,
        digest: digest2
      };
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/codecs/raw.js
  var init_raw = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/codecs/raw.js"() {
      init_virtual_process_polyfill();
      init_bytes();
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/codecs/json.js
  var textEncoder5, textDecoder4;
  var init_json = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/codecs/json.js"() {
      init_virtual_process_polyfill();
      textEncoder5 = new TextEncoder();
      textDecoder4 = new TextDecoder();
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/cid.js
  var CID4, parseCIDtoBytes4, toStringV04, toStringV14, DAG_PB_CODE4, SHA_256_CODE4, encodeCID4, cidSymbol4, readonly4, hidden3, version5, deprecate4, IS_CID_DEPRECATION3;
  var init_cid = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/cid.js"() {
      init_virtual_process_polyfill();
      init_varint2();
      init_digest();
      init_base58();
      init_base32();
      init_bytes();
      CID4 = class {
        constructor(version8, code8, multihash, bytes) {
          this.code = code8;
          this.version = version8;
          this.multihash = multihash;
          this.bytes = bytes;
          this.byteOffset = bytes.byteOffset;
          this.byteLength = bytes.byteLength;
          this.asCID = this;
          this._baseCache = /* @__PURE__ */ new Map();
          Object.defineProperties(this, {
            byteOffset: hidden3,
            byteLength: hidden3,
            code: readonly4,
            version: readonly4,
            multihash: readonly4,
            bytes: readonly4,
            _baseCache: hidden3,
            asCID: hidden3
          });
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            default: {
              const { code: code8, multihash } = this;
              if (code8 !== DAG_PB_CODE4) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE4) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return CID4.createV0(multihash);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code: code8, digest: digest3 } = this.multihash;
              const multihash = create4(code8, digest3);
              return CID4.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return other && this.code === other.code && this.version === other.version && equals9(this.multihash, other.multihash);
        }
        toString(base7) {
          const { bytes, version: version8, _baseCache } = this;
          switch (version8) {
            case 0:
              return toStringV04(bytes, _baseCache, base7 || base58btc4.encoder);
            default:
              return toStringV14(bytes, _baseCache, base7 || base324.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(value) {
          deprecate4(/^0\.0/, IS_CID_DEPRECATION3);
          return !!(value && (value[cidSymbol4] || value.asCID === value));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(value) {
          if (value instanceof CID4) {
            return value;
          } else if (value != null && value.asCID === value) {
            const { version: version8, code: code8, multihash, bytes } = value;
            return new CID4(version8, code8, multihash, bytes || encodeCID4(version8, code8, multihash.bytes));
          } else if (value != null && value[cidSymbol4] === true) {
            const { version: version8, multihash, code: code8 } = value;
            const digest3 = decode22(multihash);
            return CID4.create(version8, code8, digest3);
          } else {
            return null;
          }
        }
        static create(version8, code8, digest3) {
          if (typeof code8 !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          switch (version8) {
            case 0: {
              if (code8 !== DAG_PB_CODE4) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`);
              } else {
                return new CID4(version8, code8, digest3, digest3.bytes);
              }
            }
            case 1: {
              const bytes = encodeCID4(version8, code8, digest3.bytes);
              return new CID4(version8, code8, digest3, bytes);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        static createV0(digest3) {
          return CID4.create(0, DAG_PB_CODE4, digest3);
        }
        static createV1(code8, digest3) {
          return CID4.create(1, code8, digest3);
        }
        static decode(bytes) {
          const [cid, remainder] = CID4.decodeFirst(bytes);
          if (remainder.length) {
            throw new Error("Incorrect length");
          }
          return cid;
        }
        static decodeFirst(bytes) {
          const specs = CID4.inspectBytes(bytes);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce4(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest3 = new Digest4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid = specs.version === 0 ? CID4.createV0(digest3) : CID4.createV1(specs.codec, digest3);
          return [
            cid,
            bytes.subarray(specs.size)
          ];
        }
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i2, length7] = decode21(initialBytes.subarray(offset));
            offset += length7;
            return i2;
          };
          let version8 = next();
          let codec = DAG_PB_CODE4;
          if (version8 === 18) {
            version8 = 0;
            offset = 0;
          } else if (version8 === 1) {
            codec = next();
          }
          if (version8 !== 0 && version8 !== 1) {
            throw new RangeError(`Invalid CID version ${version8}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size = offset + digestSize;
          const multihashSize = size - prefixSize;
          return {
            version: version8,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
          };
        }
        static parse(source, base7) {
          const [prefix, bytes] = parseCIDtoBytes4(source, base7);
          const cid = CID4.decode(bytes);
          cid._baseCache.set(prefix, source);
          return cid;
        }
      };
      parseCIDtoBytes4 = (source, base7) => {
        switch (source[0]) {
          case "Q": {
            const decoder = base7 || base58btc4;
            return [
              base58btc4.prefix,
              decoder.decode(`${base58btc4.prefix}${source}`)
            ];
          }
          case base58btc4.prefix: {
            const decoder = base7 || base58btc4;
            return [
              base58btc4.prefix,
              decoder.decode(source)
            ];
          }
          case base324.prefix: {
            const decoder = base7 || base324;
            return [
              base324.prefix,
              decoder.decode(source)
            ];
          }
          default: {
            if (base7 == null) {
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            }
            return [
              source[0],
              base7.decode(source)
            ];
          }
        }
      };
      toStringV04 = (bytes, cache2, base7) => {
        const { prefix } = base7;
        if (prefix !== base58btc4.prefix) {
          throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
        }
        const cid = cache2.get(prefix);
        if (cid == null) {
          const cid2 = base7.encode(bytes).slice(1);
          cache2.set(prefix, cid2);
          return cid2;
        } else {
          return cid;
        }
      };
      toStringV14 = (bytes, cache2, base7) => {
        const { prefix } = base7;
        const cid = cache2.get(prefix);
        if (cid == null) {
          const cid2 = base7.encode(bytes);
          cache2.set(prefix, cid2);
          return cid2;
        } else {
          return cid;
        }
      };
      DAG_PB_CODE4 = 112;
      SHA_256_CODE4 = 18;
      encodeCID4 = (version8, code8, multihash) => {
        const codeOffset = encodingLength4(version8);
        const hashOffset = codeOffset + encodingLength4(code8);
        const bytes = new Uint8Array(hashOffset + multihash.byteLength);
        encodeTo4(version8, bytes, 0);
        encodeTo4(code8, bytes, codeOffset);
        bytes.set(multihash, hashOffset);
        return bytes;
      };
      cidSymbol4 = Symbol.for("@ipld/js-cid/CID");
      readonly4 = {
        writable: false,
        configurable: false,
        enumerable: true
      };
      hidden3 = {
        writable: false,
        enumerable: false,
        configurable: false
      };
      version5 = "0.0.0-dev";
      deprecate4 = (range, message) => {
        if (range.test(version5)) {
          console.warn(message);
        } else {
          throw new Error(message);
        }
      };
      IS_CID_DEPRECATION3 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/index.js
  var init_src = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/index.js"() {
      init_virtual_process_polyfill();
      init_cid();
      init_varint2();
      init_bytes();
      init_hasher();
      init_digest();
    }
  });

  // node_modules/uint8arrays/node_modules/multiformats/esm/src/basics.js
  var bases, hashes;
  var init_basics = __esm({
    "node_modules/uint8arrays/node_modules/multiformats/esm/src/basics.js"() {
      init_virtual_process_polyfill();
      init_identity();
      init_base2();
      init_base8();
      init_base10();
      init_base16();
      init_base32();
      init_base36();
      init_base58();
      init_base64();
      init_base256emoji();
      init_sha2_browser();
      init_identity2();
      init_raw();
      init_json();
      init_src();
      bases = {
        ...identity_exports,
        ...base2_exports,
        ...base8_exports,
        ...base10_exports,
        ...base16_exports,
        ...base32_exports,
        ...base36_exports,
        ...base58_exports,
        ...base64_exports,
        ...base256emoji_exports
      };
      hashes = {
        ...sha2_browser_exports,
        ...identity_exports2
      };
    }
  });

  // node_modules/uint8arrays/esm/src/util/as-uint8array.js
  function asUint8Array(buf2) {
    if (globalThis.Buffer != null) {
      return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    }
    return buf2;
  }
  var init_as_uint8array = __esm({
    "node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
      init_virtual_process_polyfill();
    }
  });

  // node_modules/uint8arrays/esm/src/alloc.js
  function allocUnsafe2(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
      return asUint8Array(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
  }
  var init_alloc = __esm({
    "node_modules/uint8arrays/esm/src/alloc.js"() {
      init_virtual_process_polyfill();
      init_as_uint8array();
    }
  });

  // node_modules/uint8arrays/esm/src/util/bases.js
  function createCodec(name6, prefix, encode21, decode32) {
    return {
      name: name6,
      prefix,
      encoder: {
        name: name6,
        prefix,
        encode: encode21
      },
      decoder: { decode: decode32 }
    };
  }
  var string, ascii, BASES, bases_default;
  var init_bases = __esm({
    "node_modules/uint8arrays/esm/src/util/bases.js"() {
      init_virtual_process_polyfill();
      init_basics();
      init_alloc();
      string = createCodec("utf8", "u", (buf2) => {
        const decoder = new TextDecoder("utf8");
        return "u" + decoder.decode(buf2);
      }, (str) => {
        const encoder = new TextEncoder();
        return encoder.encode(str.substring(1));
      });
      ascii = createCodec("ascii", "a", (buf2) => {
        let string2 = "a";
        for (let i2 = 0; i2 < buf2.length; i2++) {
          string2 += String.fromCharCode(buf2[i2]);
        }
        return string2;
      }, (str) => {
        str = str.substring(1);
        const buf2 = allocUnsafe2(str.length);
        for (let i2 = 0; i2 < str.length; i2++) {
          buf2[i2] = str.charCodeAt(i2);
        }
        return buf2;
      });
      BASES = {
        utf8: string,
        "utf-8": string,
        hex: bases.base16,
        latin1: ascii,
        ascii,
        binary: ascii,
        ...bases
      };
      bases_default = BASES;
    }
  });

  // node_modules/uint8arrays/esm/src/from-string.js
  var from_string_exports = {};
  __export(from_string_exports, {
    fromString: () => fromString4
  });
  function fromString4(string2, encoding = "utf8") {
    const base7 = bases_default[encoding];
    if (!base7) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
    }
    return base7.decoder.decode(`${base7.prefix}${string2}`);
  }
  var init_from_string = __esm({
    "node_modules/uint8arrays/esm/src/from-string.js"() {
      init_virtual_process_polyfill();
      init_bases();
      init_as_uint8array();
    }
  });

  // node_modules/hamt-sharding/src/bucket.js
  var require_bucket = __commonJS({
    "node_modules/hamt-sharding/src/bucket.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var SparseArray = require_sparse_array();
      var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
      var Bucket3 = class {
        constructor(options, parent, posAtParent = 0) {
          this._options = options;
          this._popCount = 0;
          this._parent = parent;
          this._posAtParent = posAtParent;
          this._children = new SparseArray();
          this.key = null;
        }
        async put(key, value) {
          const place = await this._findNewBucketAndPos(key);
          await place.bucket._putAt(place, key, value);
        }
        async get(key) {
          const child = await this._findChild(key);
          if (child) {
            return child.value;
          }
        }
        async del(key) {
          const place = await this._findPlace(key);
          const child = place.bucket._at(place.pos);
          if (child && child.key === key) {
            place.bucket._delAt(place.pos);
          }
        }
        leafCount() {
          const children = this._children.compactArray();
          return children.reduce((acc, child) => {
            if (child instanceof Bucket3) {
              return acc + child.leafCount();
            }
            return acc + 1;
          }, 0);
        }
        childrenCount() {
          return this._children.length;
        }
        onlyChild() {
          return this._children.get(0);
        }
        *eachLeafSeries() {
          const children = this._children.compactArray();
          for (const child of children) {
            if (child instanceof Bucket3) {
              yield* child.eachLeafSeries();
            } else {
              yield child;
            }
          }
          return [];
        }
        serialize(map, reduce2) {
          const acc = [];
          return reduce2(this._children.reduce((acc2, child, index) => {
            if (child) {
              if (child instanceof Bucket3) {
                acc2.push(child.serialize(map, reduce2));
              } else {
                acc2.push(map(child, index));
              }
            }
            return acc2;
          }, acc));
        }
        asyncTransform(asyncMap, asyncReduce) {
          return asyncTransformBucket(this, asyncMap, asyncReduce);
        }
        toJSON() {
          return this.serialize(mapNode, reduceNodes);
        }
        prettyPrint() {
          return JSON.stringify(this.toJSON(), null, "  ");
        }
        tableSize() {
          return Math.pow(2, this._options.bits);
        }
        async _findChild(key) {
          const result = await this._findPlace(key);
          const child = result.bucket._at(result.pos);
          if (child instanceof Bucket3) {
            return void 0;
          }
          if (child && child.key === key) {
            return child;
          }
        }
        async _findPlace(key) {
          const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
          const index = await hashValue.take(this._options.bits);
          const child = this._children.get(index);
          if (child instanceof Bucket3) {
            return child._findPlace(hashValue);
          }
          return {
            bucket: this,
            pos: index,
            hash: hashValue,
            existingChild: child
          };
        }
        async _findNewBucketAndPos(key) {
          const place = await this._findPlace(key);
          if (place.existingChild && place.existingChild.key !== key) {
            const bucket = new Bucket3(this._options, place.bucket, place.pos);
            place.bucket._putObjectAt(place.pos, bucket);
            const newPlace = await bucket._findPlace(place.existingChild.hash);
            newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
            return bucket._findNewBucketAndPos(place.hash);
          }
          return place;
        }
        _putAt(place, key, value) {
          this._putObjectAt(place.pos, {
            key,
            value,
            hash: place.hash
          });
        }
        _putObjectAt(pos, object) {
          if (!this._children.get(pos)) {
            this._popCount++;
          }
          this._children.set(pos, object);
        }
        _delAt(pos) {
          if (pos === -1) {
            throw new Error("Invalid position");
          }
          if (this._children.get(pos)) {
            this._popCount--;
          }
          this._children.unset(pos);
          this._level();
        }
        _level() {
          if (this._parent && this._popCount <= 1) {
            if (this._popCount === 1) {
              const onlyChild = this._children.find(exists);
              if (onlyChild && !(onlyChild instanceof Bucket3)) {
                const hash = onlyChild.hash;
                hash.untake(this._options.bits);
                const place = {
                  pos: this._posAtParent,
                  hash,
                  bucket: this._parent
                };
                this._parent._putAt(place, onlyChild.key, onlyChild.value);
              }
            } else {
              this._parent._delAt(this._posAtParent);
            }
          }
        }
        _at(index) {
          return this._children.get(index);
        }
      };
      function exists(o2) {
        return Boolean(o2);
      }
      function mapNode(node, index) {
        return node.key;
      }
      function reduceNodes(nodes) {
        return nodes;
      }
      async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
        const output = [];
        for (const child of bucket._children.compactArray()) {
          if (child instanceof Bucket3) {
            await asyncTransformBucket(child, asyncMap, asyncReduce);
          } else {
            const mappedChildren = await asyncMap(child);
            output.push({
              bitField: bucket._children.bitField(),
              children: mappedChildren
            });
          }
        }
        return asyncReduce(output);
      }
      module2.exports = Bucket3;
    }
  });

  // node_modules/hamt-sharding/src/consumable-buffer.js
  var require_consumable_buffer = __commonJS({
    "node_modules/hamt-sharding/src/consumable-buffer.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var START_MASKS = [
        255,
        254,
        252,
        248,
        240,
        224,
        192,
        128
      ];
      var STOP_MASKS = [
        1,
        3,
        7,
        15,
        31,
        63,
        127,
        255
      ];
      module2.exports = class ConsumableBuffer {
        constructor(value) {
          this._value = value;
          this._currentBytePos = value.length - 1;
          this._currentBitPos = 7;
        }
        availableBits() {
          return this._currentBitPos + 1 + this._currentBytePos * 8;
        }
        totalBits() {
          return this._value.length * 8;
        }
        take(bits) {
          let pendingBits = bits;
          let result = 0;
          while (pendingBits && this._haveBits()) {
            const byte = this._value[this._currentBytePos];
            const availableBits = this._currentBitPos + 1;
            const taking = Math.min(availableBits, pendingBits);
            const value = byteBitsToInt(byte, availableBits - taking, taking);
            result = (result << taking) + value;
            pendingBits -= taking;
            this._currentBitPos -= taking;
            if (this._currentBitPos < 0) {
              this._currentBitPos = 7;
              this._currentBytePos--;
            }
          }
          return result;
        }
        untake(bits) {
          this._currentBitPos += bits;
          while (this._currentBitPos > 7) {
            this._currentBitPos -= 8;
            this._currentBytePos += 1;
          }
        }
        _haveBits() {
          return this._currentBytePos >= 0;
        }
      };
      function byteBitsToInt(byte, start, length7) {
        const mask = maskFor(start, length7);
        return (byte & mask) >>> start;
      }
      function maskFor(start, length7) {
        return START_MASKS[start] & STOP_MASKS[Math.min(length7 + start - 1, 7)];
      }
    }
  });

  // node_modules/uint8arrays/esm/src/concat.js
  var concat_exports = {};
  __export(concat_exports, {
    concat: () => concat3
  });
  function concat3(arrays, length7) {
    if (!length7) {
      length7 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = allocUnsafe2(length7);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array(output);
  }
  var init_concat = __esm({
    "node_modules/uint8arrays/esm/src/concat.js"() {
      init_virtual_process_polyfill();
      init_alloc();
      init_as_uint8array();
    }
  });

  // node_modules/hamt-sharding/src/consumable-hash.js
  var require_consumable_hash = __commonJS({
    "node_modules/hamt-sharding/src/consumable-hash.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var ConsumableBuffer = require_consumable_buffer();
      var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
      function wrapHash(hashFn2) {
        function hashing(value) {
          if (value instanceof InfiniteHash) {
            return value;
          } else {
            return new InfiniteHash(value, hashFn2);
          }
        }
        return hashing;
      }
      var InfiniteHash = class {
        constructor(value, hashFn2) {
          if (!(value instanceof Uint8Array)) {
            throw new Error("can only hash Uint8Arrays");
          }
          this._value = value;
          this._hashFn = hashFn2;
          this._depth = -1;
          this._availableBits = 0;
          this._currentBufferIndex = 0;
          this._buffers = [];
        }
        async take(bits) {
          let pendingBits = bits;
          while (this._availableBits < pendingBits) {
            await this._produceMoreBits();
          }
          let result = 0;
          while (pendingBits > 0) {
            const hash = this._buffers[this._currentBufferIndex];
            const available = Math.min(hash.availableBits(), pendingBits);
            const took = hash.take(available);
            result = (result << available) + took;
            pendingBits -= available;
            this._availableBits -= available;
            if (hash.availableBits() === 0) {
              this._currentBufferIndex++;
            }
          }
          return result;
        }
        untake(bits) {
          let pendingBits = bits;
          while (pendingBits > 0) {
            const hash = this._buffers[this._currentBufferIndex];
            const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
            hash.untake(availableForUntake);
            pendingBits -= availableForUntake;
            this._availableBits += availableForUntake;
            if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
              this._depth--;
              this._currentBufferIndex--;
            }
          }
        }
        async _produceMoreBits() {
          this._depth++;
          const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
          const hashValue = await this._hashFn(value);
          const buffer2 = new ConsumableBuffer(hashValue);
          this._buffers.push(buffer2);
          this._availableBits += buffer2.availableBits();
        }
      };
      module2.exports = wrapHash;
      module2.exports.InfiniteHash = InfiniteHash;
    }
  });

  // node_modules/hamt-sharding/src/index.js
  var require_src = __commonJS({
    "node_modules/hamt-sharding/src/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var Bucket3 = require_bucket();
      var wrapHash = require_consumable_hash();
      function createHAMT3(options) {
        if (!options || !options.hashFn) {
          throw new Error("please define an options.hashFn");
        }
        const bucketOptions = {
          bits: options.bits || 8,
          hash: wrapHash(options.hashFn)
        };
        return new Bucket3(bucketOptions);
      }
      module2.exports = {
        createHAMT: createHAMT3,
        Bucket: Bucket3
      };
    }
  });

  // node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
  var require_murmurHash3js = __commonJS({
    "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
      init_virtual_process_polyfill();
      (function(root, undefined2) {
        "use strict";
        var library = {
          "version": "3.0.0",
          "x86": {},
          "x64": {},
          "inputValidation": true
        };
        function _validBytes(bytes) {
          if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
            return false;
          }
          for (var i2 = 0; i2 < bytes.length; i2++) {
            if (!Number.isInteger(bytes[i2]) || bytes[i2] < 0 || bytes[i2] > 255) {
              return false;
            }
          }
          return true;
        }
        function _x86Multiply(m2, n2) {
          return (m2 & 65535) * n2 + (((m2 >>> 16) * n2 & 65535) << 16);
        }
        function _x86Rotl(m2, n2) {
          return m2 << n2 | m2 >>> 32 - n2;
        }
        function _x86Fmix(h2) {
          h2 ^= h2 >>> 16;
          h2 = _x86Multiply(h2, 2246822507);
          h2 ^= h2 >>> 13;
          h2 = _x86Multiply(h2, 3266489909);
          h2 ^= h2 >>> 16;
          return h2;
        }
        function _x64Add(m2, n2) {
          m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
          n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
          var o2 = [0, 0, 0, 0];
          o2[3] += m2[3] + n2[3];
          o2[2] += o2[3] >>> 16;
          o2[3] &= 65535;
          o2[2] += m2[2] + n2[2];
          o2[1] += o2[2] >>> 16;
          o2[2] &= 65535;
          o2[1] += m2[1] + n2[1];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[0] += m2[0] + n2[0];
          o2[0] &= 65535;
          return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
        }
        function _x64Multiply(m2, n2) {
          m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
          n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
          var o2 = [0, 0, 0, 0];
          o2[3] += m2[3] * n2[3];
          o2[2] += o2[3] >>> 16;
          o2[3] &= 65535;
          o2[2] += m2[2] * n2[3];
          o2[1] += o2[2] >>> 16;
          o2[2] &= 65535;
          o2[2] += m2[3] * n2[2];
          o2[1] += o2[2] >>> 16;
          o2[2] &= 65535;
          o2[1] += m2[1] * n2[3];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[1] += m2[2] * n2[2];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[1] += m2[3] * n2[1];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[0] += m2[0] * n2[3] + m2[1] * n2[2] + m2[2] * n2[1] + m2[3] * n2[0];
          o2[0] &= 65535;
          return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
        }
        function _x64Rotl(m2, n2) {
          n2 %= 64;
          if (n2 === 32) {
            return [m2[1], m2[0]];
          } else if (n2 < 32) {
            return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2 | m2[0] >>> 32 - n2];
          } else {
            n2 -= 32;
            return [m2[1] << n2 | m2[0] >>> 32 - n2, m2[0] << n2 | m2[1] >>> 32 - n2];
          }
        }
        function _x64LeftShift(m2, n2) {
          n2 %= 64;
          if (n2 === 0) {
            return m2;
          } else if (n2 < 32) {
            return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2];
          } else {
            return [m2[1] << n2 - 32, 0];
          }
        }
        function _x64Xor(m2, n2) {
          return [m2[0] ^ n2[0], m2[1] ^ n2[1]];
        }
        function _x64Fmix(h2) {
          h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
          h2 = _x64Multiply(h2, [4283543511, 3981806797]);
          h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
          h2 = _x64Multiply(h2, [3301882366, 444984403]);
          h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
          return h2;
        }
        library.x86.hash32 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 4;
          var blocks = bytes.length - remainder;
          var h1 = seed;
          var k1 = 0;
          var c1 = 3432918353;
          var c2 = 461845907;
          for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
            k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 13);
            h1 = _x86Multiply(h1, 5) + 3864292196;
          }
          k1 = 0;
          switch (remainder) {
            case 3:
              k1 ^= bytes[i2 + 2] << 16;
            case 2:
              k1 ^= bytes[i2 + 1] << 8;
            case 1:
              k1 ^= bytes[i2];
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c2);
              h1 ^= k1;
          }
          h1 ^= bytes.length;
          h1 = _x86Fmix(h1);
          return h1 >>> 0;
        };
        library.x86.hash128 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 16;
          var blocks = bytes.length - remainder;
          var h1 = seed;
          var h2 = seed;
          var h3 = seed;
          var h4 = seed;
          var k1 = 0;
          var k2 = 0;
          var k3 = 0;
          var k4 = 0;
          var c1 = 597399067;
          var c2 = 2869860233;
          var c3 = 951274213;
          var c4 = 2716044179;
          for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
            k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
            k2 = bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24;
            k3 = bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24;
            k4 = bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 19);
            h1 += h2;
            h1 = _x86Multiply(h1, 5) + 1444728091;
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
            h2 = _x86Rotl(h2, 17);
            h2 += h3;
            h2 = _x86Multiply(h2, 5) + 197830471;
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
            h3 = _x86Rotl(h3, 15);
            h3 += h4;
            h3 = _x86Multiply(h3, 5) + 2530024501;
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
            h4 = _x86Rotl(h4, 13);
            h4 += h1;
            h4 = _x86Multiply(h4, 5) + 850148119;
          }
          k1 = 0;
          k2 = 0;
          k3 = 0;
          k4 = 0;
          switch (remainder) {
            case 15:
              k4 ^= bytes[i2 + 14] << 16;
            case 14:
              k4 ^= bytes[i2 + 13] << 8;
            case 13:
              k4 ^= bytes[i2 + 12];
              k4 = _x86Multiply(k4, c4);
              k4 = _x86Rotl(k4, 18);
              k4 = _x86Multiply(k4, c1);
              h4 ^= k4;
            case 12:
              k3 ^= bytes[i2 + 11] << 24;
            case 11:
              k3 ^= bytes[i2 + 10] << 16;
            case 10:
              k3 ^= bytes[i2 + 9] << 8;
            case 9:
              k3 ^= bytes[i2 + 8];
              k3 = _x86Multiply(k3, c3);
              k3 = _x86Rotl(k3, 17);
              k3 = _x86Multiply(k3, c4);
              h3 ^= k3;
            case 8:
              k2 ^= bytes[i2 + 7] << 24;
            case 7:
              k2 ^= bytes[i2 + 6] << 16;
            case 6:
              k2 ^= bytes[i2 + 5] << 8;
            case 5:
              k2 ^= bytes[i2 + 4];
              k2 = _x86Multiply(k2, c2);
              k2 = _x86Rotl(k2, 16);
              k2 = _x86Multiply(k2, c3);
              h2 ^= k2;
            case 4:
              k1 ^= bytes[i2 + 3] << 24;
            case 3:
              k1 ^= bytes[i2 + 2] << 16;
            case 2:
              k1 ^= bytes[i2 + 1] << 8;
            case 1:
              k1 ^= bytes[i2];
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c2);
              h1 ^= k1;
          }
          h1 ^= bytes.length;
          h2 ^= bytes.length;
          h3 ^= bytes.length;
          h4 ^= bytes.length;
          h1 += h2;
          h1 += h3;
          h1 += h4;
          h2 += h1;
          h3 += h1;
          h4 += h1;
          h1 = _x86Fmix(h1);
          h2 = _x86Fmix(h2);
          h3 = _x86Fmix(h3);
          h4 = _x86Fmix(h4);
          h1 += h2;
          h1 += h3;
          h1 += h4;
          h2 += h1;
          h3 += h1;
          h4 += h1;
          return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
        };
        library.x64.hash128 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 16;
          var blocks = bytes.length - remainder;
          var h1 = [0, seed];
          var h2 = [0, seed];
          var k1 = [0, 0];
          var k2 = [0, 0];
          var c1 = [2277735313, 289559509];
          var c2 = [1291169091, 658871167];
          for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
            k1 = [bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24, bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24];
            k2 = [bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24, bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24];
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
            h1 = _x64Rotl(h1, 27);
            h1 = _x64Add(h1, h2);
            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
            h2 = _x64Rotl(h2, 31);
            h2 = _x64Add(h2, h1);
            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
          }
          k1 = [0, 0];
          k2 = [0, 0];
          switch (remainder) {
            case 15:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 14]], 48));
            case 14:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 13]], 40));
            case 13:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 12]], 32));
            case 12:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 11]], 24));
            case 11:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 10]], 16));
            case 10:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 9]], 8));
            case 9:
              k2 = _x64Xor(k2, [0, bytes[i2 + 8]]);
              k2 = _x64Multiply(k2, c2);
              k2 = _x64Rotl(k2, 33);
              k2 = _x64Multiply(k2, c1);
              h2 = _x64Xor(h2, k2);
            case 8:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 7]], 56));
            case 7:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 6]], 48));
            case 6:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 5]], 40));
            case 5:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 4]], 32));
            case 4:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 3]], 24));
            case 3:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 2]], 16));
            case 2:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 1]], 8));
            case 1:
              k1 = _x64Xor(k1, [0, bytes[i2]]);
              k1 = _x64Multiply(k1, c1);
              k1 = _x64Rotl(k1, 31);
              k1 = _x64Multiply(k1, c2);
              h1 = _x64Xor(h1, k1);
          }
          h1 = _x64Xor(h1, [0, bytes.length]);
          h2 = _x64Xor(h2, [0, bytes.length]);
          h1 = _x64Add(h1, h2);
          h2 = _x64Add(h2, h1);
          h1 = _x64Fmix(h1);
          h2 = _x64Fmix(h2);
          h1 = _x64Add(h1, h2);
          h2 = _x64Add(h2, h1);
          return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
        };
        if (typeof exports2 !== "undefined") {
          if (typeof module2 !== "undefined" && module2.exports) {
            exports2 = module2.exports = library;
          }
          exports2.murmurHash3 = library;
        } else if (typeof define === "function" && define.amd) {
          define([], function() {
            return library;
          });
        } else {
          library._murmurHash3 = root.murmurHash3;
          library.noConflict = function() {
            root.murmurHash3 = library._murmurHash3;
            library._murmurHash3 = undefined2;
            library.noConflict = undefined2;
            return library;
          };
          root.murmurHash3 = library;
        }
      })(exports2);
    }
  });

  // node_modules/murmurhash3js-revisited/index.js
  var require_murmurhash3js_revisited = __commonJS({
    "node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      module2.exports = require_murmurHash3js();
    }
  });

  // node_modules/it-last/index.js
  var require_it_last = __commonJS({
    "node_modules/it-last/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var last2 = async (source) => {
        let res;
        for await (const entry of source) {
          res = entry;
        }
        return res;
      };
      module2.exports = last2;
    }
  });

  // node_modules/it-batch/index.js
  var require_it_batch = __commonJS({
    "node_modules/it-batch/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      async function* batch3(source, size = 1) {
        let things = [];
        if (size < 1) {
          size = 1;
        }
        for await (const thing of source) {
          things.push(thing);
          while (things.length >= size) {
            yield things.slice(0, size);
            things = things.slice(size);
          }
        }
        while (things.length) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      }
      module2.exports = batch3;
    }
  });

  // node_modules/it-parallel-batch/index.js
  var require_it_parallel_batch = __commonJS({
    "node_modules/it-parallel-batch/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var batch3 = require_it_batch();
      async function* parallelBatch3(source, size = 1) {
        for await (const tasks of batch3(source, size)) {
          const things = tasks.map(
            (p2) => {
              return p2().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
            }
          );
          for (let i2 = 0; i2 < things.length; i2++) {
            const result = await things[i2];
            if (result.ok) {
              yield result.value;
            } else {
              throw result.err;
            }
          }
        }
      }
      module2.exports = parallelBatch3;
    }
  });

  // node_modules/is-plain-obj/index.js
  var require_is_plain_obj = __commonJS({
    "node_modules/is-plain-obj/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      module2.exports = (value) => {
        if (Object.prototype.toString.call(value) !== "[object Object]") {
          return false;
        }
        const prototype = Object.getPrototypeOf(value);
        return prototype === null || prototype === Object.prototype;
      };
    }
  });

  // node_modules/merge-options/index.js
  var require_merge_options = __commonJS({
    "node_modules/merge-options/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var isOptionObject = require_is_plain_obj();
      var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
      var { propertyIsEnumerable } = Object;
      var defineProperty = (object, name6, value) => Object.defineProperty(object, name6, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
      var globalThis2 = exports2;
      var defaultMergeOptions = {
        concatArrays: false,
        ignoreUndefined: false
      };
      var getEnumerableOwnPropertyKeys = (value) => {
        const keys = [];
        for (const key in value) {
          if (hasOwnProperty2.call(value, key)) {
            keys.push(key);
          }
        }
        if (Object.getOwnPropertySymbols) {
          const symbols = Object.getOwnPropertySymbols(value);
          for (const symbol of symbols) {
            if (propertyIsEnumerable.call(value, symbol)) {
              keys.push(symbol);
            }
          }
        }
        return keys;
      };
      function clone(value) {
        if (Array.isArray(value)) {
          return cloneArray(value);
        }
        if (isOptionObject(value)) {
          return cloneOptionObject(value);
        }
        return value;
      }
      function cloneArray(array) {
        const result = array.slice(0, 0);
        getEnumerableOwnPropertyKeys(array).forEach((key) => {
          defineProperty(result, key, clone(array[key]));
        });
        return result;
      }
      function cloneOptionObject(object) {
        const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
        getEnumerableOwnPropertyKeys(object).forEach((key) => {
          defineProperty(result, key, clone(object[key]));
        });
        return result;
      }
      var mergeKeys = (merged, source, keys, config3) => {
        keys.forEach((key) => {
          if (typeof source[key] === "undefined" && config3.ignoreUndefined) {
            return;
          }
          if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
            defineProperty(merged, key, merge(merged[key], source[key], config3));
          } else {
            defineProperty(merged, key, clone(source[key]));
          }
        });
        return merged;
      };
      var concatArrays = (merged, source, config3) => {
        let result = merged.slice(0, 0);
        let resultIndex = 0;
        [merged, source].forEach((array) => {
          const indices = [];
          for (let k2 = 0; k2 < array.length; k2++) {
            if (!hasOwnProperty2.call(array, k2)) {
              continue;
            }
            indices.push(String(k2));
            if (array === merged) {
              defineProperty(result, resultIndex++, array[k2]);
            } else {
              defineProperty(result, resultIndex++, clone(array[k2]));
            }
          }
          result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config3);
        });
        return result;
      };
      function merge(merged, source, config3) {
        if (config3.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
          return concatArrays(merged, source, config3);
        }
        if (!isOptionObject(source) || !isOptionObject(merged)) {
          return clone(source);
        }
        return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config3);
      }
      module2.exports = function(...options) {
        const config3 = merge(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
        let merged = { _: {} };
        for (const option of options) {
          if (option === void 0) {
            continue;
          }
          if (!isOptionObject(option)) {
            throw new TypeError("`" + option + "` is not an Option Object");
          }
          merged = merge(merged, { _: option }, config3);
        }
        return merged._;
      };
    }
  });

  // node_modules/it-all/index.js
  var require_it_all = __commonJS({
    "node_modules/it-all/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var all2 = async (source) => {
        const arr = [];
        for await (const entry of source) {
          arr.push(entry);
        }
        return arr;
      };
      module2.exports = all2;
    }
  });

  // node_modules/bl/BufferList.js
  var require_BufferList = __commonJS({
    "node_modules/bl/BufferList.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      var { Buffer: Buffer3 } = require_buffer();
      var symbol = Symbol.for("BufferList");
      function BufferList3(buf2) {
        if (!(this instanceof BufferList3)) {
          return new BufferList3(buf2);
        }
        BufferList3._init.call(this, buf2);
      }
      BufferList3._init = function _init(buf2) {
        Object.defineProperty(this, symbol, { value: true });
        this._bufs = [];
        this.length = 0;
        if (buf2) {
          this.append(buf2);
        }
      };
      BufferList3.prototype._new = function _new(buf2) {
        return new BufferList3(buf2);
      };
      BufferList3.prototype._offset = function _offset(offset) {
        if (offset === 0) {
          return [0, 0];
        }
        let tot = 0;
        for (let i2 = 0; i2 < this._bufs.length; i2++) {
          const _t = tot + this._bufs[i2].length;
          if (offset < _t || i2 === this._bufs.length - 1) {
            return [i2, offset - tot];
          }
          tot = _t;
        }
      };
      BufferList3.prototype._reverseOffset = function(blOffset) {
        const bufferId = blOffset[0];
        let offset = blOffset[1];
        for (let i2 = 0; i2 < bufferId; i2++) {
          offset += this._bufs[i2].length;
        }
        return offset;
      };
      BufferList3.prototype.get = function get2(index) {
        if (index > this.length || index < 0) {
          return void 0;
        }
        const offset = this._offset(index);
        return this._bufs[offset[0]][offset[1]];
      };
      BufferList3.prototype.slice = function slice3(start, end) {
        if (typeof start === "number" && start < 0) {
          start += this.length;
        }
        if (typeof end === "number" && end < 0) {
          end += this.length;
        }
        return this.copy(null, 0, start, end);
      };
      BufferList3.prototype.copy = function copy2(dst, dstStart, srcStart, srcEnd) {
        if (typeof srcStart !== "number" || srcStart < 0) {
          srcStart = 0;
        }
        if (typeof srcEnd !== "number" || srcEnd > this.length) {
          srcEnd = this.length;
        }
        if (srcStart >= this.length) {
          return dst || Buffer3.alloc(0);
        }
        if (srcEnd <= 0) {
          return dst || Buffer3.alloc(0);
        }
        const copy3 = !!dst;
        const off3 = this._offset(srcStart);
        const len = srcEnd - srcStart;
        let bytes = len;
        let bufoff = copy3 && dstStart || 0;
        let start = off3[1];
        if (srcStart === 0 && srcEnd === this.length) {
          if (!copy3) {
            return this._bufs.length === 1 ? this._bufs[0] : Buffer3.concat(this._bufs, this.length);
          }
          for (let i2 = 0; i2 < this._bufs.length; i2++) {
            this._bufs[i2].copy(dst, bufoff);
            bufoff += this._bufs[i2].length;
          }
          return dst;
        }
        if (bytes <= this._bufs[off3[0]].length - start) {
          return copy3 ? this._bufs[off3[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off3[0]].slice(start, start + bytes);
        }
        if (!copy3) {
          dst = Buffer3.allocUnsafe(len);
        }
        for (let i2 = off3[0]; i2 < this._bufs.length; i2++) {
          const l2 = this._bufs[i2].length - start;
          if (bytes > l2) {
            this._bufs[i2].copy(dst, bufoff, start);
            bufoff += l2;
          } else {
            this._bufs[i2].copy(dst, bufoff, start, start + bytes);
            bufoff += l2;
            break;
          }
          bytes -= l2;
          if (start) {
            start = 0;
          }
        }
        if (dst.length > bufoff)
          return dst.slice(0, bufoff);
        return dst;
      };
      BufferList3.prototype.shallowSlice = function shallowSlice(start, end) {
        start = start || 0;
        end = typeof end !== "number" ? this.length : end;
        if (start < 0) {
          start += this.length;
        }
        if (end < 0) {
          end += this.length;
        }
        if (start === end) {
          return this._new();
        }
        const startOffset = this._offset(start);
        const endOffset = this._offset(end);
        const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
        if (endOffset[1] === 0) {
          buffers.pop();
        } else {
          buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
        }
        if (startOffset[1] !== 0) {
          buffers[0] = buffers[0].slice(startOffset[1]);
        }
        return this._new(buffers);
      };
      BufferList3.prototype.toString = function toString6(encoding, start, end) {
        return this.slice(start, end).toString(encoding);
      };
      BufferList3.prototype.consume = function consume(bytes) {
        bytes = Math.trunc(bytes);
        if (Number.isNaN(bytes) || bytes <= 0)
          return this;
        while (this._bufs.length) {
          if (bytes >= this._bufs[0].length) {
            bytes -= this._bufs[0].length;
            this.length -= this._bufs[0].length;
            this._bufs.shift();
          } else {
            this._bufs[0] = this._bufs[0].slice(bytes);
            this.length -= bytes;
            break;
          }
        }
        return this;
      };
      BufferList3.prototype.duplicate = function duplicate() {
        const copy2 = this._new();
        for (let i2 = 0; i2 < this._bufs.length; i2++) {
          copy2.append(this._bufs[i2]);
        }
        return copy2;
      };
      BufferList3.prototype.append = function append(buf2) {
        if (buf2 == null) {
          return this;
        }
        if (buf2.buffer) {
          this._appendBuffer(Buffer3.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
        } else if (Array.isArray(buf2)) {
          for (let i2 = 0; i2 < buf2.length; i2++) {
            this.append(buf2[i2]);
          }
        } else if (this._isBufferList(buf2)) {
          for (let i2 = 0; i2 < buf2._bufs.length; i2++) {
            this.append(buf2._bufs[i2]);
          }
        } else {
          if (typeof buf2 === "number") {
            buf2 = buf2.toString();
          }
          this._appendBuffer(Buffer3.from(buf2));
        }
        return this;
      };
      BufferList3.prototype._appendBuffer = function appendBuffer(buf2) {
        this._bufs.push(buf2);
        this.length += buf2.length;
      };
      BufferList3.prototype.indexOf = function(search, offset, encoding) {
        if (encoding === void 0 && typeof offset === "string") {
          encoding = offset;
          offset = void 0;
        }
        if (typeof search === "function" || Array.isArray(search)) {
          throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
        } else if (typeof search === "number") {
          search = Buffer3.from([search]);
        } else if (typeof search === "string") {
          search = Buffer3.from(search, encoding);
        } else if (this._isBufferList(search)) {
          search = search.slice();
        } else if (Array.isArray(search.buffer)) {
          search = Buffer3.from(search.buffer, search.byteOffset, search.byteLength);
        } else if (!Buffer3.isBuffer(search)) {
          search = Buffer3.from(search);
        }
        offset = Number(offset || 0);
        if (isNaN(offset)) {
          offset = 0;
        }
        if (offset < 0) {
          offset = this.length + offset;
        }
        if (offset < 0) {
          offset = 0;
        }
        if (search.length === 0) {
          return offset > this.length ? this.length : offset;
        }
        const blOffset = this._offset(offset);
        let blIndex = blOffset[0];
        let buffOffset = blOffset[1];
        for (; blIndex < this._bufs.length; blIndex++) {
          const buff = this._bufs[blIndex];
          while (buffOffset < buff.length) {
            const availableWindow = buff.length - buffOffset;
            if (availableWindow >= search.length) {
              const nativeSearchResult = buff.indexOf(search, buffOffset);
              if (nativeSearchResult !== -1) {
                return this._reverseOffset([blIndex, nativeSearchResult]);
              }
              buffOffset = buff.length - search.length + 1;
            } else {
              const revOffset = this._reverseOffset([blIndex, buffOffset]);
              if (this._match(revOffset, search)) {
                return revOffset;
              }
              buffOffset++;
            }
          }
          buffOffset = 0;
        }
        return -1;
      };
      BufferList3.prototype._match = function(offset, search) {
        if (this.length - offset < search.length) {
          return false;
        }
        for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
          if (this.get(offset + searchOffset) !== search[searchOffset]) {
            return false;
          }
        }
        return true;
      };
      (function() {
        const methods = {
          readDoubleBE: 8,
          readDoubleLE: 8,
          readFloatBE: 4,
          readFloatLE: 4,
          readInt32BE: 4,
          readInt32LE: 4,
          readUInt32BE: 4,
          readUInt32LE: 4,
          readInt16BE: 2,
          readInt16LE: 2,
          readUInt16BE: 2,
          readUInt16LE: 2,
          readInt8: 1,
          readUInt8: 1,
          readIntBE: null,
          readIntLE: null,
          readUIntBE: null,
          readUIntLE: null
        };
        for (const m2 in methods) {
          (function(m3) {
            if (methods[m3] === null) {
              BufferList3.prototype[m3] = function(offset, byteLength2) {
                return this.slice(offset, offset + byteLength2)[m3](0, byteLength2);
              };
            } else {
              BufferList3.prototype[m3] = function(offset = 0) {
                return this.slice(offset, offset + methods[m3])[m3](0);
              };
            }
          })(m2);
        }
      })();
      BufferList3.prototype._isBufferList = function _isBufferList(b2) {
        return b2 instanceof BufferList3 || BufferList3.isBufferList(b2);
      };
      BufferList3.isBufferList = function isBufferList(b2) {
        return b2 != null && b2[symbol];
      };
      module2.exports = BufferList3;
    }
  });

  // node_modules/rabin-wasm/src/rabin.js
  var require_rabin = __commonJS({
    "node_modules/rabin-wasm/src/rabin.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var Rabin = class {
        constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
          this.bits = bits;
          this.min = min;
          this.max = max;
          this.asModule = asModule;
          this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
          this.polynomial = polynomial;
        }
        fingerprint(buf2) {
          const {
            __retain,
            __release,
            __allocArray,
            __getInt32Array,
            Int32Array_ID,
            Uint8Array_ID
          } = this.asModule;
          const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
          const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
          const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
          const out = this.rabin.fingerprint(pointer, lengthsPtr);
          const processed = __getInt32Array(out);
          __release(pointer);
          __release(lengthsPtr);
          const end = processed.indexOf(0);
          return end >= 0 ? processed.subarray(0, end) : processed;
        }
      };
      module2.exports = Rabin;
    }
  });

  // node_modules/@assemblyscript/loader/index.js
  var require_loader = __commonJS({
    "node_modules/@assemblyscript/loader/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      var ID_OFFSET = -8;
      var SIZE_OFFSET = -4;
      var ARRAYBUFFER_ID = 0;
      var STRING_ID = 1;
      var ARRAYBUFFERVIEW = 1 << 0;
      var ARRAY = 1 << 1;
      var SET = 1 << 2;
      var MAP = 1 << 3;
      var VAL_ALIGN_OFFSET = 5;
      var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
      var VAL_SIGNED = 1 << 10;
      var VAL_FLOAT = 1 << 11;
      var VAL_NULLABLE = 1 << 12;
      var VAL_MANAGED = 1 << 13;
      var KEY_ALIGN_OFFSET = 14;
      var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
      var KEY_SIGNED = 1 << 19;
      var KEY_FLOAT = 1 << 20;
      var KEY_NULLABLE = 1 << 21;
      var KEY_MANAGED = 1 << 22;
      var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
      var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
      var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
      var ARRAYBUFFERVIEW_SIZE = 12;
      var ARRAY_LENGTH_OFFSET = 12;
      var ARRAY_SIZE = 16;
      var BIGINT = typeof BigUint64Array !== "undefined";
      var THIS = Symbol();
      var CHUNKSIZE = 1024;
      function getStringImpl(buffer2, ptr) {
        const U32 = new Uint32Array(buffer2);
        const U16 = new Uint16Array(buffer2);
        var length7 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
        var offset = ptr >>> 1;
        if (length7 <= CHUNKSIZE)
          return String.fromCharCode.apply(String, U16.subarray(offset, offset + length7));
        const parts = [];
        do {
          const last2 = U16[offset + CHUNKSIZE - 1];
          const size = last2 >= 55296 && last2 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
          parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
          length7 -= size;
        } while (length7 > CHUNKSIZE);
        return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length7));
      }
      function preInstantiate(imports) {
        const baseModule = {};
        function getString(memory, ptr) {
          if (!memory)
            return "<yet unknown>";
          return getStringImpl(memory.buffer, ptr);
        }
        const env3 = imports.env = imports.env || {};
        env3.abort = env3.abort || function abort(mesg, file, line, colm) {
          const memory = baseModule.memory || env3.memory;
          throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
        };
        env3.trace = env3.trace || function trace(mesg, n2) {
          const memory = baseModule.memory || env3.memory;
          console.log("trace: " + getString(memory, mesg) + (n2 ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n2).join(", "));
        };
        imports.Math = imports.Math || Math;
        imports.Date = imports.Date || Date;
        return baseModule;
      }
      function postInstantiate(baseModule, instance) {
        const rawExports = instance.exports;
        const memory = rawExports.memory;
        const table = rawExports.table;
        const alloc3 = rawExports["__alloc"];
        const retain = rawExports["__retain"];
        const rttiBase = rawExports["__rtti_base"] || ~0;
        function getInfo(id) {
          const U32 = new Uint32Array(memory.buffer);
          const count = U32[rttiBase >>> 2];
          if ((id >>>= 0) >= count)
            throw Error("invalid id: " + id);
          return U32[(rttiBase + 4 >>> 2) + id * 2];
        }
        function getBase(id) {
          const U32 = new Uint32Array(memory.buffer);
          const count = U32[rttiBase >>> 2];
          if ((id >>>= 0) >= count)
            throw Error("invalid id: " + id);
          return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
        }
        function getValueAlign(info) {
          return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
        }
        function getKeyAlign(info) {
          return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
        }
        function __allocString(str) {
          const length7 = str.length;
          const ptr = alloc3(length7 << 1, STRING_ID);
          const U16 = new Uint16Array(memory.buffer);
          for (var i2 = 0, p2 = ptr >>> 1; i2 < length7; ++i2)
            U16[p2 + i2] = str.charCodeAt(i2);
          return ptr;
        }
        baseModule.__allocString = __allocString;
        function __getString(ptr) {
          const buffer2 = memory.buffer;
          const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
          if (id !== STRING_ID)
            throw Error("not a string: " + ptr);
          return getStringImpl(buffer2, ptr);
        }
        baseModule.__getString = __getString;
        function getView(alignLog2, signed, float) {
          const buffer2 = memory.buffer;
          if (float) {
            switch (alignLog2) {
              case 2:
                return new Float32Array(buffer2);
              case 3:
                return new Float64Array(buffer2);
            }
          } else {
            switch (alignLog2) {
              case 0:
                return new (signed ? Int8Array : Uint8Array)(buffer2);
              case 1:
                return new (signed ? Int16Array : Uint16Array)(buffer2);
              case 2:
                return new (signed ? Int32Array : Uint32Array)(buffer2);
              case 3:
                return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
            }
          }
          throw Error("unsupported align: " + alignLog2);
        }
        function __allocArray(id, values) {
          const info = getInfo(id);
          if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
            throw Error("not an array: " + id + " @ " + info);
          const align = getValueAlign(info);
          const length7 = values.length;
          const buf2 = alloc3(length7 << align, ARRAYBUFFER_ID);
          const arr = alloc3(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
          const U32 = new Uint32Array(memory.buffer);
          U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
          U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
          U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length7 << align;
          if (info & ARRAY)
            U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length7;
          const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
          if (info & VAL_MANAGED) {
            for (let i2 = 0; i2 < length7; ++i2)
              view[(buf2 >>> align) + i2] = retain(values[i2]);
          } else {
            view.set(values, buf2 >>> align);
          }
          return arr;
        }
        baseModule.__allocArray = __allocArray;
        function __getArrayView(arr) {
          const U32 = new Uint32Array(memory.buffer);
          const id = U32[arr + ID_OFFSET >>> 2];
          const info = getInfo(id);
          if (!(info & ARRAYBUFFERVIEW))
            throw Error("not an array: " + id);
          const align = getValueAlign(info);
          var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
          const length7 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
          return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length7);
        }
        baseModule.__getArrayView = __getArrayView;
        function __getArray(arr) {
          const input = __getArrayView(arr);
          const len = input.length;
          const out = new Array(len);
          for (let i2 = 0; i2 < len; i2++)
            out[i2] = input[i2];
          return out;
        }
        baseModule.__getArray = __getArray;
        function __getArrayBuffer(ptr) {
          const buffer2 = memory.buffer;
          const length7 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
          return buffer2.slice(ptr, ptr + length7);
        }
        baseModule.__getArrayBuffer = __getArrayBuffer;
        function getTypedArray(Type2, alignLog2, ptr) {
          return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
        }
        function getTypedArrayView(Type2, alignLog2, ptr) {
          const buffer2 = memory.buffer;
          const U32 = new Uint32Array(buffer2);
          const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
          return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
        }
        baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
        baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
        baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
        baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
        baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
        baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
        baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
        baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
        baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
        baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
        baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
        baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
        baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
        baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
        if (BIGINT) {
          baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
          baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
          baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
          baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
        }
        baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
        baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
        baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
        baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
        function __instanceof(ptr, baseId) {
          const U32 = new Uint32Array(memory.buffer);
          var id = U32[ptr + ID_OFFSET >>> 2];
          if (id <= U32[rttiBase >>> 2]) {
            do
              if (id == baseId)
                return true;
            while (id = getBase(id));
          }
          return false;
        }
        baseModule.__instanceof = __instanceof;
        baseModule.memory = baseModule.memory || memory;
        baseModule.table = baseModule.table || table;
        return demangle(rawExports, baseModule);
      }
      function isResponse(o2) {
        return typeof Response !== "undefined" && o2 instanceof Response;
      }
      async function instantiate(source, imports) {
        if (isResponse(source = await source))
          return instantiateStreaming(source, imports);
        return postInstantiate(
          preInstantiate(imports || (imports = {})),
          await WebAssembly.instantiate(
            source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source),
            imports
          )
        );
      }
      exports2.instantiate = instantiate;
      function instantiateSync(source, imports) {
        return postInstantiate(
          preInstantiate(imports || (imports = {})),
          new WebAssembly.Instance(
            source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
            imports
          )
        );
      }
      exports2.instantiateSync = instantiateSync;
      async function instantiateStreaming(source, imports) {
        if (!WebAssembly.instantiateStreaming) {
          return instantiate(
            isResponse(source = await source) ? source.arrayBuffer() : source,
            imports
          );
        }
        return postInstantiate(
          preInstantiate(imports || (imports = {})),
          (await WebAssembly.instantiateStreaming(source, imports)).instance
        );
      }
      exports2.instantiateStreaming = instantiateStreaming;
      function demangle(exports3, baseModule) {
        var module3 = baseModule ? Object.create(baseModule) : {};
        var setArgumentsLength = exports3["__argumentsLength"] ? function(length7) {
          exports3["__argumentsLength"].value = length7;
        } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
        };
        for (let internalName in exports3) {
          if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
            continue;
          const elem = exports3[internalName];
          let parts = internalName.split(".");
          let curr = module3;
          while (parts.length > 1) {
            let part = parts.shift();
            if (!Object.prototype.hasOwnProperty.call(curr, part))
              curr[part] = {};
            curr = curr[part];
          }
          let name6 = parts[0];
          let hash = name6.indexOf("#");
          if (hash >= 0) {
            let className = name6.substring(0, hash);
            let classElem = curr[className];
            if (typeof classElem === "undefined" || !classElem.prototype) {
              let ctor = function(...args) {
                return ctor.wrap(ctor.prototype.constructor(0, ...args));
              };
              ctor.prototype = {
                valueOf: function valueOf() {
                  return this[THIS];
                }
              };
              ctor.wrap = function(thisValue) {
                return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
              };
              if (classElem)
                Object.getOwnPropertyNames(classElem).forEach(
                  (name7) => Object.defineProperty(ctor, name7, Object.getOwnPropertyDescriptor(classElem, name7))
                );
              curr[className] = ctor;
            }
            name6 = name6.substring(hash + 1);
            curr = curr[className].prototype;
            if (/^(get|set):/.test(name6)) {
              if (!Object.prototype.hasOwnProperty.call(curr, name6 = name6.substring(4))) {
                let getter = exports3[internalName.replace("set:", "get:")];
                let setter = exports3[internalName.replace("get:", "set:")];
                Object.defineProperty(curr, name6, {
                  get: function() {
                    return getter(this[THIS]);
                  },
                  set: function(value) {
                    setter(this[THIS], value);
                  },
                  enumerable: true
                });
              }
            } else {
              if (name6 === "constructor") {
                (curr[name6] = (...args) => {
                  setArgumentsLength(args.length);
                  return elem(...args);
                }).original = elem;
              } else {
                (curr[name6] = function(...args) {
                  setArgumentsLength(args.length);
                  return elem(this[THIS], ...args);
                }).original = elem;
              }
            }
          } else {
            if (/^(get|set):/.test(name6)) {
              if (!Object.prototype.hasOwnProperty.call(curr, name6 = name6.substring(4))) {
                Object.defineProperty(curr, name6, {
                  get: exports3[internalName.replace("set:", "get:")],
                  set: exports3[internalName.replace("get:", "set:")],
                  enumerable: true
                });
              }
            } else if (typeof elem === "function" && elem !== setArgumentsLength) {
              (curr[name6] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              curr[name6] = elem;
            }
          }
        }
        return module3;
      }
      exports2.demangle = demangle;
    }
  });

  // node_modules/rabin-wasm/dist/rabin-wasm.js
  var require_rabin_wasm = __commonJS({
    "node_modules/rabin-wasm/dist/rabin-wasm.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var { instantiate } = require_loader();
      loadWebAssembly.supported = typeof WebAssembly !== "undefined";
      function loadWebAssembly(imp = {}) {
        if (!loadWebAssembly.supported)
          return null;
        var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
        return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
      }
      module2.exports = loadWebAssembly;
    }
  });

  // node_modules/rabin-wasm/src/index.js
  var require_src2 = __commonJS({
    "node_modules/rabin-wasm/src/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      var Rabin = require_rabin();
      var getRabin = require_rabin_wasm();
      var create8 = async (avg, min, max, windowSize, polynomial) => {
        const compiled = await getRabin();
        return new Rabin(compiled, avg, min, max, windowSize, polynomial);
      };
      module2.exports = {
        Rabin,
        create: create8
      };
    }
  });

  // src/index.js
  init_virtual_process_polyfill();

  // src/encoder.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/bases/base64.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/bases/base.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/vendor/base-x.js
  init_virtual_process_polyfill();
  function base(ALPHABET, name6) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
      BASE_MAP[j2] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET.length; i2++) {
      var x2 = ALPHABET.charAt(i2);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode21(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length7 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length7) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        pbegin++;
      }
      var it2 = size - length7;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length7 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length7) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length7;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j3 = zeroes;
      while (it4 !== size) {
        vch[j3++] = b256[it4++];
      }
      return vch;
    }
    function decode32(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name6} character`);
    }
    return {
      encode: encode21,
      decodeUnsafe,
      decode: decode32
    };
  }
  var src = base;
  var _brrp__multiformats_scope_baseX = src;
  var base_x_default = _brrp__multiformats_scope_baseX;

  // node_modules/multiformats/src/bytes.js
  init_virtual_process_polyfill();
  var empty = new Uint8Array(0);
  var equals = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce = (o2) => {
    if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
      return o2;
    if (o2 instanceof ArrayBuffer)
      return new Uint8Array(o2);
    if (ArrayBuffer.isView(o2)) {
      return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };

  // node_modules/multiformats/src/bases/interface.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/bases/base.js
  var Encoder = class {
    constructor(name6, prefix, baseEncode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder = class {
    constructor(name6, prefix, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or(this, decoder);
    }
  };
  var ComposedDecoder = class {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or = (left, right) => new ComposedDecoder({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  var Codec = class {
    constructor(name6, prefix, baseEncode, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name6, prefix, baseEncode);
      this.decoder = new Decoder(name6, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from = ({ name: name6, prefix, encode: encode21, decode: decode32 }) => new Codec(name6, prefix, encode21, decode32);
  var baseX = ({ prefix, name: name6, alphabet: alphabet2 }) => {
    const { encode: encode21, decode: decode32 } = base_x_default(alphabet2, name6);
    return from({
      prefix,
      name: name6,
      encode: encode21,
      decode: (text) => coerce(decode32(text))
    });
  };
  var decode = (string2, alphabet2, bitsPerChar, name6) => {
    const codes = {};
    for (let i2 = 0; i2 < alphabet2.length; ++i2) {
      codes[alphabet2[i2]] = i2;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i2 = 0; i2 < end; ++i2) {
      const value = codes[string2[i2]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name6} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode = (data, alphabet2, bitsPerChar) => {
    const pad2 = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      buffer2 = buffer2 << 8 | data[i2];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer2 >> bits];
      }
    }
    if (bits) {
      out += alphabet2[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad2) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from({
      prefix,
      name: name6,
      encode(input) {
        return encode(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode(input, alphabet2, bitsPerChar, name6);
      }
    });
  };

  // node_modules/multiformats/src/bases/base64.js
  var base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // src/encoder.js
  var textEncoder = new TextEncoder();
  var textDecoder = new TextDecoder();
  var Encoder2 = class {
    static base64UrlToBytes(base64urlString) {
      const content = base64url.baseDecode(base64urlString);
      return content;
    }
    static base64UrlToObject(base64urlString) {
      const payloadBytes = base64url.baseDecode(base64urlString);
      const payloadString = Encoder2.bytesToString(payloadBytes);
      const payloadObject = JSON.parse(payloadString);
      return payloadObject;
    }
    static bytesToBase64Url(bytes) {
      const base64UrlString = base64url.baseEncode(bytes);
      return base64UrlString;
    }
    static bytesToString(content) {
      const bytes = textDecoder.decode(content);
      return bytes;
    }
    static objectToBytes(obj) {
      const objectString = JSON.stringify(obj);
      const objectBytes = textEncoder.encode(objectString);
      return objectBytes;
    }
    static stringToBase64Url(content) {
      const bytes = textEncoder.encode(content);
      const base64UrlString = base64url.baseEncode(bytes);
      return base64UrlString;
    }
    static stringToBytes(content) {
      const bytes = textEncoder.encode(content);
      return bytes;
    }
  };

  // src/block-store.js
  init_virtual_process_polyfill();
  var import_level = __toESM(require_browser(), 1);
  var _db, _sleep, sleep_fn;
  var _Blockstore = class {
    constructor(location) {
      __privateAdd(this, _db, void 0);
      __privateSet(this, _db, new import_level.Level(location, { keyEncoding: "utf8", valueEncoding: "binary" }));
    }
    async open() {
      var _a;
      while (__privateGet(this, _db).status === "opening" || __privateGet(this, _db).status === "closing") {
        await __privateMethod(_a = _Blockstore, _sleep, sleep_fn).call(_a, 200);
      }
      if (__privateGet(this, _db).status === "open") {
        return;
      }
      return __privateGet(this, _db).open();
    }
    async close() {
      var _a;
      while (__privateGet(this, _db).status === "opening" || __privateGet(this, _db).status === "closing") {
        await __privateMethod(_a = _Blockstore, _sleep, sleep_fn).call(_a, 200);
      }
      if (__privateGet(this, _db).status === "closed") {
        return;
      }
      return __privateGet(this, _db).close();
    }
    put(key, val, _ctx) {
      return __privateGet(this, _db).put(key.toString(), val);
    }
    async get(key, _options) {
      try {
        const val = await __privateGet(this, _db).get(key.toString());
        return val;
      } catch (e2) {
        if (e2.code === "LEVEL_NOT_FOUND") {
          return void 0;
        } else {
          throw e2;
        }
      }
    }
    async has(key, _options) {
      return !!await this.get(key);
    }
    delete(key, _options) {
      return __privateGet(this, _db).del(key.toString());
    }
    async *putMany(source, options) {
      for await (const entry of source) {
        await this.put(entry.key, entry.value, options);
        yield entry;
      }
    }
    async *getMany(source, _options) {
      for await (const key of source) {
        yield this.get(key);
      }
    }
    async *deleteMany(source, options) {
      for await (const key of source) {
        await this.delete(key, options);
        yield key;
      }
    }
    clear() {
      return __privateGet(this, _db).clear();
    }
    batch() {
      throw new Error("not implemented");
    }
    query(_query, _options) {
      throw new Error("not implemented");
    }
    queryKeys(_query, _options) {
      throw new Error("not implemented");
    }
  };
  var Blockstore = _Blockstore;
  _db = new WeakMap();
  _sleep = new WeakSet();
  sleep_fn = function(durationInMillisecond) {
    return new Promise((resolve5) => setTimeout(resolve5, durationInMillisecond));
  };
  __privateAdd(Blockstore, _sleep);

  // src/message-store.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/block.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/index.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/cid.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/varint.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/vendor/varint.js
  init_virtual_process_polyfill();
  var encode_1 = encode2;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode2(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode2.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode2 = read2;
  var MSB$1 = 128;
  var REST$1 = 127;
  function read2(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
    do {
      if (counter >= l2) {
        read2.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b2 = buf2[counter++];
      res += shift < 28 ? (b2 & REST$1) << shift : (b2 & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b2 >= MSB$1);
    read2.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode2,
    encodingLength: length
  };
  var _brrp_varint = varint;
  var varint_default = _brrp_varint;

  // node_modules/multiformats/src/varint.js
  var decode3 = (data, offset = 0) => {
    const code8 = varint_default.decode(data, offset);
    return [code8, varint_default.decode.bytes];
  };
  var encodeTo = (int, target, offset = 0) => {
    varint_default.encode(int, target, offset);
    return target;
  };
  var encodingLength = (int) => {
    return varint_default.encodingLength(int);
  };

  // node_modules/multiformats/src/hashes/digest.js
  init_virtual_process_polyfill();
  var create = (code8, digest3) => {
    const size = digest3.byteLength;
    const sizeOffset = encodingLength(code8);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code8, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest3, digestOffset);
    return new Digest(code8, size, digest3, bytes);
  };
  var decode4 = (multihash) => {
    const bytes = coerce(multihash);
    const [code8, sizeOffset] = decode3(bytes);
    const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
    const digest3 = bytes.subarray(sizeOffset + digestOffset);
    if (digest3.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code8, size, digest3, bytes);
  };
  var equals3 = (a2, b2) => {
    if (a2 === b2) {
      return true;
    } else {
      const data = b2;
      return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals(a2.bytes, data.bytes);
    }
  };
  var Digest = class {
    constructor(code8, size, digest3, bytes) {
      this.code = code8;
      this.size = size;
      this.digest = digest3;
      this.bytes = bytes;
    }
  };

  // node_modules/multiformats/src/bases/base58.js
  init_virtual_process_polyfill();
  var base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/multiformats/src/bases/base32.js
  init_virtual_process_polyfill();
  var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/multiformats/src/link/interface.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/cid.js
  var format = (link, base7) => {
    const { bytes, version: version8 } = link;
    switch (version8) {
      case 0:
        return toStringV0(
          bytes,
          baseCache(link),
          base7 || base58btc.encoder
        );
      default:
        return toStringV1(
          bytes,
          baseCache(link),
          base7 || base32.encoder
        );
    }
  };
  var cache = /* @__PURE__ */ new WeakMap();
  var baseCache = (cid) => {
    const baseCache2 = cache.get(cid);
    if (baseCache2 == null) {
      const baseCache3 = /* @__PURE__ */ new Map();
      cache.set(cid, baseCache3);
      return baseCache3;
    }
    return baseCache2;
  };
  var CID = class {
    constructor(version8, code8, multihash, bytes) {
      this.code = code8;
      this.version = version8;
      this.multihash = multihash;
      this.bytes = bytes;
      this["/"] = bytes;
    }
    get asCID() {
      return this;
    }
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code8, multihash } = this;
          if (code8 !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID.createV0(
            multihash
          );
        }
        default: {
          throw Error(
            `Can not convert CID version ${this.version} to version 0. This is a bug please report`
          );
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code8, digest: digest3 } = this.multihash;
          const multihash = create(code8, digest3);
          return CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(
            `Can not convert CID version ${this.version} to version 1. This is a bug please report`
          );
        }
      }
    }
    equals(other) {
      return CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown && self2.code === unknown.code && self2.version === unknown.version && equals3(self2.multihash, unknown.multihash);
    }
    toString(base7) {
      return format(this, base7);
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    link() {
      return this;
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version8, code: code8, multihash, bytes } = value;
        return new CID(
          version8,
          code8,
          multihash,
          bytes || encodeCID(version8, code8, multihash.bytes)
        );
      } else if (value[cidSymbol] === true) {
        const { version: version8, multihash, code: code8 } = value;
        const digest3 = decode4(multihash);
        return CID.create(version8, code8, digest3);
      } else {
        return null;
      }
    }
    static create(version8, code8, digest3) {
      if (typeof code8 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest3.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version8) {
        case 0: {
          if (code8 !== DAG_PB_CODE) {
            throw new Error(
              `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
            );
          } else {
            return new CID(version8, code8, digest3, digest3.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID(version8, code8, digest3.bytes);
          return new CID(version8, code8, digest3, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest3) {
      return CID.create(0, DAG_PB_CODE, digest3);
    }
    static createV1(code8, digest3) {
      return CID.create(1, code8, digest3);
    }
    static decode(bytes) {
      const [cid, remainder] = CID.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes) {
      const specs = CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(
        bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
      );
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(
        specs.multihashSize - specs.digestSize
      );
      const digest3 = new Digest(
        specs.multihashCode,
        specs.digestSize,
        digestBytes,
        multihashBytes
      );
      const cid = specs.version === 0 ? CID.createV0(digest3) : CID.createV1(specs.codec, digest3);
      return [cid, bytes.subarray(specs.size)];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i2, length7] = decode3(initialBytes.subarray(offset));
        offset += length7;
        return i2;
      };
      let version8 = next();
      let codec = DAG_PB_CODE;
      if (version8 === 18) {
        version8 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version8 !== 0 && version8 !== 1) {
        throw new RangeError(`Invalid CID version ${version8}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version8, codec, multihashCode, digestSize, multihashSize, size };
    }
    static parse(source, base7) {
      const [prefix, bytes] = parseCIDtoBytes(source, base7);
      const cid = CID.decode(bytes);
      baseCache(cid).set(prefix, source);
      return cid;
    }
  };
  var parseCIDtoBytes = (source, base7) => {
    switch (source[0]) {
      case "Q": {
        const decoder = base7 || base58btc;
        return [
          base58btc.prefix,
          decoder.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder = base7 || base58btc;
        return [base58btc.prefix, decoder.decode(source)];
      }
      case base32.prefix: {
        const decoder = base7 || base32;
        return [base32.prefix, decoder.decode(source)];
      }
      default: {
        if (base7 == null) {
          throw Error(
            "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
          );
        }
        return [source[0], base7.decode(source)];
      }
    }
  };
  var toStringV0 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV1 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE = 112;
  var SHA_256_CODE = 18;
  var encodeCID = (version8, code8, multihash) => {
    const codeOffset = encodingLength(version8);
    const hashOffset = codeOffset + encodingLength(code8);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version8, bytes, 0);
    encodeTo(code8, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  var cidSymbol = Symbol.for("@ipld/js-cid/CID");

  // node_modules/multiformats/src/hashes/hasher.js
  init_virtual_process_polyfill();
  var from3 = ({ name: name6, code: code8, encode: encode21 }) => new Hasher(name6, code8, encode21);
  var Hasher = class {
    constructor(name6, code8, encode21) {
      this.name = name6;
      this.code = code8;
      this.encode = encode21;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create(this.code, result) : result.then((digest3) => create(this.code, digest3));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // node_modules/multiformats/src/interface.js
  init_virtual_process_polyfill();

  // node_modules/multiformats/src/block.js
  function readonly({ enumerable = true, configurable = false } = {}) {
    return { enumerable, configurable, writable: false };
  }
  function* linksWithin(path, value) {
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [...path, index];
          const cid = CID.asCID(element);
          if (cid) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [path.join("/"), cid];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
  function* links(source, base7) {
    if (source == null || source instanceof Uint8Array) {
      return;
    }
    for (const [key, value] of Object.entries(source)) {
      const path = [...base7, key];
      yield* linksWithin(path, value);
    }
  }
  function* treeWithin(path, value) {
    if (Array.isArray(value)) {
      for (const [index, element] of value.entries()) {
        const elementPath = [...path, index];
        yield elementPath.join("/");
        if (typeof element === "object" && !CID.asCID(element)) {
          yield* tree(element, elementPath);
        }
      }
    } else {
      yield* tree(value, path);
    }
  }
  function* tree(source, base7) {
    if (source == null || typeof source !== "object") {
      return;
    }
    for (const [key, value] of Object.entries(source)) {
      const path = [...base7, key];
      yield path.join("/");
      if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
        yield* treeWithin(path, value);
      }
    }
  }
  function get(source, path) {
    let node = source;
    for (const [index, key] of path.entries()) {
      node = node[key];
      if (node == null) {
        throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
      }
      const cid = CID.asCID(node);
      if (cid) {
        return { value: cid, remaining: path.slice(index + 1).join("/") };
      }
    }
    return { value: node };
  }
  var Block = class {
    constructor({ cid, bytes, value }) {
      if (!cid || !bytes || typeof value === "undefined") {
        throw new Error("Missing required argument");
      }
      this.cid = cid;
      this.bytes = bytes;
      this.value = value;
      this.asBlock = this;
      Object.defineProperties(this, {
        cid: readonly(),
        bytes: readonly(),
        value: readonly(),
        asBlock: readonly()
      });
    }
    links() {
      return links(this.value, []);
    }
    tree() {
      return tree(this.value, []);
    }
    get(path = "/") {
      return get(this.value, path.split("/").filter(Boolean));
    }
  };
  async function encode3({ value, codec, hasher }) {
    if (typeof value === "undefined")
      throw new Error('Missing required argument "value"');
    if (!codec || !hasher)
      throw new Error("Missing required argument: codec or hasher");
    const bytes = codec.encode(value);
    const hash = await hasher.digest(bytes);
    const cid = CID.create(
      1,
      codec.code,
      hash
    );
    return new Block({ value, bytes, cid });
  }
  async function decode5({ bytes, codec, hasher }) {
    if (!bytes)
      throw new Error('Missing required argument "bytes"');
    if (!codec || !hasher)
      throw new Error("Missing required argument: codec or hasher");
    const value = codec.decode(bytes);
    const hash = await hasher.digest(bytes);
    const cid = CID.create(1, codec.code, hash);
    return new Block({ value, bytes, cid });
  }

  // node_modules/@ipld/dag-cbor/src/index.js
  var src_exports = {};
  __export(src_exports, {
    code: () => code,
    decode: () => decode7,
    encode: () => encode5,
    name: () => name
  });
  init_virtual_process_polyfill();

  // node_modules/cborg/esm/cborg.js
  init_virtual_process_polyfill();

  // node_modules/cborg/esm/lib/encode.js
  init_virtual_process_polyfill();

  // node_modules/cborg/esm/lib/is.js
  init_virtual_process_polyfill();
  var typeofs = [
    "string",
    "number",
    "bigint",
    "symbol"
  ];
  var objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "HTMLElement",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function is(value) {
    if (value === null) {
      return "null";
    }
    if (value === void 0) {
      return "undefined";
    }
    if (value === true || value === false) {
      return "boolean";
    }
    const typeOf = typeof value;
    if (typeofs.includes(typeOf)) {
      return typeOf;
    }
    if (typeOf === "function") {
      return "Function";
    }
    if (Array.isArray(value)) {
      return "Array";
    }
    if (isBuffer2(value)) {
      return "Buffer";
    }
    const objectType = getObjectType(value);
    if (objectType) {
      return objectType;
    }
    return "Object";
  }
  function isBuffer2(value) {
    return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
  }
  function getObjectType(value) {
    const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
    if (objectTypeNames.includes(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  }

  // node_modules/cborg/esm/lib/token.js
  init_virtual_process_polyfill();
  var Type = class {
    constructor(major, name6, terminal) {
      this.major = major;
      this.majorEncoded = major << 5;
      this.name = name6;
      this.terminal = terminal;
    }
    toString() {
      return `Type[${this.major}].${this.name}`;
    }
    compare(typ) {
      return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
    }
  };
  Type.uint = new Type(0, "uint", true);
  Type.negint = new Type(1, "negint", true);
  Type.bytes = new Type(2, "bytes", true);
  Type.string = new Type(3, "string", true);
  Type.array = new Type(4, "array", false);
  Type.map = new Type(5, "map", false);
  Type.tag = new Type(6, "tag", false);
  Type.float = new Type(7, "float", true);
  Type.false = new Type(7, "false", true);
  Type.true = new Type(7, "true", true);
  Type.null = new Type(7, "null", true);
  Type.undefined = new Type(7, "undefined", true);
  Type.break = new Type(7, "break", true);
  var Token = class {
    constructor(type, value, encodedLength) {
      this.type = type;
      this.value = value;
      this.encodedLength = encodedLength;
      this.encodedBytes = void 0;
      this.byteValue = void 0;
    }
    toString() {
      return `Token[${this.type}].${this.value}`;
    }
  };

  // node_modules/cborg/esm/lib/bl.js
  init_virtual_process_polyfill();

  // node_modules/cborg/esm/lib/byte-utils.js
  init_virtual_process_polyfill();
  var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
  var textDecoder2 = new TextDecoder();
  var textEncoder2 = new TextEncoder();
  function isBuffer3(buf2) {
    return useBuffer && globalThis.Buffer.isBuffer(buf2);
  }
  function asU8A(buf2) {
    if (!(buf2 instanceof Uint8Array)) {
      return Uint8Array.from(buf2);
    }
    return isBuffer3(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
  }
  var toString3 = useBuffer ? (bytes, start, end) => {
    return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice2(bytes, start, end);
  } : (bytes, start, end) => {
    return end - start > 64 ? textDecoder2.decode(bytes.subarray(start, end)) : utf8Slice2(bytes, start, end);
  };
  var fromString2 = useBuffer ? (string2) => {
    return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes2(string2);
  } : (string2) => {
    return string2.length > 64 ? textEncoder2.encode(string2) : utf8ToBytes2(string2);
  };
  var fromArray = (arr) => {
    return Uint8Array.from(arr);
  };
  var slice2 = useBuffer ? (bytes, start, end) => {
    if (isBuffer3(bytes)) {
      return new Uint8Array(bytes.subarray(start, end));
    }
    return bytes.slice(start, end);
  } : (bytes, start, end) => {
    return bytes.slice(start, end);
  };
  var concat2 = useBuffer ? (chunks, length7) => {
    chunks = chunks.map((c2) => c2 instanceof Uint8Array ? c2 : globalThis.Buffer.from(c2));
    return asU8A(globalThis.Buffer.concat(chunks, length7));
  } : (chunks, length7) => {
    const out = new Uint8Array(length7);
    let off3 = 0;
    for (let b2 of chunks) {
      if (off3 + b2.length > out.length) {
        b2 = b2.subarray(0, out.length - off3);
      }
      out.set(b2, off3);
      off3 += b2.length;
    }
    return out;
  };
  var alloc2 = useBuffer ? (size) => {
    return globalThis.Buffer.allocUnsafe(size);
  } : (size) => {
    return new Uint8Array(size);
  };
  function compare3(b1, b2) {
    if (isBuffer3(b1) && isBuffer3(b2)) {
      return b1.compare(b2);
    }
    for (let i2 = 0; i2 < b1.length; i2++) {
      if (b1[i2] === b2[i2]) {
        continue;
      }
      return b1[i2] < b2[i2] ? -1 : 1;
    }
    return 0;
  }
  function utf8ToBytes2(string2, units = Infinity) {
    let codePoint;
    const length7 = string2.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length7; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length7) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function utf8Slice2(buf2, offset, end) {
    const res = [];
    while (offset < end) {
      const firstByte = buf2[offset];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (offset + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[offset + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            fourthByte = buf2[offset + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      offset += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  var MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2));
    }
    return res;
  }

  // node_modules/cborg/esm/lib/bl.js
  var defaultChunkSize = 256;
  var Bl = class {
    constructor(chunkSize = defaultChunkSize) {
      this.chunkSize = chunkSize;
      this.cursor = 0;
      this.maxCursor = -1;
      this.chunks = [];
      this._initReuseChunk = null;
    }
    reset() {
      this.cursor = 0;
      this.maxCursor = -1;
      if (this.chunks.length) {
        this.chunks = [];
      }
      if (this._initReuseChunk !== null) {
        this.chunks.push(this._initReuseChunk);
        this.maxCursor = this._initReuseChunk.length - 1;
      }
    }
    push(bytes) {
      let topChunk = this.chunks[this.chunks.length - 1];
      const newMax = this.cursor + bytes.length;
      if (newMax <= this.maxCursor + 1) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        topChunk.set(bytes, chunkPos);
      } else {
        if (topChunk) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          if (chunkPos < topChunk.length) {
            this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
            this.maxCursor = this.cursor - 1;
          }
        }
        if (bytes.length < 64 && bytes.length < this.chunkSize) {
          topChunk = alloc2(this.chunkSize);
          this.chunks.push(topChunk);
          this.maxCursor += topChunk.length;
          if (this._initReuseChunk === null) {
            this._initReuseChunk = topChunk;
          }
          topChunk.set(bytes, 0);
        } else {
          this.chunks.push(bytes);
          this.maxCursor += bytes.length;
        }
      }
      this.cursor += bytes.length;
    }
    toBytes(reset = false) {
      let byts;
      if (this.chunks.length === 1) {
        const chunk = this.chunks[0];
        if (reset && this.cursor > chunk.length / 2) {
          byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
          this._initReuseChunk = null;
          this.chunks = [];
        } else {
          byts = slice2(chunk, 0, this.cursor);
        }
      } else {
        byts = concat2(this.chunks, this.cursor);
      }
      if (reset) {
        this.reset();
      }
      return byts;
    }
  };

  // node_modules/cborg/esm/lib/common.js
  init_virtual_process_polyfill();
  var decodeErrPrefix = "CBOR decode error:";
  var encodeErrPrefix = "CBOR encode error:";
  var uintMinorPrefixBytes = [];
  uintMinorPrefixBytes[23] = 1;
  uintMinorPrefixBytes[24] = 2;
  uintMinorPrefixBytes[25] = 3;
  uintMinorPrefixBytes[26] = 5;
  uintMinorPrefixBytes[27] = 9;
  function assertEnoughData(data, pos, need) {
    if (data.length - pos < need) {
      throw new Error(`${decodeErrPrefix} not enough data for type`);
    }
  }

  // node_modules/cborg/esm/lib/jump.js
  init_virtual_process_polyfill();

  // node_modules/cborg/esm/lib/0uint.js
  init_virtual_process_polyfill();
  var uintBoundaries = [
    24,
    256,
    65536,
    4294967296,
    BigInt("18446744073709551616")
  ];
  function readUint8(data, offset, options) {
    assertEnoughData(data, offset, 1);
    const value = data[offset];
    if (options.strict === true && value < uintBoundaries[0]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint16(data, offset, options) {
    assertEnoughData(data, offset, 2);
    const value = data[offset] << 8 | data[offset + 1];
    if (options.strict === true && value < uintBoundaries[1]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint32(data, offset, options) {
    assertEnoughData(data, offset, 4);
    const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    if (options.strict === true && value < uintBoundaries[2]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint64(data, offset, options) {
    assertEnoughData(data, offset, 8);
    const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
    const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
    if (options.strict === true && value < uintBoundaries[3]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    if (value <= Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    if (options.allowBigInt === true) {
      return value;
    }
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  function decodeUint8(data, pos, _minor, options) {
    return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
  }
  function decodeUint16(data, pos, _minor, options) {
    return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
  }
  function decodeUint32(data, pos, _minor, options) {
    return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
  }
  function decodeUint64(data, pos, _minor, options) {
    return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
  }
  function encodeUint(buf2, token) {
    return encodeUintValue(buf2, 0, token.value);
  }
  function encodeUintValue(buf2, major, uint) {
    if (uint < uintBoundaries[0]) {
      const nuint = Number(uint);
      buf2.push([major | nuint]);
    } else if (uint < uintBoundaries[1]) {
      const nuint = Number(uint);
      buf2.push([
        major | 24,
        nuint
      ]);
    } else if (uint < uintBoundaries[2]) {
      const nuint = Number(uint);
      buf2.push([
        major | 25,
        nuint >>> 8,
        nuint & 255
      ]);
    } else if (uint < uintBoundaries[3]) {
      const nuint = Number(uint);
      buf2.push([
        major | 26,
        nuint >>> 24 & 255,
        nuint >>> 16 & 255,
        nuint >>> 8 & 255,
        nuint & 255
      ]);
    } else {
      const buint = BigInt(uint);
      if (buint < uintBoundaries[4]) {
        const set = [
          major | 27,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        let lo = Number(buint & BigInt(4294967295));
        let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
        set[8] = lo & 255;
        lo = lo >> 8;
        set[7] = lo & 255;
        lo = lo >> 8;
        set[6] = lo & 255;
        lo = lo >> 8;
        set[5] = lo & 255;
        set[4] = hi & 255;
        hi = hi >> 8;
        set[3] = hi & 255;
        hi = hi >> 8;
        set[2] = hi & 255;
        hi = hi >> 8;
        set[1] = hi & 255;
        buf2.push(set);
      } else {
        throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
      }
    }
  }
  encodeUint.encodedSize = function encodedSize(token) {
    return encodeUintValue.encodedSize(token.value);
  };
  encodeUintValue.encodedSize = function encodedSize2(uint) {
    if (uint < uintBoundaries[0]) {
      return 1;
    }
    if (uint < uintBoundaries[1]) {
      return 2;
    }
    if (uint < uintBoundaries[2]) {
      return 3;
    }
    if (uint < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeUint.compareTokens = function compareTokens(tok1, tok2) {
    return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
  };

  // node_modules/cborg/esm/lib/1negint.js
  init_virtual_process_polyfill();
  function decodeNegint8(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
  }
  function decodeNegint16(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
  }
  function decodeNegint32(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
  }
  var neg1b = BigInt(-1);
  var pos1b = BigInt(1);
  function decodeNegint64(data, pos, _minor, options) {
    const int = readUint64(data, pos + 1, options);
    if (typeof int !== "bigint") {
      const value = -1 - int;
      if (value >= Number.MIN_SAFE_INTEGER) {
        return new Token(Type.negint, value, 9);
      }
    }
    if (options.allowBigInt !== true) {
      throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
    }
    return new Token(Type.negint, neg1b - BigInt(int), 9);
  }
  function encodeNegint(buf2, token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    encodeUintValue(buf2, token.type.majorEncoded, unsigned);
  }
  encodeNegint.encodedSize = function encodedSize3(token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    if (unsigned < uintBoundaries[0]) {
      return 1;
    }
    if (unsigned < uintBoundaries[1]) {
      return 2;
    }
    if (unsigned < uintBoundaries[2]) {
      return 3;
    }
    if (unsigned < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
    return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
  };

  // node_modules/cborg/esm/lib/2bytes.js
  init_virtual_process_polyfill();
  function toToken(data, pos, prefix, length7) {
    assertEnoughData(data, pos, prefix + length7);
    const buf2 = slice2(data, pos + prefix, pos + prefix + length7);
    return new Token(Type.bytes, buf2, prefix + length7);
  }
  function decodeBytesCompact(data, pos, minor, _options) {
    return toToken(data, pos, 1, minor);
  }
  function decodeBytes8(data, pos, _minor, options) {
    return toToken(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeBytes16(data, pos, _minor, options) {
    return toToken(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeBytes32(data, pos, _minor, options) {
    return toToken(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeBytes64(data, pos, _minor, options) {
    const l2 = readUint64(data, pos + 1, options);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
    }
    return toToken(data, pos, 9, l2);
  }
  function tokenBytes(token) {
    if (token.encodedBytes === void 0) {
      token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
    }
    return token.encodedBytes;
  }
  function encodeBytes(buf2, token) {
    const bytes = tokenBytes(token);
    encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
    buf2.push(bytes);
  }
  encodeBytes.encodedSize = function encodedSize4(token) {
    const bytes = tokenBytes(token);
    return encodeUintValue.encodedSize(bytes.length) + bytes.length;
  };
  encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
    return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
  };
  function compareBytes(b1, b2) {
    return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare3(b1, b2);
  }

  // node_modules/cborg/esm/lib/3string.js
  init_virtual_process_polyfill();
  function toToken2(data, pos, prefix, length7, options) {
    const totLength = prefix + length7;
    assertEnoughData(data, pos, totLength);
    const tok = new Token(Type.string, toString3(data, pos + prefix, pos + totLength), totLength);
    if (options.retainStringBytes === true) {
      tok.byteValue = slice2(data, pos + prefix, pos + totLength);
    }
    return tok;
  }
  function decodeStringCompact(data, pos, minor, options) {
    return toToken2(data, pos, 1, minor, options);
  }
  function decodeString8(data, pos, _minor, options) {
    return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
  }
  function decodeString16(data, pos, _minor, options) {
    return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
  }
  function decodeString32(data, pos, _minor, options) {
    return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
  }
  function decodeString64(data, pos, _minor, options) {
    const l2 = readUint64(data, pos + 1, options);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
    }
    return toToken2(data, pos, 9, l2, options);
  }
  var encodeString = encodeBytes;

  // node_modules/cborg/esm/lib/4array.js
  init_virtual_process_polyfill();
  function toToken3(_data, _pos, prefix, length7) {
    return new Token(Type.array, length7, prefix);
  }
  function decodeArrayCompact(data, pos, minor, _options) {
    return toToken3(data, pos, 1, minor);
  }
  function decodeArray8(data, pos, _minor, options) {
    return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeArray16(data, pos, _minor, options) {
    return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeArray32(data, pos, _minor, options) {
    return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeArray64(data, pos, _minor, options) {
    const l2 = readUint64(data, pos + 1, options);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
    }
    return toToken3(data, pos, 9, l2);
  }
  function decodeArrayIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken3(data, pos, 1, Infinity);
  }
  function encodeArray(buf2, token) {
    encodeUintValue(buf2, Type.array.majorEncoded, token.value);
  }
  encodeArray.compareTokens = encodeUint.compareTokens;
  encodeArray.encodedSize = function encodedSize5(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/esm/lib/5map.js
  init_virtual_process_polyfill();
  function toToken4(_data, _pos, prefix, length7) {
    return new Token(Type.map, length7, prefix);
  }
  function decodeMapCompact(data, pos, minor, _options) {
    return toToken4(data, pos, 1, minor);
  }
  function decodeMap8(data, pos, _minor, options) {
    return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeMap16(data, pos, _minor, options) {
    return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeMap32(data, pos, _minor, options) {
    return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeMap64(data, pos, _minor, options) {
    const l2 = readUint64(data, pos + 1, options);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
    }
    return toToken4(data, pos, 9, l2);
  }
  function decodeMapIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken4(data, pos, 1, Infinity);
  }
  function encodeMap(buf2, token) {
    encodeUintValue(buf2, Type.map.majorEncoded, token.value);
  }
  encodeMap.compareTokens = encodeUint.compareTokens;
  encodeMap.encodedSize = function encodedSize6(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/esm/lib/6tag.js
  init_virtual_process_polyfill();
  function decodeTagCompact(_data, _pos, minor, _options) {
    return new Token(Type.tag, minor, 1);
  }
  function decodeTag8(data, pos, _minor, options) {
    return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
  }
  function decodeTag16(data, pos, _minor, options) {
    return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
  }
  function decodeTag32(data, pos, _minor, options) {
    return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
  }
  function decodeTag64(data, pos, _minor, options) {
    return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
  }
  function encodeTag(buf2, token) {
    encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
  }
  encodeTag.compareTokens = encodeUint.compareTokens;
  encodeTag.encodedSize = function encodedSize7(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/esm/lib/7float.js
  init_virtual_process_polyfill();
  var MINOR_FALSE = 20;
  var MINOR_TRUE = 21;
  var MINOR_NULL = 22;
  var MINOR_UNDEFINED = 23;
  function decodeUndefined(_data, _pos, _minor, options) {
    if (options.allowUndefined === false) {
      throw new Error(`${decodeErrPrefix} undefined values are not supported`);
    } else if (options.coerceUndefinedToNull === true) {
      return new Token(Type.null, null, 1);
    }
    return new Token(Type.undefined, void 0, 1);
  }
  function decodeBreak(_data, _pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return new Token(Type.break, void 0, 1);
  }
  function createToken(value, bytes, options) {
    if (options) {
      if (options.allowNaN === false && Number.isNaN(value)) {
        throw new Error(`${decodeErrPrefix} NaN values are not supported`);
      }
      if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
        throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
      }
    }
    return new Token(Type.float, value, bytes);
  }
  function decodeFloat16(data, pos, _minor, options) {
    return createToken(readFloat16(data, pos + 1), 3, options);
  }
  function decodeFloat32(data, pos, _minor, options) {
    return createToken(readFloat32(data, pos + 1), 5, options);
  }
  function decodeFloat64(data, pos, _minor, options) {
    return createToken(readFloat64(data, pos + 1), 9, options);
  }
  function encodeFloat(buf2, token, options) {
    const float = token.value;
    if (float === false) {
      buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
    } else if (float === true) {
      buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
    } else if (float === null) {
      buf2.push([Type.float.majorEncoded | MINOR_NULL]);
    } else if (float === void 0) {
      buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
    } else {
      let decoded;
      let success = false;
      if (!options || options.float64 !== true) {
        encodeFloat16(float);
        decoded = readFloat16(ui8a, 1);
        if (float === decoded || Number.isNaN(float)) {
          ui8a[0] = 249;
          buf2.push(ui8a.slice(0, 3));
          success = true;
        } else {
          encodeFloat32(float);
          decoded = readFloat32(ui8a, 1);
          if (float === decoded) {
            ui8a[0] = 250;
            buf2.push(ui8a.slice(0, 5));
            success = true;
          }
        }
      }
      if (!success) {
        encodeFloat64(float);
        decoded = readFloat64(ui8a, 1);
        ui8a[0] = 251;
        buf2.push(ui8a.slice(0, 9));
      }
    }
  }
  encodeFloat.encodedSize = function encodedSize8(token, options) {
    const float = token.value;
    if (float === false || float === true || float === null || float === void 0) {
      return 1;
    }
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      let decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        return 3;
      }
      encodeFloat32(float);
      decoded = readFloat32(ui8a, 1);
      if (float === decoded) {
        return 5;
      }
    }
    return 9;
  };
  var buffer = new ArrayBuffer(9);
  var dataView = new DataView(buffer, 1);
  var ui8a = new Uint8Array(buffer, 0);
  function encodeFloat16(inp) {
    if (inp === Infinity) {
      dataView.setUint16(0, 31744, false);
    } else if (inp === -Infinity) {
      dataView.setUint16(0, 64512, false);
    } else if (Number.isNaN(inp)) {
      dataView.setUint16(0, 32256, false);
    } else {
      dataView.setFloat32(0, inp);
      const valu32 = dataView.getUint32(0);
      const exponent = (valu32 & 2139095040) >> 23;
      const mantissa = valu32 & 8388607;
      if (exponent === 255) {
        dataView.setUint16(0, 31744, false);
      } else if (exponent === 0) {
        dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
      } else {
        const logicalExponent = exponent - 127;
        if (logicalExponent < -24) {
          dataView.setUint16(0, 0);
        } else if (logicalExponent < -14) {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
        } else {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
        }
      }
    }
  }
  function readFloat16(ui8a2, pos) {
    if (ui8a2.length - pos < 2) {
      throw new Error(`${decodeErrPrefix} not enough data for float16`);
    }
    const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
    if (half === 31744) {
      return Infinity;
    }
    if (half === 64512) {
      return -Infinity;
    }
    if (half === 32256) {
      return NaN;
    }
    const exp = half >> 10 & 31;
    const mant = half & 1023;
    let val;
    if (exp === 0) {
      val = mant * 2 ** -24;
    } else if (exp !== 31) {
      val = (mant + 1024) * 2 ** (exp - 25);
    } else {
      val = mant === 0 ? Infinity : NaN;
    }
    return half & 32768 ? -val : val;
  }
  function encodeFloat32(inp) {
    dataView.setFloat32(0, inp, false);
  }
  function readFloat32(ui8a2, pos) {
    if (ui8a2.length - pos < 4) {
      throw new Error(`${decodeErrPrefix} not enough data for float32`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
  }
  function encodeFloat64(inp) {
    dataView.setFloat64(0, inp, false);
  }
  function readFloat64(ui8a2, pos) {
    if (ui8a2.length - pos < 8) {
      throw new Error(`${decodeErrPrefix} not enough data for float64`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
  }
  encodeFloat.compareTokens = encodeUint.compareTokens;

  // node_modules/cborg/esm/lib/jump.js
  function invalidMinor(data, pos, minor) {
    throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
  }
  function errorer(msg) {
    return () => {
      throw new Error(`${decodeErrPrefix} ${msg}`);
    };
  }
  var jump = [];
  for (let i2 = 0; i2 <= 23; i2++) {
    jump[i2] = invalidMinor;
  }
  jump[24] = decodeUint8;
  jump[25] = decodeUint16;
  jump[26] = decodeUint32;
  jump[27] = decodeUint64;
  jump[28] = invalidMinor;
  jump[29] = invalidMinor;
  jump[30] = invalidMinor;
  jump[31] = invalidMinor;
  for (let i2 = 32; i2 <= 55; i2++) {
    jump[i2] = invalidMinor;
  }
  jump[56] = decodeNegint8;
  jump[57] = decodeNegint16;
  jump[58] = decodeNegint32;
  jump[59] = decodeNegint64;
  jump[60] = invalidMinor;
  jump[61] = invalidMinor;
  jump[62] = invalidMinor;
  jump[63] = invalidMinor;
  for (let i2 = 64; i2 <= 87; i2++) {
    jump[i2] = decodeBytesCompact;
  }
  jump[88] = decodeBytes8;
  jump[89] = decodeBytes16;
  jump[90] = decodeBytes32;
  jump[91] = decodeBytes64;
  jump[92] = invalidMinor;
  jump[93] = invalidMinor;
  jump[94] = invalidMinor;
  jump[95] = errorer("indefinite length bytes/strings are not supported");
  for (let i2 = 96; i2 <= 119; i2++) {
    jump[i2] = decodeStringCompact;
  }
  jump[120] = decodeString8;
  jump[121] = decodeString16;
  jump[122] = decodeString32;
  jump[123] = decodeString64;
  jump[124] = invalidMinor;
  jump[125] = invalidMinor;
  jump[126] = invalidMinor;
  jump[127] = errorer("indefinite length bytes/strings are not supported");
  for (let i2 = 128; i2 <= 151; i2++) {
    jump[i2] = decodeArrayCompact;
  }
  jump[152] = decodeArray8;
  jump[153] = decodeArray16;
  jump[154] = decodeArray32;
  jump[155] = decodeArray64;
  jump[156] = invalidMinor;
  jump[157] = invalidMinor;
  jump[158] = invalidMinor;
  jump[159] = decodeArrayIndefinite;
  for (let i2 = 160; i2 <= 183; i2++) {
    jump[i2] = decodeMapCompact;
  }
  jump[184] = decodeMap8;
  jump[185] = decodeMap16;
  jump[186] = decodeMap32;
  jump[187] = decodeMap64;
  jump[188] = invalidMinor;
  jump[189] = invalidMinor;
  jump[190] = invalidMinor;
  jump[191] = decodeMapIndefinite;
  for (let i2 = 192; i2 <= 215; i2++) {
    jump[i2] = decodeTagCompact;
  }
  jump[216] = decodeTag8;
  jump[217] = decodeTag16;
  jump[218] = decodeTag32;
  jump[219] = decodeTag64;
  jump[220] = invalidMinor;
  jump[221] = invalidMinor;
  jump[222] = invalidMinor;
  jump[223] = invalidMinor;
  for (let i2 = 224; i2 <= 243; i2++) {
    jump[i2] = errorer("simple values are not supported");
  }
  jump[244] = invalidMinor;
  jump[245] = invalidMinor;
  jump[246] = invalidMinor;
  jump[247] = decodeUndefined;
  jump[248] = errorer("simple values are not supported");
  jump[249] = decodeFloat16;
  jump[250] = decodeFloat32;
  jump[251] = decodeFloat64;
  jump[252] = invalidMinor;
  jump[253] = invalidMinor;
  jump[254] = invalidMinor;
  jump[255] = decodeBreak;
  var quick = [];
  for (let i2 = 0; i2 < 24; i2++) {
    quick[i2] = new Token(Type.uint, i2, 1);
  }
  for (let i2 = -1; i2 >= -24; i2--) {
    quick[31 - i2] = new Token(Type.negint, i2, 1);
  }
  quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
  quick[96] = new Token(Type.string, "", 1);
  quick[128] = new Token(Type.array, 0, 1);
  quick[160] = new Token(Type.map, 0, 1);
  quick[244] = new Token(Type.false, false, 1);
  quick[245] = new Token(Type.true, true, 1);
  quick[246] = new Token(Type.null, null, 1);
  function quickEncodeToken(token) {
    switch (token.type) {
      case Type.false:
        return fromArray([244]);
      case Type.true:
        return fromArray([245]);
      case Type.null:
        return fromArray([246]);
      case Type.bytes:
        if (!token.value.length) {
          return fromArray([64]);
        }
        return;
      case Type.string:
        if (token.value === "") {
          return fromArray([96]);
        }
        return;
      case Type.array:
        if (token.value === 0) {
          return fromArray([128]);
        }
        return;
      case Type.map:
        if (token.value === 0) {
          return fromArray([160]);
        }
        return;
      case Type.uint:
        if (token.value < 24) {
          return fromArray([Number(token.value)]);
        }
        return;
      case Type.negint:
        if (token.value >= -24) {
          return fromArray([31 - Number(token.value)]);
        }
    }
  }

  // node_modules/cborg/esm/lib/encode.js
  var defaultEncodeOptions = {
    float64: false,
    mapSorter,
    quickEncodeToken
  };
  function makeCborEncoders() {
    const encoders = [];
    encoders[Type.uint.major] = encodeUint;
    encoders[Type.negint.major] = encodeNegint;
    encoders[Type.bytes.major] = encodeBytes;
    encoders[Type.string.major] = encodeString;
    encoders[Type.array.major] = encodeArray;
    encoders[Type.map.major] = encodeMap;
    encoders[Type.tag.major] = encodeTag;
    encoders[Type.float.major] = encodeFloat;
    return encoders;
  }
  var cborEncoders = makeCborEncoders();
  var buf = new Bl();
  var Ref = class {
    constructor(obj, parent) {
      this.obj = obj;
      this.parent = parent;
    }
    includes(obj) {
      let p2 = this;
      do {
        if (p2.obj === obj) {
          return true;
        }
      } while (p2 = p2.parent);
      return false;
    }
    static createCheck(stack, obj) {
      if (stack && stack.includes(obj)) {
        throw new Error(`${encodeErrPrefix} object contains circular references`);
      }
      return new Ref(obj, stack);
    }
  };
  var simpleTokens = {
    null: new Token(Type.null, null),
    undefined: new Token(Type.undefined, void 0),
    true: new Token(Type.true, true),
    false: new Token(Type.false, false),
    emptyArray: new Token(Type.array, 0),
    emptyMap: new Token(Type.map, 0)
  };
  var typeEncoders = {
    number(obj, _typ, _options, _refStack) {
      if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
        return new Token(Type.float, obj);
      } else if (obj >= 0) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    bigint(obj, _typ, _options, _refStack) {
      if (obj >= BigInt(0)) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    Uint8Array(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, obj);
    },
    string(obj, _typ, _options, _refStack) {
      return new Token(Type.string, obj);
    },
    boolean(obj, _typ, _options, _refStack) {
      return obj ? simpleTokens.true : simpleTokens.false;
    },
    null(_obj, _typ, _options, _refStack) {
      return simpleTokens.null;
    },
    undefined(_obj, _typ, _options, _refStack) {
      return simpleTokens.undefined;
    },
    ArrayBuffer(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj));
    },
    DataView(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
    },
    Array(obj, _typ, options, refStack) {
      if (!obj.length) {
        if (options.addBreakTokens === true) {
          return [
            simpleTokens.emptyArray,
            new Token(Type.break)
          ];
        }
        return simpleTokens.emptyArray;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries = [];
      let i2 = 0;
      for (const e2 of obj) {
        entries[i2++] = objectToTokens(e2, options, refStack);
      }
      if (options.addBreakTokens) {
        return [
          new Token(Type.array, obj.length),
          entries,
          new Token(Type.break)
        ];
      }
      return [
        new Token(Type.array, obj.length),
        entries
      ];
    },
    Object(obj, typ, options, refStack) {
      const isMap = typ !== "Object";
      const keys = isMap ? obj.keys() : Object.keys(obj);
      const length7 = isMap ? obj.size : keys.length;
      if (!length7) {
        if (options.addBreakTokens === true) {
          return [
            simpleTokens.emptyMap,
            new Token(Type.break)
          ];
        }
        return simpleTokens.emptyMap;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries = [];
      let i2 = 0;
      for (const key of keys) {
        entries[i2++] = [
          objectToTokens(key, options, refStack),
          objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
        ];
      }
      sortMapEntries(entries, options);
      if (options.addBreakTokens) {
        return [
          new Token(Type.map, length7),
          entries,
          new Token(Type.break)
        ];
      }
      return [
        new Token(Type.map, length7),
        entries
      ];
    }
  };
  typeEncoders.Map = typeEncoders.Object;
  typeEncoders.Buffer = typeEncoders.Uint8Array;
  for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
    typeEncoders[`${typ}Array`] = typeEncoders.DataView;
  }
  function objectToTokens(obj, options = {}, refStack) {
    const typ = is(obj);
    const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
    if (typeof customTypeEncoder === "function") {
      const tokens = customTypeEncoder(obj, typ, options, refStack);
      if (tokens != null) {
        return tokens;
      }
    }
    const typeEncoder = typeEncoders[typ];
    if (!typeEncoder) {
      throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
    }
    return typeEncoder(obj, typ, options, refStack);
  }
  function sortMapEntries(entries, options) {
    if (options.mapSorter) {
      entries.sort(options.mapSorter);
    }
  }
  function mapSorter(e1, e2) {
    const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
    const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
    if (keyToken1.type !== keyToken2.type) {
      return keyToken1.type.compare(keyToken2.type);
    }
    const major = keyToken1.type.major;
    const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
    if (tcmp === 0) {
      console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
    }
    return tcmp;
  }
  function tokensToEncoded(buf2, tokens, encoders, options) {
    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        tokensToEncoded(buf2, token, encoders, options);
      }
    } else {
      encoders[tokens.type.major](buf2, tokens, options);
    }
  }
  function encodeCustom(data, encoders, options) {
    const tokens = objectToTokens(data, options);
    if (!Array.isArray(tokens) && options.quickEncodeToken) {
      const quickBytes = options.quickEncodeToken(tokens);
      if (quickBytes) {
        return quickBytes;
      }
      const encoder = encoders[tokens.type.major];
      if (encoder.encodedSize) {
        const size = encoder.encodedSize(tokens, options);
        const buf2 = new Bl(size);
        encoder(buf2, tokens, options);
        if (buf2.chunks.length !== 1) {
          throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
        }
        return asU8A(buf2.chunks[0]);
      }
    }
    buf.reset();
    tokensToEncoded(buf, tokens, encoders, options);
    return buf.toBytes(true);
  }
  function encode4(data, options) {
    options = Object.assign({}, defaultEncodeOptions, options);
    return encodeCustom(data, cborEncoders, options);
  }

  // node_modules/cborg/esm/lib/decode.js
  init_virtual_process_polyfill();
  var defaultDecodeOptions = {
    strict: false,
    allowIndefinite: true,
    allowUndefined: true,
    allowBigInt: true
  };
  var Tokeniser = class {
    constructor(data, options = {}) {
      this.pos = 0;
      this.data = data;
      this.options = options;
    }
    done() {
      return this.pos >= this.data.length;
    }
    next() {
      const byt = this.data[this.pos];
      let token = quick[byt];
      if (token === void 0) {
        const decoder = jump[byt];
        if (!decoder) {
          throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
        }
        const minor = byt & 31;
        token = decoder(this.data, this.pos, minor, this.options);
      }
      this.pos += token.encodedLength;
      return token;
    }
  };
  var DONE = Symbol.for("DONE");
  var BREAK = Symbol.for("BREAK");
  function tokenToArray(token, tokeniser, options) {
    const arr = [];
    for (let i2 = 0; i2 < token.value; i2++) {
      const value = tokensToObject(tokeniser, options);
      if (value === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
      }
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
      }
      arr[i2] = value;
    }
    return arr;
  }
  function tokenToMap(token, tokeniser, options) {
    const useMaps = options.useMaps === true;
    const obj = useMaps ? void 0 : {};
    const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
    for (let i2 = 0; i2 < token.value; i2++) {
      const key = tokensToObject(tokeniser, options);
      if (key === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
      }
      if (key === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
      }
      if (useMaps !== true && typeof key !== "string") {
        throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
      }
      if (options.rejectDuplicateMapKeys === true) {
        if (useMaps && m2.has(key) || !useMaps && key in obj) {
          throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
        }
      }
      const value = tokensToObject(tokeniser, options);
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
      }
      if (useMaps) {
        m2.set(key, value);
      } else {
        obj[key] = value;
      }
    }
    return useMaps ? m2 : obj;
  }
  function tokensToObject(tokeniser, options) {
    if (tokeniser.done()) {
      return DONE;
    }
    const token = tokeniser.next();
    if (token.type === Type.break) {
      return BREAK;
    }
    if (token.type.terminal) {
      return token.value;
    }
    if (token.type === Type.array) {
      return tokenToArray(token, tokeniser, options);
    }
    if (token.type === Type.map) {
      return tokenToMap(token, tokeniser, options);
    }
    if (token.type === Type.tag) {
      if (options.tags && typeof options.tags[token.value] === "function") {
        const tagged = tokensToObject(tokeniser, options);
        return options.tags[token.value](tagged);
      }
      throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
    }
    throw new Error("unsupported");
  }
  function decode6(data, options) {
    if (!(data instanceof Uint8Array)) {
      throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
    }
    options = Object.assign({}, defaultDecodeOptions, options);
    const tokeniser = options.tokenizer || new Tokeniser(data, options);
    const decoded = tokensToObject(tokeniser, options);
    if (decoded === DONE) {
      throw new Error(`${decodeErrPrefix} did not find any content to decode`);
    }
    if (decoded === BREAK) {
      throw new Error(`${decodeErrPrefix} got unexpected break`);
    }
    if (!tokeniser.done()) {
      throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
    }
    return decoded;
  }

  // node_modules/@ipld/dag-cbor/src/index.js
  var CID_CBOR_TAG = 42;
  function cidEncoder(obj) {
    if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
      return null;
    }
    const cid = CID.asCID(obj);
    if (!cid) {
      return null;
    }
    const bytes = new Uint8Array(cid.bytes.byteLength + 1);
    bytes.set(cid.bytes, 1);
    return [
      new Token(Type.tag, CID_CBOR_TAG),
      new Token(Type.bytes, bytes)
    ];
  }
  function undefinedEncoder() {
    throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
  }
  function numberEncoder(num) {
    if (Number.isNaN(num)) {
      throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
    }
    if (num === Infinity || num === -Infinity) {
      throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
    }
    return null;
  }
  var encodeOptions = {
    float64: true,
    typeEncoders: {
      Object: cidEncoder,
      undefined: undefinedEncoder,
      number: numberEncoder
    }
  };
  function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
      throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
    }
    return CID.decode(bytes.subarray(1));
  }
  var decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    strict: true,
    useMaps: false,
    tags: []
  };
  decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
  var name = "dag-cbor";
  var code = 113;
  var encode5 = (node) => encode4(node, encodeOptions);
  var decode7 = (data) => decode6(data, decodeOptions);

  // src/message-store.js
  var import_lodash = __toESM(require_lodash(), 1);
  var import_search_index = __toESM(require_browser4(), 1);

  // node_modules/@js-temporal/polyfill/dist/index.esm.js
  init_virtual_process_polyfill();
  var import_jsbi = __toESM(require_jsbi_umd(), 1);
  var t = {};
  function MakeIntrinsicClass(e2, t2) {
    Object.defineProperty(e2.prototype, Symbol.toStringTag, { value: t2, writable: false, enumerable: false, configurable: true });
    for (const t3 of Object.getOwnPropertyNames(e2)) {
      const r2 = Object.getOwnPropertyDescriptor(e2, t3);
      r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2, t3, r2));
    }
    for (const t3 of Object.getOwnPropertyNames(e2.prototype)) {
      const r2 = Object.getOwnPropertyDescriptor(e2.prototype, t3);
      r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2.prototype, t3, r2));
    }
    DefineIntrinsic(t2, e2), DefineIntrinsic(`${t2}.prototype`, e2.prototype);
  }
  function DefineIntrinsic(e2, r2) {
    const o2 = `%${e2}%`;
    if (void 0 !== t[o2])
      throw new Error(`intrinsic ${e2} already exists`);
    t[o2] = r2;
  }
  function GetIntrinsic(e2) {
    return t[e2];
  }
  var r = "slot-epochNanoSeconds";
  var o = "slot-timezone-identifier";
  var n = "slot-year";
  var a = "slot-month";
  var i = "slot-day";
  var s = "slot-hour";
  var l = "slot-minute";
  var d = "slot-second";
  var m = "slot-millisecond";
  var c = "slot-microsecond";
  var h = "slot-nanosecond";
  var u = "slot-calendar";
  var T = "slot-cached-instant";
  var p = "slot-time-zone";
  var f = "slot-years";
  var y = "slot-months";
  var S = "slot-weeks";
  var w = "slot-days";
  var g = "slot-hours";
  var I = "slot-minutes";
  var D = "slot-seconds";
  var G = "slot-milliseconds";
  var v = "slot-microseconds";
  var O = "slot-nanoseconds";
  var C = "slot-calendar-identifier";
  var E = /* @__PURE__ */ new WeakMap();
  function CreateSlots(e2) {
    E.set(e2, /* @__PURE__ */ Object.create(null));
  }
  function GetSlots(e2) {
    return E.get(e2);
  }
  function HasSlot(e2, ...t2) {
    if (!e2 || "object" != typeof e2)
      return false;
    const r2 = GetSlots(e2);
    return !!r2 && t2.reduce((e3, t3) => e3 && t3 in r2, true);
  }
  function GetSlot(e2, t2) {
    const r2 = GetSlots(e2)[t2];
    if (void 0 === r2)
      throw new TypeError(`Missing internal slot ${t2}`);
    return r2;
  }
  function SetSlot(e2, t2, r2) {
    GetSlots(e2)[t2] = r2;
  }
  var b = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
  var M = new RegExp(`(?:(?:${b.source})(?:\\/(?:${b.source}))*|Etc/GMT[-+]\\d{1,2}|${/(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source})`);
  var R = /[A-Za-z0-9]{3,8}/;
  var Z = new RegExp(`(?:${R.source}(?:-${R.source})*)`);
  var P = /(?:[+\u2212-]\d{6}|\d{4})/;
  var F = /(?:0[1-9]|1[0-2])/;
  var Y = /(?:0[1-9]|[12]\d|3[01])/;
  var j = new RegExp(`(${P.source})(?:-(${F.source})-(${Y.source})|(${F.source})(${Y.source}))`);
  var $ = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
  var B = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
  var N = new RegExp(`(?:([zZ])|(?:${B.source})?)(?:\\[(${M.source})\\])?`);
  var k = new RegExp(`\\[u-ca=(${Z.source})\\]`);
  var A = new RegExp(`^${j.source}(?:(?:T|\\s+)${$.source})?${N.source}(?:${k.source})?$`, "i");
  var U = new RegExp(`^T?${$.source}(?:${N.source})?(?:${k.source})?$`, "i");
  var L = new RegExp(`^(${P.source})-?(${F.source})$`);
  var x = new RegExp(`^(?:--)?(${F.source})-?(${Y.source})$`);
  var H = /(\d+)(?:[.,](\d{1,9}))?/;
  var q = new RegExp(`(?:${H.source}H)?(?:${H.source}M)?(?:${H.source}S)?`);
  var W = new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${q.source})?$`, "i");
  var z = Array.prototype.includes;
  var _ = Array.prototype.push;
  var J = globalThis.Intl.DateTimeFormat;
  var V = Math.min;
  var X = Math.max;
  var K = Math.abs;
  var Q = Math.floor;
  var ee = Math.sign;
  var te = Math.trunc;
  var re = Number.isNaN;
  var oe = Number.isFinite;
  var ne = Number;
  var ae = String;
  var ie = Number.MAX_SAFE_INTEGER;
  var se = Object.assign;
  var le = Object.create;
  var de = Object.getOwnPropertyDescriptor;
  var me = Object.is;
  var ce = Reflect.apply;
  var he = import_jsbi.default.BigInt(0);
  var ue = import_jsbi.default.BigInt(1);
  var Te = import_jsbi.default.BigInt(60);
  var pe = import_jsbi.default.BigInt(1e3);
  var fe = import_jsbi.default.BigInt(1e6);
  var ye = import_jsbi.default.BigInt(1e9);
  var Se = import_jsbi.default.BigInt(-1);
  var we = import_jsbi.default.multiply(import_jsbi.default.BigInt(86400), ye);
  var ge = import_jsbi.default.multiply(import_jsbi.default.BigInt(-86400), import_jsbi.default.BigInt(1e17));
  var Ie = import_jsbi.default.multiply(import_jsbi.default.BigInt(86400), import_jsbi.default.BigInt(1e17));
  var De = import_jsbi.default.multiply(import_jsbi.default.BigInt(-388152), import_jsbi.default.BigInt(1e13));
  var Ge = import_jsbi.default.multiply(we, import_jsbi.default.BigInt(3660));
  var ve = import_jsbi.default.multiply(we, import_jsbi.default.BigInt(366));
  var Oe = import_jsbi.default.multiply(we, import_jsbi.default.BigInt(14));
  var Ce = ["iso8601", "hebrew", "islamic", "islamic-umalqura", "islamic-tbla", "islamic-civil", "islamic-rgsa", "islamicc", "persian", "ethiopic", "ethioaa", "coptic", "chinese", "dangi", "roc", "indian", "buddhist", "japanese", "gregory"];
  function IsInteger(e2) {
    if ("number" != typeof e2 || !oe(e2))
      return false;
    const t2 = K(e2);
    return Q(t2) === t2;
  }
  function IsObject(e2) {
    return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
  }
  function ToNumber(e2) {
    if ("bigint" == typeof e2)
      throw new TypeError("Cannot convert BigInt to number");
    return ne(e2);
  }
  function ToInteger(e2) {
    const t2 = ToNumber(e2);
    if (re(t2))
      return 0;
    const r2 = te(t2);
    return 0 === t2 ? 0 : r2;
  }
  function ToString(e2) {
    if ("symbol" == typeof e2)
      throw new TypeError("Cannot convert a Symbol value to a String");
    return ae(e2);
  }
  function ToIntegerThrowOnInfinity(e2) {
    const t2 = ToInteger(e2);
    if (!oe(t2))
      throw new RangeError("infinity is out of range");
    return t2;
  }
  function ToPositiveInteger(e2, t2) {
    const r2 = ToInteger(e2);
    if (!oe(r2))
      throw new RangeError("infinity is out of range");
    if (r2 < 1) {
      if (void 0 !== t2)
        throw new RangeError(`property '${t2}' cannot be a a number less than one`);
      throw new RangeError("Cannot convert a number less than one to a positive integer");
    }
    return r2;
  }
  function ToIntegerWithoutRounding(e2) {
    const t2 = ToNumber(e2);
    if (re(t2))
      return 0;
    if (!oe(t2))
      throw new RangeError("infinity is out of range");
    if (!IsInteger(t2))
      throw new RangeError(`unsupported fractional value ${t2}`);
    return ToInteger(t2);
  }
  function divmod(t2, r2) {
    return { quotient: import_jsbi.default.divide(t2, r2), remainder: import_jsbi.default.remainder(t2, r2) };
  }
  function abs(t2) {
    return import_jsbi.default.lessThan(t2, he) ? import_jsbi.default.multiply(t2, Se) : t2;
  }
  function ArrayPush(e2, ...t2) {
    return _.apply(e2, t2), e2;
  }
  var Ee = /* @__PURE__ */ new Map([["year", ToIntegerThrowOnInfinity], ["month", ToPositiveInteger], ["monthCode", ToString], ["day", ToPositiveInteger], ["hour", ToIntegerThrowOnInfinity], ["minute", ToIntegerThrowOnInfinity], ["second", ToIntegerThrowOnInfinity], ["millisecond", ToIntegerThrowOnInfinity], ["microsecond", ToIntegerThrowOnInfinity], ["nanosecond", ToIntegerThrowOnInfinity], ["years", ToIntegerWithoutRounding], ["months", ToIntegerWithoutRounding], ["weeks", ToIntegerWithoutRounding], ["days", ToIntegerWithoutRounding], ["hours", ToIntegerWithoutRounding], ["minutes", ToIntegerWithoutRounding], ["seconds", ToIntegerWithoutRounding], ["milliseconds", ToIntegerWithoutRounding], ["microseconds", ToIntegerWithoutRounding], ["nanoseconds", ToIntegerWithoutRounding], ["era", ToString], ["eraYear", ToInteger], ["offset", ToString]]);
  var be = /* @__PURE__ */ new Map([["hour", 0], ["minute", 0], ["second", 0], ["millisecond", 0], ["microsecond", 0], ["nanosecond", 0]]);
  var Me = [["years", "year", "date"], ["months", "month", "date"], ["weeks", "week", "date"], ["days", "day", "date"], ["hours", "hour", "time"], ["minutes", "minute", "time"], ["seconds", "second", "time"], ["milliseconds", "millisecond", "time"], ["microseconds", "microsecond", "time"], ["nanoseconds", "nanosecond", "time"]];
  var Re = new Map(Me.map((e2) => [e2[0], e2[1]]));
  var Ze = new Map(Me.map(([e2, t2]) => [t2, e2]));
  var Pe = Me.map(([, e2]) => e2);
  var Fe = Array.from(Re.keys()).sort();
  var Ye = /* @__PURE__ */ new Map();
  function getIntlDateTimeFormatEnUsForTimeZone(e2) {
    let t2 = Ye.get(e2);
    return void 0 === t2 && (t2 = new J("en-us", { timeZone: ae(e2), hour12: false, era: "short", year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), Ye.set(e2, t2)), t2;
  }
  function IsTemporalInstant(e2) {
    return HasSlot(e2, r) && !HasSlot(e2, p, u);
  }
  function IsTemporalTimeZone(e2) {
    return HasSlot(e2, o);
  }
  function IsTemporalCalendar(e2) {
    return HasSlot(e2, C);
  }
  function IsTemporalDuration(e2) {
    return HasSlot(e2, f, y, w, g, I, D, G, v, O);
  }
  function IsTemporalDate(e2) {
    return HasSlot(e2, "slot-date-brand");
  }
  function IsTemporalTime(e2) {
    return HasSlot(e2, s, l, d, m, c, h) && !HasSlot(e2, n, a, i);
  }
  function IsTemporalDateTime(e2) {
    return HasSlot(e2, n, a, i, s, l, d, m, c, h);
  }
  function IsTemporalYearMonth(e2) {
    return HasSlot(e2, "slot-year-month-brand");
  }
  function IsTemporalMonthDay(e2) {
    return HasSlot(e2, "slot-month-day-brand");
  }
  function IsTemporalZonedDateTime(e2) {
    return HasSlot(e2, r, p, u);
  }
  function RejectObjectWithCalendarOrTimeZone(e2) {
    if (HasSlot(e2, u) || HasSlot(e2, p))
      throw new TypeError("with() does not support a calendar or timeZone property");
    if (void 0 !== e2.calendar)
      throw new TypeError("with() does not support a calendar property");
    if (void 0 !== e2.timeZone)
      throw new TypeError("with() does not support a timeZone property");
  }
  function ParseTemporalTimeZone(e2) {
    let { ianaName: t2, offset: r2, z: o2 } = function ParseTemporalTimeZoneString(e3) {
      try {
        let t3 = GetCanonicalTimeZoneIdentifier(e3);
        if (t3)
          return { ianaName: t3.toString() };
      } catch {
      }
      try {
        const t3 = ParseISODateTime(e3);
        if (t3.z || t3.offset || t3.ianaName)
          return t3;
      } catch {
      }
      throw new RangeError(`Invalid time zone: ${e3}`);
    }(e2);
    return t2 || (o2 ? "UTC" : r2);
  }
  function FormatCalendarAnnotation(e2, t2) {
    return "never" === t2 || "auto" === t2 && "iso8601" === e2 ? "" : `[u-ca=${e2}]`;
  }
  function ParseISODateTime(e2) {
    const t2 = A.exec(e2);
    if (!t2)
      throw new RangeError(`invalid ISO 8601 string: ${e2}`);
    let r2 = t2[1];
    if ("\u2212" === r2[0] && (r2 = `-${r2.slice(1)}`), "-000000" === r2)
      throw new RangeError(`invalid ISO 8601 string: ${e2}`);
    const o2 = ToInteger(r2), n2 = ToInteger(t2[2] || t2[4]), a2 = ToInteger(t2[3] || t2[5]), i2 = ToInteger(t2[6]), s2 = void 0 !== t2[6], l2 = ToInteger(t2[7] || t2[10]);
    let d2 = ToInteger(t2[8] || t2[11]);
    60 === d2 && (d2 = 59);
    const m2 = (t2[9] || t2[12]) + "000000000", c2 = ToInteger(m2.slice(0, 3)), h2 = ToInteger(m2.slice(3, 6)), u2 = ToInteger(m2.slice(6, 9));
    let T2, p2 = false;
    if (t2[13])
      T2 = void 0, p2 = true;
    else if (t2[14] && t2[15]) {
      const e3 = "-" === t2[14] || "\u2212" === t2[14] ? "-" : "+", r3 = t2[15] || "00", o3 = t2[16] || "00", n3 = t2[17] || "00";
      let a3 = t2[18] || "0";
      if (T2 = `${e3}${r3}:${o3}`, +a3) {
        for (; a3.endsWith("0"); )
          a3 = a3.slice(0, -1);
        T2 += `:${n3}.${a3}`;
      } else
        +n3 && (T2 += `:${n3}`);
      "-00:00" === T2 && (T2 = "+00:00");
    }
    let f2 = t2[19];
    if (f2)
      try {
        f2 = GetCanonicalTimeZoneIdentifier(f2).toString();
      } catch {
      }
    const y2 = t2[20];
    return RejectDateTime(o2, n2, a2, i2, l2, d2, c2, h2, u2), { year: o2, month: n2, day: a2, hasTime: s2, hour: i2, minute: l2, second: d2, millisecond: c2, microsecond: h2, nanosecond: u2, ianaName: f2, offset: T2, z: p2, calendar: y2 };
  }
  function ParseTemporalYearMonthString(e2) {
    const t2 = L.exec(e2);
    let r2, o2, n2, a2;
    if (t2) {
      let a3 = t2[1];
      if ("\u2212" === a3[0] && (a3 = `-${a3.slice(1)}`), "-000000" === a3)
        throw new RangeError(`invalid ISO 8601 string: ${e2}`);
      r2 = ToInteger(a3), o2 = ToInteger(t2[2]), n2 = t2[3];
    } else {
      let t3;
      if ({ year: r2, month: o2, calendar: n2, day: a2, z: t3 } = ParseISODateTime(e2), t3)
        throw new RangeError("Z designator not supported for PlainYearMonth");
    }
    return { year: r2, month: o2, calendar: n2, referenceISODay: a2 };
  }
  function ParseTemporalMonthDayString(e2) {
    const t2 = x.exec(e2);
    let r2, o2, n2, a2;
    if (t2)
      r2 = ToInteger(t2[1]), o2 = ToInteger(t2[2]);
    else {
      let t3;
      if ({ month: r2, day: o2, calendar: n2, year: a2, z: t3 } = ParseISODateTime(e2), t3)
        throw new RangeError("Z designator not supported for PlainMonthDay");
    }
    return { month: r2, day: o2, calendar: n2, referenceISOYear: a2 };
  }
  function ParseTemporalDurationString(e2) {
    const t2 = W.exec(e2);
    if (!t2)
      throw new RangeError(`invalid duration: ${e2}`);
    if (t2.slice(2).every((e3) => void 0 === e3))
      throw new RangeError(`invalid duration: ${e2}`);
    const r2 = "-" === t2[1] || "\u2212" === t2[1] ? -1 : 1, o2 = ToInteger(t2[2]) * r2, n2 = ToInteger(t2[3]) * r2, a2 = ToInteger(t2[4]) * r2, i2 = ToInteger(t2[5]) * r2, s2 = ToInteger(t2[6]) * r2;
    let l2 = t2[7], d2 = ToInteger(t2[8]) * r2, m2 = t2[9], c2 = ToInteger(t2[10]) * r2;
    const h2 = t2[11] + "000000000";
    let u2 = ToInteger(h2.slice(0, 3)) * r2, T2 = ToInteger(h2.slice(3, 6)) * r2, p2 = ToInteger(h2.slice(6, 9)) * r2;
    return l2 = l2 ? r2 * ToInteger(l2) / 10 ** l2.length : 0, m2 = m2 ? r2 * ToInteger(m2) / 10 ** m2.length : 0, { minutes: d2, seconds: c2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = function DurationHandleFractions(e3, t3, r3, o3, n3, a3, i3) {
      let s3 = e3, l3 = t3, d3 = r3, m3 = o3, c3 = n3, h3 = a3, u3 = i3;
      if (0 !== s3) {
        [l3, d3, m3, c3, h3, u3].forEach((e5) => {
          if (0 !== e5)
            throw new RangeError("only the smallest unit can be fractional");
        });
        const e4 = 60 * s3;
        l3 = te(e4), d3 = e4 % 1;
      }
      if (0 !== d3) {
        [m3, c3, h3, u3].forEach((e5) => {
          if (0 !== e5)
            throw new RangeError("only the smallest unit can be fractional");
        });
        const e4 = 60 * d3;
        m3 = te(e4);
        const t4 = e4 % 1;
        if (0 !== t4) {
          const e5 = 1e3 * t4;
          c3 = te(e5);
          const r4 = e5 % 1;
          if (0 !== r4) {
            const e6 = 1e3 * r4;
            h3 = te(e6);
            const t5 = e6 % 1;
            if (0 !== t5) {
              u3 = te(1e3 * t5);
            }
          }
        }
      }
      return { minutes: l3, seconds: m3, milliseconds: c3, microseconds: h3, nanoseconds: u3 };
    }(l2, d2, m2, c2, u2, T2, p2), RejectDuration(o2, n2, a2, i2, s2, d2, c2, u2, T2, p2), { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: d2, seconds: c2, milliseconds: u2, microseconds: T2, nanoseconds: p2 };
  }
  function ParseTemporalInstant(e2) {
    let { year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2, offset: m2, z: c2 } = function ParseTemporalInstantString(e3) {
      const t3 = ParseISODateTime(e3);
      if (!t3.z && !t3.offset)
        throw new RangeError("Temporal.Instant requires a time zone offset");
      return t3;
    }(e2);
    if (!c2 && !m2)
      throw new RangeError("Temporal.Instant requires a time zone offset");
    const h2 = c2 ? 0 : ParseTimeZoneOffsetString(m2);
    ({ year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2 } = BalanceISODateTime(t2, r2, o2, n2, a2, i2, s2, l2, d2 - h2));
    const u2 = GetEpochFromISOParts(t2, r2, o2, n2, a2, i2, s2, l2, d2);
    if (null === u2)
      throw new RangeError("DateTime outside of supported range");
    return u2;
  }
  function RegulateISODate(e2, t2, r2, o2) {
    let n2 = e2, a2 = t2, i2 = r2;
    switch (o2) {
      case "reject":
        RejectISODate(n2, a2, i2);
        break;
      case "constrain":
        ({ year: n2, month: a2, day: i2 } = ConstrainISODate(n2, a2, i2));
    }
    return { year: n2, month: a2, day: i2 };
  }
  function RegulateTime(e2, t2, r2, o2, n2, a2, i2) {
    let s2 = e2, l2 = t2, d2 = r2, m2 = o2, c2 = n2, h2 = a2;
    switch (i2) {
      case "reject":
        RejectTime(s2, l2, d2, m2, c2, h2);
        break;
      case "constrain":
        ({ hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 } = function ConstrainTime(e3, t3, r3, o3, n3, a3) {
          const i3 = ConstrainToRange(e3, 0, 23), s3 = ConstrainToRange(t3, 0, 59), l3 = ConstrainToRange(r3, 0, 59), d3 = ConstrainToRange(o3, 0, 999), m3 = ConstrainToRange(n3, 0, 999), c3 = ConstrainToRange(a3, 0, 999);
          return { hour: i3, minute: s3, second: l3, millisecond: d3, microsecond: m3, nanosecond: c3 };
        }(s2, l2, d2, m2, c2, h2));
    }
    return { hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 };
  }
  function ToTemporalDurationRecord(e2) {
    if (!IsObject(e2))
      return ParseTemporalDurationString(ToString(e2));
    if (IsTemporalDuration(e2))
      return { years: GetSlot(e2, f), months: GetSlot(e2, y), weeks: GetSlot(e2, S), days: GetSlot(e2, w), hours: GetSlot(e2, g), minutes: GetSlot(e2, I), seconds: GetSlot(e2, D), milliseconds: GetSlot(e2, G), microseconds: GetSlot(e2, v), nanoseconds: GetSlot(e2, O) };
    const t2 = { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
    let r2 = function ToTemporalPartialDurationRecord(e3) {
      if (!IsObject(e3))
        throw new TypeError("invalid duration-like");
      const t3 = { years: void 0, months: void 0, weeks: void 0, days: void 0, hours: void 0, minutes: void 0, seconds: void 0, milliseconds: void 0, microseconds: void 0, nanoseconds: void 0 };
      let r3 = false;
      for (const o3 of Fe) {
        const n3 = e3[o3];
        void 0 !== n3 && (r3 = true, t3[o3] = ToIntegerWithoutRounding(n3));
      }
      if (!r3)
        throw new TypeError("invalid duration-like");
      return t3;
    }(e2);
    for (const e3 of Fe) {
      const o3 = r2[e3];
      void 0 !== o3 && (t2[e3] = o3);
    }
    let { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 } = t2;
    return RejectDuration(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 };
  }
  function ToTemporalOverflow(e2) {
    return void 0 === e2 ? "constrain" : GetOption(e2, "overflow", ["constrain", "reject"], "constrain");
  }
  function ToTemporalDisambiguation(e2) {
    return void 0 === e2 ? "compatible" : GetOption(e2, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
  }
  function ToTemporalRoundingMode(e2, t2) {
    return GetOption(e2, "roundingMode", ["ceil", "floor", "trunc", "halfExpand"], t2);
  }
  function NegateTemporalRoundingMode(e2) {
    switch (e2) {
      case "ceil":
        return "floor";
      case "floor":
        return "ceil";
      default:
        return e2;
    }
  }
  function ToTemporalOffset(e2, t2) {
    return void 0 === e2 ? t2 : GetOption(e2, "offset", ["prefer", "use", "ignore", "reject"], t2);
  }
  function ToShowCalendarOption(e2) {
    return GetOption(e2, "calendarName", ["auto", "always", "never"], "auto");
  }
  function ToTemporalRoundingIncrement(e2, t2, r2) {
    let o2 = 1 / 0;
    void 0 !== t2 && (o2 = t2), r2 || void 0 === t2 || (o2 = t2 > 1 ? t2 - 1 : 1);
    const n2 = function GetNumberOption(e3, t3, r3, o3, n3) {
      let a2 = e3[t3];
      if (void 0 === a2)
        return n3;
      const i2 = ToNumber(a2);
      if (re(i2) || i2 < r3 || i2 > o3)
        throw new RangeError(`${String(t3)} must be between ${r3} and ${o3}, not ${i2}`);
      return Q(i2);
    }(e2, "roundingIncrement", 1, o2, 1);
    if (void 0 !== t2 && t2 % n2 != 0)
      throw new RangeError(`Rounding increment must divide evenly into ${t2}`);
    return n2;
  }
  function ToTemporalDateTimeRoundingIncrement(e2, t2) {
    return ToTemporalRoundingIncrement(e2, { year: void 0, month: void 0, week: void 0, day: void 0, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[t2], false);
  }
  function ToSecondsStringPrecision(e2) {
    const t2 = GetTemporalUnit(e2, "smallestUnit", "time", void 0);
    if ("hour" === t2) {
      const e3 = Me.reduce((e4, [t3, r3, o3]) => ("time" === o3 && "hour" !== r3 && e4.push(r3, t3), e4), []);
      throw new RangeError(`smallestUnit must be one of ${e3.join(", ")}, not ${t2}`);
    }
    switch (t2) {
      case "minute":
        return { precision: "minute", unit: "minute", increment: 1 };
      case "second":
        return { precision: 0, unit: "second", increment: 1 };
      case "millisecond":
        return { precision: 3, unit: "millisecond", increment: 1 };
      case "microsecond":
        return { precision: 6, unit: "microsecond", increment: 1 };
      case "nanosecond":
        return { precision: 9, unit: "nanosecond", increment: 1 };
    }
    let r2 = e2.fractionalSecondDigits;
    if (void 0 === r2 && (r2 = "auto"), "number" != typeof r2) {
      const e3 = ToString(r2);
      if ("auto" === e3)
        return { precision: "auto", unit: "nanosecond", increment: 1 };
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${e3}`);
    }
    if (re(r2) || r2 < 0 || r2 > 9)
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${r2}`);
    const o2 = Q(r2);
    switch (o2) {
      case 0:
        return { precision: o2, unit: "second", increment: 1 };
      case 1:
      case 2:
      case 3:
        return { precision: o2, unit: "millisecond", increment: 10 ** (3 - o2) };
      case 4:
      case 5:
      case 6:
        return { precision: o2, unit: "microsecond", increment: 10 ** (6 - o2) };
      case 7:
      case 8:
      case 9:
        return { precision: o2, unit: "nanosecond", increment: 10 ** (9 - o2) };
      default:
        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${r2}`);
    }
  }
  var je = Symbol("~required~");
  function GetTemporalUnit(e2, t2, r2, o2, n2 = []) {
    const a2 = [];
    for (const [, e3, t3] of Me)
      "datetime" !== r2 && r2 !== t3 || a2.push(e3);
    a2.push(...n2);
    let i2 = o2;
    i2 === je ? i2 = void 0 : void 0 !== i2 && a2.push(i2);
    const s2 = [...a2];
    for (const e3 of a2) {
      const t3 = Ze.get(e3);
      void 0 !== t3 && s2.push(t3);
    }
    let l2 = GetOption(e2, t2, s2, i2);
    if (void 0 === l2 && o2 === je)
      throw new RangeError(`${t2} is required`);
    return Re.has(l2) ? Re.get(l2) : l2;
  }
  function ToRelativeTemporalObject(e2) {
    const t2 = e2.relativeTo;
    if (void 0 === t2)
      return t2;
    let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = "option", p2 = false;
    if (IsObject(t2)) {
      if (IsTemporalZonedDateTime(t2) || IsTemporalDate(t2))
        return t2;
      if (IsTemporalDateTime(t2))
        return TemporalDateTimeToDate(t2);
      c2 = GetTemporalCalendarWithISODefault(t2);
      const e3 = PrepareTemporalFields(t2, CalendarFields(c2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []), p3 = le(null);
      p3.overflow = "constrain", { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(c2, e3, p3), u2 = t2.offset, void 0 === u2 && (T2 = "wall"), h2 = t2.timeZone;
    } else {
      let e3, f2;
      ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, calendar: c2, ianaName: e3, offset: u2, z: f2 } = ParseISODateTime(ToString(t2))), e3 && (h2 = e3), f2 ? T2 = "exact" : u2 || (T2 = "wall"), c2 || (c2 = GetISO8601Calendar()), c2 = ToTemporalCalendar(c2), p2 = true;
    }
    if (void 0 !== h2) {
      h2 = ToTemporalTimeZone(h2);
      let e3 = 0;
      "option" === T2 && (e3 = ParseTimeZoneOffsetString(ToString(u2)));
      return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, T2, e3, h2, "compatible", "reject", p2), h2, c2);
    }
    return CreateTemporalDate(r2, o2, n2, c2);
  }
  function DefaultTemporalLargestUnit(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
    for (const [m2, c2] of [["years", e2], ["months", t2], ["weeks", r2], ["days", o2], ["hours", n2], ["minutes", a2], ["seconds", i2], ["milliseconds", s2], ["microseconds", l2], ["nanoseconds", d2]])
      if (0 !== c2)
        return Re.get(m2);
    return "nanosecond";
  }
  function LargerOfTwoTemporalUnits(e2, t2) {
    return Pe.indexOf(e2) > Pe.indexOf(t2) ? t2 : e2;
  }
  function MergeLargestUnitOption(e2, t2) {
    let r2 = e2;
    return void 0 === r2 && (r2 = le(null)), se(le(null), r2, { largestUnit: t2 });
  }
  function PrepareTemporalFields(e2, t2, r2, { emptySourceErrorMessage: o2 } = { emptySourceErrorMessage: "no supported properties found" }) {
    const n2 = le(null);
    let a2 = false;
    for (const o3 of t2) {
      let t3 = e2[o3];
      if (void 0 !== t3)
        a2 = true, Ee.has(o3) && (t3 = Ee.get(o3)(t3)), n2[o3] = t3;
      else if ("partial" !== r2) {
        if (z.call(r2, o3))
          throw new TypeError(`required property '${o3}' missing or undefined`);
        t3 = be.get(o3), n2[o3] = t3;
      }
    }
    if ("partial" === r2 && !a2)
      throw new TypeError(o2);
    if (void 0 === n2.era != (void 0 === n2.eraYear))
      throw new RangeError("properties 'era' and 'eraYear' must be provided together");
    return n2;
  }
  function ToTemporalTimeRecord(e2, t2 = "complete") {
    const r2 = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"], o2 = PrepareTemporalFields(e2, r2, "partial", { emptySourceErrorMessage: "invalid time-like" }), n2 = {};
    for (const e3 of r2) {
      const r3 = de(o2, e3);
      void 0 !== r3 ? n2[e3] = r3.value : "complete" === t2 && (n2[e3] = 0);
    }
    return n2;
  }
  function ToTemporalDate(e2, t2) {
    let r2 = e2;
    if (IsObject(r2)) {
      if (IsTemporalDate(r2))
        return r2;
      if (IsTemporalZonedDateTime(r2) && (ToTemporalOverflow(t2), r2 = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(r2, p), GetSlot(r2, T), GetSlot(r2, u))), IsTemporalDateTime(r2))
        return ToTemporalOverflow(t2), CreateTemporalDate(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(r2, u));
      const e3 = GetTemporalCalendarWithISODefault(r2);
      return CalendarDateFromFields(e3, PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []), t2);
    }
    ToTemporalOverflow(t2);
    const { year: o2, month: s2, day: l2, calendar: d2, z: m2 } = function ParseTemporalDateString(e3) {
      return ParseISODateTime(e3);
    }(ToString(r2));
    if (m2)
      throw new RangeError("Z designator not supported for PlainDate");
    return new (GetIntrinsic("%Temporal.PlainDate%"))(o2, s2, l2, d2);
  }
  function InterpretTemporalDateTimeFields(e2, t2, r2) {
    let { hour: o2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = ToTemporalTimeRecord(t2);
    const h2 = ToTemporalOverflow(r2), u2 = CalendarDateFromFields(e2, t2, r2), T2 = GetSlot(u2, n), p2 = GetSlot(u2, a), f2 = GetSlot(u2, i);
    return { hour: o2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = RegulateTime(o2, s2, l2, d2, m2, c2, h2), { year: T2, month: p2, day: f2, hour: o2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 };
  }
  function ToTemporalDateTime(e2, t2) {
    let r2, o2, s2, l2, d2, m2, c2, h2, f2, y2;
    if (IsObject(e2)) {
      if (IsTemporalDateTime(e2))
        return e2;
      if (IsTemporalZonedDateTime(e2))
        return ToTemporalOverflow(t2), BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(e2, p), GetSlot(e2, T), GetSlot(e2, u));
      if (IsTemporalDate(e2))
        return ToTemporalOverflow(t2), CreateTemporalDateTime(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), 0, 0, 0, 0, 0, 0, GetSlot(e2, u));
      y2 = GetTemporalCalendarWithISODefault(e2);
      const S2 = PrepareTemporalFields(e2, CalendarFields(y2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []);
      ({ year: r2, month: o2, day: s2, hour: l2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: f2 } = InterpretTemporalDateTimeFields(y2, S2, t2));
    } else {
      let n2;
      if (ToTemporalOverflow(t2), { year: r2, month: o2, day: s2, hour: l2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: f2, calendar: y2, z: n2 } = function ParseTemporalDateTimeString(e3) {
        return ParseISODateTime(e3);
      }(ToString(e2)), n2)
        throw new RangeError("Z designator not supported for PlainDateTime");
      RejectDateTime(r2, o2, s2, l2, d2, m2, c2, h2, f2), void 0 === y2 && (y2 = GetISO8601Calendar()), y2 = ToTemporalCalendar(y2);
    }
    return CreateTemporalDateTime(r2, o2, s2, l2, d2, m2, c2, h2, f2, y2);
  }
  function ToTemporalDuration(e2) {
    if (IsTemporalDuration(e2))
      return e2;
    let { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = ToTemporalDurationRecord(e2);
    return new (GetIntrinsic("%Temporal.Duration%"))(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
  }
  function ToTemporalInstant(e2) {
    if (IsTemporalInstant(e2))
      return e2;
    if (IsTemporalZonedDateTime(e2)) {
      return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, r));
    }
    const t2 = ParseTemporalInstant(ToString(e2));
    return new (GetIntrinsic("%Temporal.Instant%"))(t2);
  }
  function ToTemporalMonthDay(e2, t2) {
    let r2 = e2;
    if (IsObject(r2)) {
      if (IsTemporalMonthDay(r2))
        return r2;
      let e3, o3;
      if (HasSlot(r2, u))
        e3 = GetSlot(r2, u), o3 = false;
      else {
        let t3 = r2.calendar;
        o3 = void 0 === t3, void 0 === t3 && (t3 = GetISO8601Calendar()), e3 = ToTemporalCalendar(t3);
      }
      r2 = r2;
      const n3 = PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []);
      return o3 && void 0 !== n3.month && void 0 === n3.monthCode && void 0 === n3.year && (n3.year = 1972), CalendarMonthDayFromFields(e3, n3, t2);
    }
    ToTemporalOverflow(t2);
    let { month: o2, day: n2, referenceISOYear: a2, calendar: i2 } = ParseTemporalMonthDayString(ToString(r2)), s2 = i2;
    if (void 0 === s2 && (s2 = GetISO8601Calendar()), s2 = ToTemporalCalendar(s2), void 0 === a2)
      return RejectISODate(1972, o2, n2), CreateTemporalMonthDay(o2, n2, s2);
    return CalendarMonthDayFromFields(s2, CreateTemporalMonthDay(o2, n2, s2, a2));
  }
  function ToTemporalTime(e2, t2 = "constrain") {
    let r2, o2, n2, a2, i2, f2, y2, S2 = e2;
    if (IsObject(S2)) {
      if (IsTemporalTime(S2))
        return S2;
      if (IsTemporalZonedDateTime(S2) && (S2 = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(S2, p), GetSlot(S2, T), GetSlot(S2, u))), IsTemporalDateTime(S2)) {
        return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(S2, s), GetSlot(S2, l), GetSlot(S2, d), GetSlot(S2, m), GetSlot(S2, c), GetSlot(S2, h));
      }
      if (y2 = GetTemporalCalendarWithISODefault(S2), "iso8601" !== ToString(y2))
        throw new RangeError("PlainTime can only have iso8601 calendar");
      ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: f2 } = ToTemporalTimeRecord(S2)), { hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: f2 } = RegulateTime(r2, o2, n2, a2, i2, f2, t2);
    } else if ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: f2, calendar: y2 } = function ParseTemporalTimeString(e3) {
      const t3 = U.exec(e3);
      let r3, o3, n3, a3, i3, s2, l2;
      if (t3) {
        r3 = ToInteger(t3[1]), o3 = ToInteger(t3[2] || t3[5]), n3 = ToInteger(t3[3] || t3[6]), 60 === n3 && (n3 = 59);
        const e4 = (t3[4] || t3[7]) + "000000000";
        a3 = ToInteger(e4.slice(0, 3)), i3 = ToInteger(e4.slice(3, 6)), s2 = ToInteger(e4.slice(6, 9)), l2 = t3[15];
      } else {
        let t4, d2;
        if ({ hasTime: d2, hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s2, calendar: l2, z: t4 } = ParseISODateTime(e3), !d2)
          throw new RangeError(`time is missing in string: ${e3}`);
        if (t4)
          throw new RangeError("Z designator not supported for PlainTime");
      }
      if (/[tT ][0-9][0-9]/.test(e3))
        return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s2, calendar: l2 };
      try {
        const { month: t4, day: r4 } = ParseTemporalMonthDayString(e3);
        RejectISODate(1972, t4, r4);
      } catch {
        try {
          const { year: t4, month: r4 } = ParseTemporalYearMonthString(e3);
          RejectISODate(t4, r4, 1);
        } catch {
          return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s2, calendar: l2 };
        }
      }
      throw new RangeError(`invalid ISO 8601 time-only string ${e3}; may need a T prefix`);
    }(ToString(S2)), RejectTime(r2, o2, n2, a2, i2, f2), void 0 !== y2 && "iso8601" !== y2)
      throw new RangeError("PlainTime can only have iso8601 calendar");
    return new (GetIntrinsic("%Temporal.PlainTime%"))(r2, o2, n2, a2, i2, f2);
  }
  function ToTemporalYearMonth(e2, t2) {
    if (IsObject(e2)) {
      if (IsTemporalYearMonth(e2))
        return e2;
      const r3 = GetTemporalCalendarWithISODefault(e2);
      return CalendarYearMonthFromFields(r3, PrepareTemporalFields(e2, CalendarFields(r3, ["month", "monthCode", "year"]), []), t2);
    }
    ToTemporalOverflow(t2);
    let { year: r2, month: o2, referenceISODay: n2, calendar: a2 } = ParseTemporalYearMonthString(ToString(e2)), i2 = a2;
    if (void 0 === i2 && (i2 = GetISO8601Calendar()), i2 = ToTemporalCalendar(i2), void 0 === n2)
      return RejectISODate(r2, o2, 1), CreateTemporalYearMonth(r2, o2, i2);
    return CalendarYearMonthFromFields(i2, CreateTemporalYearMonth(r2, o2, i2, n2));
  }
  function InterpretISODateTimeOffset(t2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2) {
    const S2 = new (GetIntrinsic("%Temporal.PlainDateTime%"))(t2, n2, a2, i2, s2, l2, d2, m2, c2);
    if ("wall" === h2 || "ignore" === f2) {
      return GetSlot(BuiltinTimeZoneGetInstantFor(T2, S2, p2), r);
    }
    if ("exact" === h2 || "use" === f2) {
      const r2 = GetEpochFromISOParts(t2, n2, a2, i2, s2, l2, d2, m2, c2);
      if (null === r2)
        throw new RangeError("ZonedDateTime outside of supported range");
      return import_jsbi.default.subtract(r2, import_jsbi.default.BigInt(u2));
    }
    const w2 = GetPossibleInstantsFor(T2, S2);
    for (const t3 of w2) {
      const o2 = GetOffsetNanosecondsFor(T2, t3), n3 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(o2), 6e10, "halfExpand"));
      if (o2 === u2 || y2 && n3 === u2)
        return GetSlot(t3, r);
    }
    if ("reject" === f2) {
      const e2 = FormatTimeZoneOffsetString(u2), t3 = IsTemporalTimeZone(T2) ? GetSlot(T2, o) : "time zone";
      throw new RangeError(`Offset ${e2} is invalid for ${S2.toString()} in ${t3}`);
    }
    return GetSlot(DisambiguatePossibleInstants(w2, T2, S2, p2), r);
  }
  function ToTemporalZonedDateTime(e2, t2) {
    let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = false, p2 = "option";
    if (IsObject(e2)) {
      if (IsTemporalZonedDateTime(e2))
        return e2;
      u2 = GetTemporalCalendarWithISODefault(e2);
      const T3 = PrepareTemporalFields(e2, ArrayPush(CalendarFields(u2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), "timeZone", "offset"), ["timeZone"]);
      ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(u2, T3, t2)), c2 = ToTemporalTimeZone(T3.timeZone), h2 = T3.offset, void 0 === h2 ? p2 = "wall" : h2 = ToString(h2);
    } else {
      let f3, y2;
      if (ToTemporalOverflow(t2), { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, ianaName: f3, offset: h2, z: y2, calendar: u2 } = function ParseTemporalZonedDateTimeString(e3) {
        const t3 = ParseISODateTime(e3);
        if (!t3.ianaName)
          throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
        return t3;
      }(ToString(e2)), !f3)
        throw new RangeError("time zone ID required in brackets");
      y2 ? p2 = "exact" : h2 || (p2 = "wall");
      c2 = new (GetIntrinsic("%Temporal.TimeZone%"))(f3), u2 || (u2 = GetISO8601Calendar()), u2 = ToTemporalCalendar(u2), T2 = true;
    }
    let f2 = 0;
    "option" === p2 && (f2 = ParseTimeZoneOffsetString(h2));
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, p2, f2, c2, ToTemporalDisambiguation(t2), ToTemporalOffset(t2, "reject"), T2), c2, u2);
  }
  function CreateTemporalDateSlots(e2, t2, r2, o2, s2) {
    RejectISODate(t2, r2, o2), RejectDateRange(t2, r2, o2), CreateSlots(e2), SetSlot(e2, n, t2), SetSlot(e2, a, r2), SetSlot(e2, i, o2), SetSlot(e2, u, s2), SetSlot(e2, "slot-date-brand", true);
  }
  function CreateTemporalDate(e2, t2, r2, o2 = GetISO8601Calendar()) {
    const n2 = GetIntrinsic("%Temporal.PlainDate%"), a2 = le(n2.prototype);
    return CreateTemporalDateSlots(a2, e2, t2, r2, o2), a2;
  }
  function CreateTemporalDateTimeSlots(e2, t2, r2, o2, T2, p2, f2, y2, S2, w2, g2) {
    RejectDateTime(t2, r2, o2, T2, p2, f2, y2, S2, w2), RejectDateTimeRange(t2, r2, o2, T2, p2, f2, y2, S2, w2), CreateSlots(e2), SetSlot(e2, n, t2), SetSlot(e2, a, r2), SetSlot(e2, i, o2), SetSlot(e2, s, T2), SetSlot(e2, l, p2), SetSlot(e2, d, f2), SetSlot(e2, m, y2), SetSlot(e2, c, S2), SetSlot(e2, h, w2), SetSlot(e2, u, g2);
  }
  function CreateTemporalDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2 = GetISO8601Calendar()) {
    const m2 = GetIntrinsic("%Temporal.PlainDateTime%"), c2 = le(m2.prototype);
    return CreateTemporalDateTimeSlots(c2, e2, t2, r2, o2, n2, a2, i2, s2, l2, d2), c2;
  }
  function CreateTemporalMonthDaySlots(e2, t2, r2, o2, s2) {
    RejectISODate(s2, t2, r2), RejectDateRange(s2, t2, r2), CreateSlots(e2), SetSlot(e2, a, t2), SetSlot(e2, i, r2), SetSlot(e2, n, s2), SetSlot(e2, u, o2), SetSlot(e2, "slot-month-day-brand", true);
  }
  function CreateTemporalMonthDay(e2, t2, r2 = GetISO8601Calendar(), o2 = 1972) {
    const n2 = GetIntrinsic("%Temporal.PlainMonthDay%"), a2 = le(n2.prototype);
    return CreateTemporalMonthDaySlots(a2, e2, t2, r2, o2), a2;
  }
  function CreateTemporalYearMonthSlots(e2, t2, r2, o2, s2) {
    RejectISODate(t2, r2, s2), function RejectYearMonthRange(e3, t3) {
      RejectToRange(e3, -271821, 275760), -271821 === e3 ? RejectToRange(t3, 4, 12) : 275760 === e3 && RejectToRange(t3, 1, 9);
    }(t2, r2), CreateSlots(e2), SetSlot(e2, n, t2), SetSlot(e2, a, r2), SetSlot(e2, i, s2), SetSlot(e2, u, o2), SetSlot(e2, "slot-year-month-brand", true);
  }
  function CreateTemporalYearMonth(e2, t2, r2 = GetISO8601Calendar(), o2 = 1) {
    const n2 = GetIntrinsic("%Temporal.PlainYearMonth%"), a2 = le(n2.prototype);
    return CreateTemporalYearMonthSlots(a2, e2, t2, r2, o2), a2;
  }
  function CreateTemporalZonedDateTimeSlots(e2, t2, o2, n2) {
    ValidateEpochNanoseconds(t2), CreateSlots(e2), SetSlot(e2, r, t2), SetSlot(e2, p, o2), SetSlot(e2, u, n2);
    const a2 = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, r));
    SetSlot(e2, T, a2);
  }
  function CreateTemporalZonedDateTime(e2, t2, r2 = GetISO8601Calendar()) {
    const o2 = GetIntrinsic("%Temporal.ZonedDateTime%"), n2 = le(o2.prototype);
    return CreateTemporalZonedDateTimeSlots(n2, e2, t2, r2), n2;
  }
  function GetISO8601Calendar() {
    return new (GetIntrinsic("%Temporal.Calendar%"))("iso8601");
  }
  function CalendarFields(e2, t2) {
    let r2 = t2;
    e2.fields && (r2 = e2.fields(r2));
    const o2 = [];
    for (const e3 of r2) {
      if ("string" != typeof e3)
        throw new TypeError("bad return from calendar.fields()");
      _.call(o2, e3);
    }
    return o2;
  }
  function CalendarMergeFields(e2, t2, r2) {
    const o2 = e2.mergeFields;
    if (!o2)
      return { ...t2, ...r2 };
    const n2 = Reflect.apply(o2, e2, [t2, r2]);
    if (!IsObject(n2))
      throw new TypeError("bad return from calendar.mergeFields()");
    return n2;
  }
  function CalendarDateAdd(e2, t2, r2, o2, n2) {
    let a2 = n2;
    void 0 === a2 && (a2 = e2.dateAdd);
    const i2 = ce(a2, e2, [t2, r2, o2]);
    if (!IsTemporalDate(i2))
      throw new TypeError("invalid result");
    return i2;
  }
  function CalendarDateUntil(e2, t2, r2, o2, n2) {
    let a2 = n2;
    void 0 === a2 && (a2 = e2.dateUntil);
    const i2 = ce(a2, e2, [t2, r2, o2]);
    if (!IsTemporalDuration(i2))
      throw new TypeError("invalid result");
    return i2;
  }
  function CalendarYear(e2, t2) {
    const r2 = e2.year(t2);
    if (void 0 === r2)
      throw new RangeError("calendar year result must be an integer");
    return ToIntegerThrowOnInfinity(r2);
  }
  function CalendarMonth(e2, t2) {
    const r2 = e2.month(t2);
    if (void 0 === r2)
      throw new RangeError("calendar month result must be a positive integer");
    return ToPositiveInteger(r2);
  }
  function CalendarMonthCode(e2, t2) {
    const r2 = e2.monthCode(t2);
    if (void 0 === r2)
      throw new RangeError("calendar monthCode result must be a string");
    return ToString(r2);
  }
  function CalendarDay(e2, t2) {
    const r2 = e2.day(t2);
    if (void 0 === r2)
      throw new RangeError("calendar day result must be a positive integer");
    return ToPositiveInteger(r2);
  }
  function CalendarEra(e2, t2) {
    let r2 = e2.era(t2);
    return void 0 !== r2 && (r2 = ToString(r2)), r2;
  }
  function CalendarEraYear(e2, t2) {
    let r2 = e2.eraYear(t2);
    return void 0 !== r2 && (r2 = ToIntegerThrowOnInfinity(r2)), r2;
  }
  function CalendarDayOfWeek(e2, t2) {
    return e2.dayOfWeek(t2);
  }
  function CalendarDayOfYear(e2, t2) {
    return e2.dayOfYear(t2);
  }
  function CalendarWeekOfYear(e2, t2) {
    return e2.weekOfYear(t2);
  }
  function CalendarDaysInWeek(e2, t2) {
    return e2.daysInWeek(t2);
  }
  function CalendarDaysInMonth(e2, t2) {
    return e2.daysInMonth(t2);
  }
  function CalendarDaysInYear(e2, t2) {
    return e2.daysInYear(t2);
  }
  function CalendarMonthsInYear(e2, t2) {
    return e2.monthsInYear(t2);
  }
  function CalendarInLeapYear(e2, t2) {
    return e2.inLeapYear(t2);
  }
  function ToTemporalCalendar(e2) {
    let t2 = e2;
    if (IsObject(t2)) {
      if (HasSlot(t2, u))
        return GetSlot(t2, u);
      if (!("calendar" in t2))
        return t2;
      if (t2 = t2.calendar, IsObject(t2) && !("calendar" in t2))
        return t2;
    }
    const r2 = ToString(t2), o2 = GetIntrinsic("%Temporal.Calendar%");
    if (IsBuiltinCalendar(r2))
      return new o2(r2);
    let n2;
    try {
      ({ calendar: n2 } = ParseISODateTime(r2));
    } catch {
      throw new RangeError(`Invalid calendar: ${r2}`);
    }
    return n2 || (n2 = "iso8601"), new o2(n2);
  }
  function GetTemporalCalendarWithISODefault(e2) {
    if (HasSlot(e2, u))
      return GetSlot(e2, u);
    const { calendar: t2 } = e2;
    return void 0 === t2 ? GetISO8601Calendar() : ToTemporalCalendar(t2);
  }
  function CalendarEquals(e2, t2) {
    if (e2 === t2)
      return true;
    return ToString(e2) === ToString(t2);
  }
  function ConsolidateCalendars(e2, t2) {
    if (e2 === t2)
      return t2;
    const r2 = ToString(e2), o2 = ToString(t2);
    if (r2 === o2 || "iso8601" === r2)
      return t2;
    if ("iso8601" === o2)
      return e2;
    throw new RangeError("irreconcilable calendars");
  }
  function CalendarDateFromFields(e2, t2, r2) {
    const o2 = e2.dateFromFields(t2, r2);
    if (!IsTemporalDate(o2))
      throw new TypeError("invalid result");
    return o2;
  }
  function CalendarYearMonthFromFields(e2, t2, r2) {
    const o2 = e2.yearMonthFromFields(t2, r2);
    if (!IsTemporalYearMonth(o2))
      throw new TypeError("invalid result");
    return o2;
  }
  function CalendarMonthDayFromFields(e2, t2, r2) {
    const o2 = e2.monthDayFromFields(t2, r2);
    if (!IsTemporalMonthDay(o2))
      throw new TypeError("invalid result");
    return o2;
  }
  function ToTemporalTimeZone(e2) {
    let t2 = e2;
    if (IsObject(t2)) {
      if (IsTemporalZonedDateTime(t2))
        return GetSlot(t2, p);
      if (!("timeZone" in t2))
        return t2;
      if (t2 = t2.timeZone, IsObject(t2) && !("timeZone" in t2))
        return t2;
    }
    const r2 = ParseTemporalTimeZone(ToString(t2));
    return new (GetIntrinsic("%Temporal.TimeZone%"))(r2);
  }
  function TimeZoneEquals(e2, t2) {
    if (e2 === t2)
      return true;
    return ToString(e2) === ToString(t2);
  }
  function TemporalDateTimeToDate(e2) {
    return CreateTemporalDate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, u));
  }
  function TemporalDateTimeToTime(e2) {
    return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h));
  }
  function GetOffsetNanosecondsFor(e2, t2) {
    let r2 = e2.getOffsetNanosecondsFor;
    if ("function" != typeof r2)
      throw new TypeError("getOffsetNanosecondsFor not callable");
    const o2 = Reflect.apply(r2, e2, [t2]);
    if ("number" != typeof o2)
      throw new TypeError("bad return from getOffsetNanosecondsFor");
    if (!IsInteger(o2) || K(o2) > 864e11)
      throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
    return o2;
  }
  function BuiltinTimeZoneGetOffsetStringFor(e2, t2) {
    return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e2, t2));
  }
  function BuiltinTimeZoneGetPlainDateTimeFor(e2, t2, o2) {
    const n2 = GetSlot(t2, r), a2 = GetOffsetNanosecondsFor(e2, t2);
    let { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = GetISOPartsFromEpoch(n2);
    return { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = BalanceISODateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2 + a2), CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, o2);
  }
  function BuiltinTimeZoneGetInstantFor(e2, t2, r2) {
    return DisambiguatePossibleInstants(GetPossibleInstantsFor(e2, t2), e2, t2, r2);
  }
  function DisambiguatePossibleInstants(t2, r2, o2, T2) {
    const p2 = GetIntrinsic("%Temporal.Instant%"), f2 = t2.length;
    if (1 === f2)
      return t2[0];
    if (f2)
      switch (T2) {
        case "compatible":
        case "earlier":
          return t2[0];
        case "later":
          return t2[f2 - 1];
        case "reject":
          throw new RangeError("multiple instants found");
      }
    const y2 = GetSlot(o2, n), S2 = GetSlot(o2, a), w2 = GetSlot(o2, i), g2 = GetSlot(o2, s), I2 = GetSlot(o2, l), D2 = GetSlot(o2, d), G2 = GetSlot(o2, m), v2 = GetSlot(o2, c), O2 = GetSlot(o2, h), C2 = GetEpochFromISOParts(y2, S2, w2, g2, I2, D2, G2, v2, O2);
    if (null === C2)
      throw new RangeError("DateTime outside of supported range");
    const E2 = new p2(import_jsbi.default.subtract(C2, we)), b2 = new p2(import_jsbi.default.add(C2, we)), M2 = GetOffsetNanosecondsFor(r2, E2), R2 = GetOffsetNanosecondsFor(r2, b2) - M2;
    switch (T2) {
      case "earlier": {
        const e2 = GetSlot(o2, u), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n2 = AddDateTime(y2, S2, w2, g2, I2, D2, G2, v2, O2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -R2, void 0);
        return GetPossibleInstantsFor(r2, new t3(n2.year, n2.month, n2.day, n2.hour, n2.minute, n2.second, n2.millisecond, n2.microsecond, n2.nanosecond, e2))[0];
      }
      case "compatible":
      case "later": {
        const e2 = GetSlot(o2, u), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n2 = AddDateTime(y2, S2, w2, g2, I2, D2, G2, v2, O2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, R2, void 0), a2 = GetPossibleInstantsFor(r2, new t3(n2.year, n2.month, n2.day, n2.hour, n2.minute, n2.second, n2.millisecond, n2.microsecond, n2.nanosecond, e2));
        return a2[a2.length - 1];
      }
      case "reject":
        throw new RangeError("no such instant found");
    }
  }
  function GetPossibleInstantsFor(e2, t2) {
    const r2 = e2.getPossibleInstantsFor(t2), o2 = [];
    for (const e3 of r2) {
      if (!IsTemporalInstant(e3))
        throw new TypeError("bad return from getPossibleInstantsFor");
      _.call(o2, e3);
    }
    return o2;
  }
  function ISOYearString(e2) {
    let t2;
    if (e2 < 0 || e2 > 9999) {
      t2 = (e2 < 0 ? "-" : "+") + `000000${K(e2)}`.slice(-6);
    } else
      t2 = `0000${e2}`.slice(-4);
    return t2;
  }
  function ISODateTimePartString(e2) {
    return `00${e2}`.slice(-2);
  }
  function FormatSecondsStringPart(e2, t2, r2, o2, n2) {
    if ("minute" === n2)
      return "";
    const a2 = `:${ISODateTimePartString(e2)}`;
    let i2, s2 = 1e6 * t2 + 1e3 * r2 + o2;
    if ("auto" === n2) {
      if (0 === s2)
        return a2;
      for (i2 = `${s2}`.padStart(9, "0"); "0" === i2[i2.length - 1]; )
        i2 = i2.slice(0, -1);
    } else {
      if (0 === n2)
        return a2;
      i2 = `${s2}`.padStart(9, "0").slice(0, n2);
    }
    return `${a2}.${i2}`;
  }
  function TemporalInstantToString(e2, t2, r2) {
    let o2 = t2;
    if (void 0 === o2) {
      o2 = new (GetIntrinsic("%Temporal.TimeZone%"))("UTC");
    }
    const u2 = BuiltinTimeZoneGetPlainDateTimeFor(o2, e2, GetISO8601Calendar()), T2 = ISOYearString(GetSlot(u2, n)), p2 = ISODateTimePartString(GetSlot(u2, a)), f2 = ISODateTimePartString(GetSlot(u2, i)), y2 = ISODateTimePartString(GetSlot(u2, s)), S2 = ISODateTimePartString(GetSlot(u2, l)), w2 = FormatSecondsStringPart(GetSlot(u2, d), GetSlot(u2, m), GetSlot(u2, c), GetSlot(u2, h), r2);
    let g2 = "Z";
    if (void 0 !== t2) {
      g2 = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o2, e2));
    }
    return `${T2}-${p2}-${f2}T${y2}:${S2}${w2}${g2}`;
  }
  function TemporalDurationToString(t2, r2 = "auto", o2) {
    function formatNumber(t3) {
      return t3 <= ie ? t3.toString(10) : import_jsbi.default.BigInt(t3).toString(10);
    }
    const n2 = GetSlot(t2, f), a2 = GetSlot(t2, y), i2 = GetSlot(t2, S), s2 = GetSlot(t2, w), l2 = GetSlot(t2, g), d2 = GetSlot(t2, I);
    let m2 = GetSlot(t2, D), c2 = GetSlot(t2, G), h2 = GetSlot(t2, v), u2 = GetSlot(t2, O);
    const T2 = DurationSign(n2, a2, i2, s2, l2, d2, m2, c2, h2, u2);
    if (o2) {
      const { unit: e2, increment: t3, roundingMode: r3 } = o2;
      ({ seconds: m2, milliseconds: c2, microseconds: h2, nanoseconds: u2 } = RoundDuration(0, 0, 0, 0, 0, 0, m2, c2, h2, u2, t3, e2, r3));
    }
    const p2 = [];
    n2 && p2.push(`${formatNumber(K(n2))}Y`), a2 && p2.push(`${formatNumber(K(a2))}M`), i2 && p2.push(`${formatNumber(K(i2))}W`), s2 && p2.push(`${formatNumber(K(s2))}D`);
    const C2 = [];
    l2 && C2.push(`${formatNumber(K(l2))}H`), d2 && C2.push(`${formatNumber(K(d2))}M`);
    const E2 = [];
    let b2, M2, R2, Z2, P2 = TotalDurationNanoseconds(0, 0, 0, m2, c2, h2, u2, 0);
    ({ quotient: P2, remainder: b2 } = divmod(P2, pe)), { quotient: P2, remainder: M2 } = divmod(P2, pe), { quotient: Z2, remainder: R2 } = divmod(P2, pe);
    const F2 = 1e6 * K(import_jsbi.default.toNumber(R2)) + 1e3 * K(import_jsbi.default.toNumber(M2)) + K(import_jsbi.default.toNumber(b2));
    let Y2;
    if ("auto" === r2) {
      if (0 !== F2)
        for (Y2 = `${F2}`.padStart(9, "0"); "0" === Y2[Y2.length - 1]; )
          Y2 = Y2.slice(0, -1);
    } else
      0 !== r2 && (Y2 = `${F2}`.padStart(9, "0").slice(0, r2));
    return Y2 && E2.unshift(".", Y2), import_jsbi.default.equal(Z2, he) && !E2.length && "auto" === r2 || E2.unshift(abs(Z2).toString()), E2.length && C2.push(`${E2.join("")}S`), C2.length && C2.unshift("T"), p2.length || C2.length ? `${T2 < 0 ? "-" : ""}P${p2.join("")}${C2.join("")}` : "PT0S";
  }
  function TemporalDateToString(e2, t2 = "auto") {
    return `${ISOYearString(GetSlot(e2, n))}-${ISODateTimePartString(GetSlot(e2, a))}-${ISODateTimePartString(GetSlot(e2, i))}${FormatCalendarAnnotation(ToString(GetSlot(e2, u)), t2)}`;
  }
  function TemporalDateTimeToString(e2, t2, r2 = "auto", o2) {
    let T2 = GetSlot(e2, n), p2 = GetSlot(e2, a), f2 = GetSlot(e2, i), y2 = GetSlot(e2, s), S2 = GetSlot(e2, l), w2 = GetSlot(e2, d), g2 = GetSlot(e2, m), I2 = GetSlot(e2, c), D2 = GetSlot(e2, h);
    if (o2) {
      const { unit: e3, increment: t3, roundingMode: r3 } = o2;
      ({ year: T2, month: p2, day: f2, hour: y2, minute: S2, second: w2, millisecond: g2, microsecond: I2, nanosecond: D2 } = RoundISODateTime(T2, p2, f2, y2, S2, w2, g2, I2, D2, t3, e3, r3));
    }
    return `${ISOYearString(T2)}-${ISODateTimePartString(p2)}-${ISODateTimePartString(f2)}T${ISODateTimePartString(y2)}:${ISODateTimePartString(S2)}${FormatSecondsStringPart(w2, g2, I2, D2, t2)}${FormatCalendarAnnotation(ToString(GetSlot(e2, u)), r2)}`;
  }
  function TemporalMonthDayToString(e2, t2 = "auto") {
    let r2 = `${ISODateTimePartString(GetSlot(e2, a))}-${ISODateTimePartString(GetSlot(e2, i))}`;
    const o2 = ToString(GetSlot(e2, u));
    if ("always" === t2 || "iso8601" !== o2) {
      r2 = `${ISOYearString(GetSlot(e2, n))}-${r2}`;
    }
    const s2 = FormatCalendarAnnotation(o2, t2);
    return s2 && (r2 += s2), r2;
  }
  function TemporalYearMonthToString(e2, t2 = "auto") {
    let r2 = `${ISOYearString(GetSlot(e2, n))}-${ISODateTimePartString(GetSlot(e2, a))}`;
    const o2 = ToString(GetSlot(e2, u));
    if ("always" === t2 || "iso8601" !== o2) {
      r2 += `-${ISODateTimePartString(GetSlot(e2, i))}`;
    }
    const s2 = FormatCalendarAnnotation(o2, t2);
    return s2 && (r2 += s2), r2;
  }
  function TemporalZonedDateTimeToString(e2, t2, o2 = "auto", f2 = "auto", y2 = "auto", S2) {
    let w2 = GetSlot(e2, T);
    if (S2) {
      const { unit: t3, increment: o3, roundingMode: n2 } = S2, a2 = RoundInstant(GetSlot(e2, r), o3, t3, n2);
      w2 = new (GetIntrinsic("%Temporal.Instant%"))(a2);
    }
    const g2 = GetSlot(e2, p), I2 = BuiltinTimeZoneGetPlainDateTimeFor(g2, w2, GetISO8601Calendar());
    let D2 = `${ISOYearString(GetSlot(I2, n))}-${ISODateTimePartString(GetSlot(I2, a))}-${ISODateTimePartString(GetSlot(I2, i))}T${ISODateTimePartString(GetSlot(I2, s))}:${ISODateTimePartString(GetSlot(I2, l))}${FormatSecondsStringPart(GetSlot(I2, d), GetSlot(I2, m), GetSlot(I2, c), GetSlot(I2, h), t2)}`;
    if ("never" !== y2) {
      D2 += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(g2, w2));
    }
    "never" !== f2 && (D2 += `[${g2}]`);
    return D2 += FormatCalendarAnnotation(ToString(GetSlot(e2, u)), o2), D2;
  }
  function TestTimeZoneOffsetString(e2) {
    return Be.test(ae(e2));
  }
  function ParseTimeZoneOffsetString(e2) {
    const t2 = Be.exec(ae(e2));
    if (!t2)
      throw new RangeError(`invalid time zone offset: ${e2}`);
    return ("-" === t2[1] || "\u2212" === t2[1] ? -1 : 1) * (1e9 * (60 * (60 * +t2[2] + +(t2[3] || 0)) + +(t2[4] || 0)) + +((t2[5] || 0) + "000000000").slice(0, 9));
  }
  function GetCanonicalTimeZoneIdentifier(e2) {
    if (TestTimeZoneOffsetString(e2)) {
      return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e2));
    }
    return getIntlDateTimeFormatEnUsForTimeZone(ae(e2)).resolvedOptions().timeZone;
  }
  function GetIANATimeZoneOffsetNanoseconds(t2, r2) {
    const { year: o2, month: n2, day: a2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = GetIANATimeZoneDateTimeParts(t2, r2), h2 = GetEpochFromISOParts(o2, n2, a2, i2, s2, l2, d2, m2, c2);
    if (null === h2)
      throw new RangeError("Date outside of supported range");
    return import_jsbi.default.toNumber(import_jsbi.default.subtract(h2, t2));
  }
  function FormatTimeZoneOffsetString(e2) {
    const t2 = e2 < 0 ? "-" : "+", r2 = K(e2), o2 = r2 % 1e9, n2 = Q(r2 / 1e9) % 60, a2 = Q(r2 / 6e10) % 60, i2 = ISODateTimePartString(Q(r2 / 36e11)), s2 = ISODateTimePartString(a2), l2 = ISODateTimePartString(n2);
    let d2 = "";
    if (o2) {
      let e3 = `${o2}`.padStart(9, "0");
      for (; "0" === e3[e3.length - 1]; )
        e3 = e3.slice(0, -1);
      d2 = `:${l2}.${e3}`;
    } else
      n2 && (d2 = `:${l2}`);
    return `${t2}${i2}:${s2}${d2}`;
  }
  function FormatISOTimeZoneOffsetString(t2) {
    let r2 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(t2), 6e10, "halfExpand"));
    const o2 = r2 < 0 ? "-" : "+";
    r2 = K(r2);
    const n2 = r2 / 6e10 % 60;
    return `${o2}${ISODateTimePartString(Q(r2 / 36e11))}:${ISODateTimePartString(n2)}`;
  }
  function GetEpochFromISOParts(t2, r2, o2, n2, a2, i2, s2, l2, d2) {
    const m2 = new Date();
    m2.setUTCHours(n2, a2, i2, s2), m2.setUTCFullYear(t2, r2 - 1, o2);
    const c2 = m2.getTime();
    if (re(c2))
      return null;
    let h2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(c2), fe);
    return h2 = import_jsbi.default.add(h2, import_jsbi.default.multiply(import_jsbi.default.BigInt(l2), pe)), h2 = import_jsbi.default.add(h2, import_jsbi.default.BigInt(d2)), import_jsbi.default.lessThan(h2, ge) || import_jsbi.default.greaterThan(h2, Ie) ? null : h2;
  }
  function GetISOPartsFromEpoch(t2) {
    const { quotient: r2, remainder: o2 } = divmod(t2, fe);
    let n2 = import_jsbi.default.toNumber(r2), a2 = import_jsbi.default.toNumber(o2);
    a2 < 0 && (a2 += 1e6, n2 -= 1);
    const i2 = Q(a2 / 1e3) % 1e3, s2 = a2 % 1e3, l2 = new Date(n2);
    return { epochMilliseconds: n2, year: l2.getUTCFullYear(), month: l2.getUTCMonth() + 1, day: l2.getUTCDate(), hour: l2.getUTCHours(), minute: l2.getUTCMinutes(), second: l2.getUTCSeconds(), millisecond: l2.getUTCMilliseconds(), microsecond: i2, nanosecond: s2 };
  }
  function GetIANATimeZoneDateTimeParts(e2, t2) {
    const { epochMilliseconds: r2, millisecond: o2, microsecond: n2, nanosecond: a2 } = GetISOPartsFromEpoch(e2), { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2 } = function GetFormatterParts(e3, t3) {
      const r3 = getIntlDateTimeFormatEnUsForTimeZone(e3);
      return function parseFromEnUsFormat(e4) {
        const t4 = e4.split(/[^\w]+/);
        if (7 !== t4.length)
          throw new RangeError(`expected 7 parts in "${e4}`);
        const r4 = +t4[0], o3 = +t4[1];
        let n3 = +t4[2];
        const a3 = t4[3].toUpperCase();
        if ("B" === a3 || "BC" === a3)
          n3 = 1 - n3;
        else if ("A" !== a3 && "AD" !== a3)
          throw new RangeError(`Unknown era ${a3} in "${e4}`);
        let i3 = +t4[4];
        24 === i3 && (i3 = 0);
        const s3 = +t4[5], l3 = +t4[6];
        if (!(oe(n3) && oe(r4) && oe(o3) && oe(i3) && oe(s3) && oe(l3)))
          throw new RangeError(`Invalid number in "${e4}`);
        return { year: n3, month: r4, day: o3, hour: i3, minute: s3, second: l3 };
      }(r3.format(new Date(t3)));
    }(t2, r2);
    return BalanceISODateTime(i2, s2, l2, d2, m2, c2, o2, n2, a2);
  }
  function maxJSBI(t2, r2) {
    return import_jsbi.default.lessThan(t2, r2) ? r2 : t2;
  }
  function afterLatestPossibleTzdbRuleChange() {
    return import_jsbi.default.add($e(), Ge);
  }
  function GetIANATimeZonePreviousTransition(t2, r2) {
    const o2 = afterLatestPossibleTzdbRuleChange(), n2 = import_jsbi.default.greaterThan(t2, o2), a2 = n2 ? import_jsbi.default.subtract(t2, ve) : De;
    let i2 = import_jsbi.default.subtract(t2, ue);
    const s2 = GetIANATimeZoneOffsetNanoseconds(i2, r2);
    let l2 = i2, d2 = s2;
    for (; s2 === d2 && import_jsbi.default.greaterThan(i2, a2); )
      l2 = import_jsbi.default.subtract(i2, Oe), d2 = GetIANATimeZoneOffsetNanoseconds(l2, r2), s2 === d2 && (i2 = l2);
    if (s2 === d2) {
      if (n2) {
        return GetIANATimeZonePreviousTransition(import_jsbi.default.subtract(o2, we), r2);
      }
      return null;
    }
    return bisect((e2) => GetIANATimeZoneOffsetNanoseconds(e2, r2), l2, i2, d2, s2);
  }
  function LeapYear(e2) {
    if (void 0 === e2)
      return false;
    return e2 % 4 == 0 && (!(e2 % 100 == 0) || e2 % 400 == 0);
  }
  function ISODaysInMonth(e2, t2) {
    return { standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] }[LeapYear(e2) ? "leapyear" : "standard"][t2 - 1];
  }
  function DayOfWeek(e2, t2, r2) {
    const o2 = t2 + (t2 < 3 ? 10 : -2), n2 = e2 - (t2 < 3 ? 1 : 0), a2 = Q(n2 / 100), i2 = n2 - 100 * a2, s2 = (r2 + Q(2.6 * o2 - 0.2) + (i2 + Q(i2 / 4)) + (Q(a2 / 4) - 2 * a2)) % 7;
    return s2 + (s2 <= 0 ? 7 : 0);
  }
  function DayOfYear(e2, t2, r2) {
    let o2 = r2;
    for (let r3 = t2 - 1; r3 > 0; r3--)
      o2 += ISODaysInMonth(e2, r3);
    return o2;
  }
  function DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
    for (const m2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2])
      if (0 !== m2)
        return m2 < 0 ? -1 : 1;
    return 0;
  }
  function BalanceISOYearMonth(e2, t2) {
    let r2 = e2, o2 = t2;
    if (!oe(r2) || !oe(o2))
      throw new RangeError("infinity is out of range");
    return o2 -= 1, r2 += Q(o2 / 12), o2 %= 12, o2 < 0 && (o2 += 12), o2 += 1, { year: r2, month: o2 };
  }
  function BalanceISODate(e2, t2, r2) {
    let o2 = e2, n2 = t2, a2 = r2;
    if (!oe(a2))
      throw new RangeError("infinity is out of range");
    ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2));
    let i2 = 0, s2 = n2 > 2 ? o2 : o2 - 1;
    for (; i2 = LeapYear(s2) ? 366 : 365, a2 < -i2; )
      o2 -= 1, s2 -= 1, a2 += i2;
    for (s2 += 1; i2 = LeapYear(s2) ? 366 : 365, a2 > i2; )
      o2 += 1, s2 += 1, a2 -= i2;
    for (; a2 < 1; )
      ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 - 1)), a2 += ISODaysInMonth(o2, n2);
    for (; a2 > ISODaysInMonth(o2, n2); )
      a2 -= ISODaysInMonth(o2, n2), { year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 + 1);
    return { year: o2, month: n2, day: a2 };
  }
  function BalanceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
    const { deltaDays: d2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 } = BalanceTime(o2, n2, a2, i2, s2, l2), { year: f2, month: y2, day: S2 } = BalanceISODate(e2, t2, r2 + d2);
    return { year: f2, month: y2, day: S2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 };
  }
  function BalanceTime(e2, t2, r2, o2, n2, a2) {
    let i2 = e2, s2 = t2, l2 = r2, d2 = o2, m2 = n2, c2 = a2;
    if (!(oe(i2) && oe(s2) && oe(l2) && oe(d2) && oe(m2) && oe(c2)))
      throw new RangeError("infinity is out of range");
    m2 += Q(c2 / 1e3), c2 = NonNegativeModulo(c2, 1e3), d2 += Q(m2 / 1e3), m2 = NonNegativeModulo(m2, 1e3), l2 += Q(d2 / 1e3), d2 = NonNegativeModulo(d2, 1e3), s2 += Q(l2 / 60), l2 = NonNegativeModulo(l2, 60), i2 += Q(s2 / 60), s2 = NonNegativeModulo(s2, 60);
    const h2 = Q(i2 / 24);
    return i2 = NonNegativeModulo(i2, 24), { deltaDays: h2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 };
  }
  function TotalDurationNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2) {
    const d2 = import_jsbi.default.BigInt(t2);
    let m2 = import_jsbi.default.BigInt(s2);
    0 !== t2 && (m2 = import_jsbi.default.subtract(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(l2)));
    const c2 = import_jsbi.default.add(import_jsbi.default.BigInt(r2), import_jsbi.default.multiply(d2, import_jsbi.default.BigInt(24))), h2 = import_jsbi.default.add(import_jsbi.default.BigInt(o2), import_jsbi.default.multiply(c2, Te)), u2 = import_jsbi.default.add(import_jsbi.default.BigInt(n2), import_jsbi.default.multiply(h2, Te)), T2 = import_jsbi.default.add(import_jsbi.default.BigInt(a2), import_jsbi.default.multiply(u2, pe)), p2 = import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.multiply(T2, pe));
    return import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.multiply(p2, pe));
  }
  function NanosecondsToDays(t2, o2) {
    const f2 = GetIntrinsic("%Temporal.Instant%"), y2 = ee(import_jsbi.default.toNumber(t2));
    let S2 = import_jsbi.default.BigInt(t2), w2 = 864e11;
    if (0 === y2)
      return { days: 0, nanoseconds: he, dayLengthNs: w2 };
    if (!IsTemporalZonedDateTime(o2)) {
      let t3;
      return { quotient: t3, remainder: S2 } = divmod(S2, import_jsbi.default.BigInt(w2)), { days: import_jsbi.default.toNumber(t3), nanoseconds: S2, dayLengthNs: w2 };
    }
    const g2 = GetSlot(o2, r), I2 = GetSlot(o2, T), D2 = import_jsbi.default.add(g2, S2), G2 = new f2(D2), v2 = GetSlot(o2, p), O2 = GetSlot(o2, u), C2 = BuiltinTimeZoneGetPlainDateTimeFor(v2, I2, O2), E2 = BuiltinTimeZoneGetPlainDateTimeFor(v2, G2, O2);
    let { days: b2 } = DifferenceISODateTime(GetSlot(C2, n), GetSlot(C2, a), GetSlot(C2, i), GetSlot(C2, s), GetSlot(C2, l), GetSlot(C2, d), GetSlot(C2, m), GetSlot(C2, c), GetSlot(C2, h), GetSlot(E2, n), GetSlot(E2, a), GetSlot(E2, i), GetSlot(E2, s), GetSlot(E2, l), GetSlot(E2, d), GetSlot(E2, m), GetSlot(E2, c), GetSlot(E2, h), O2, "day", le(null)), M2 = AddZonedDateTime(I2, v2, O2, 0, 0, 0, b2, 0, 0, 0, 0, 0, 0);
    if (1 === y2)
      for (; b2 > 0 && import_jsbi.default.greaterThan(M2, D2); )
        --b2, M2 = AddZonedDateTime(I2, v2, O2, 0, 0, 0, b2, 0, 0, 0, 0, 0, 0);
    S2 = import_jsbi.default.subtract(D2, M2);
    let R2 = false, Z2 = new f2(M2);
    do {
      const t3 = AddZonedDateTime(Z2, v2, O2, 0, 0, 0, y2, 0, 0, 0, 0, 0, 0), o3 = GetSlot(Z2, r);
      w2 = import_jsbi.default.toNumber(import_jsbi.default.subtract(t3, o3)), R2 = import_jsbi.default.greaterThan(import_jsbi.default.multiply(import_jsbi.default.subtract(S2, import_jsbi.default.BigInt(w2)), import_jsbi.default.BigInt(y2)), he), R2 && (S2 = import_jsbi.default.subtract(S2, import_jsbi.default.BigInt(w2)), Z2 = new f2(t3), b2 += y2);
    } while (R2);
    return { days: b2, nanoseconds: S2, dayLengthNs: K(w2) };
  }
  function BalanceDuration(t2, o2, n2, a2, i2, s2, l2, d2, m2) {
    let c2, h2, f2, y2, S2, w2, g2 = t2;
    if (IsTemporalZonedDateTime(m2)) {
      const t3 = AddZonedDateTime(GetSlot(m2, T), GetSlot(m2, p), GetSlot(m2, u), 0, 0, 0, g2, o2, n2, a2, i2, s2, l2), d3 = GetSlot(m2, r);
      c2 = import_jsbi.default.subtract(t3, d3);
    } else
      c2 = TotalDurationNanoseconds(g2, o2, n2, a2, i2, s2, l2, 0);
    "year" === d2 || "month" === d2 || "week" === d2 || "day" === d2 ? { days: g2, nanoseconds: c2 } = NanosecondsToDays(c2, m2) : g2 = 0;
    const I2 = import_jsbi.default.lessThan(c2, he) ? -1 : 1;
    switch (c2 = abs(c2), h2 = f2 = y2 = S2 = w2 = he, d2) {
      case "year":
      case "month":
      case "week":
      case "day":
      case "hour":
        ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe), { quotient: y2, remainder: f2 } = divmod(f2, pe), { quotient: S2, remainder: y2 } = divmod(y2, Te), { quotient: w2, remainder: S2 } = divmod(S2, Te);
        break;
      case "minute":
        ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe), { quotient: y2, remainder: f2 } = divmod(f2, pe), { quotient: S2, remainder: y2 } = divmod(y2, Te);
        break;
      case "second":
        ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe), { quotient: y2, remainder: f2 } = divmod(f2, pe);
        break;
      case "millisecond":
        ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe);
        break;
      case "microsecond":
        ({ quotient: h2, remainder: c2 } = divmod(c2, pe));
        break;
      case "nanosecond":
        break;
      default:
        throw new Error("assert not reached");
    }
    return { days: g2, hours: import_jsbi.default.toNumber(w2) * I2, minutes: import_jsbi.default.toNumber(S2) * I2, seconds: import_jsbi.default.toNumber(y2) * I2, milliseconds: import_jsbi.default.toNumber(f2) * I2, microseconds: import_jsbi.default.toNumber(h2) * I2, nanoseconds: import_jsbi.default.toNumber(c2) * I2 };
  }
  function UnbalanceDurationRelative(e2, t2, r2, o2, n2, a2) {
    let i2 = e2, s2 = t2, l2 = r2, d2 = o2;
    const m2 = GetIntrinsic("%Temporal.Duration%"), c2 = DurationSign(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
    let h2, T2;
    a2 && (T2 = ToTemporalDate(a2), h2 = GetSlot(T2, u));
    const p2 = new m2(c2), f2 = new m2(0, c2), S2 = new m2(0, 0, c2);
    switch (n2) {
      case "year":
        break;
      case "month":
        {
          if (!h2)
            throw new RangeError("a starting point is required for months balancing");
          const e3 = h2.dateAdd, t3 = h2.dateUntil;
          let r3 = T2;
          for (; K(i2) > 0; ) {
            const o3 = CalendarDateAdd(h2, r3, p2, void 0, e3), n3 = le(null);
            n3.largestUnit = "month";
            const a3 = GetSlot(CalendarDateUntil(h2, r3, o3, n3, t3), y);
            r3 = o3, s2 += a3, i2 -= c2;
          }
        }
        break;
      case "week":
        if (!h2)
          throw new RangeError("a starting point is required for weeks balancing");
        for (; K(i2) > 0; ) {
          let e3;
          ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, p2)), d2 += e3, i2 -= c2;
        }
        for (; K(s2) > 0; ) {
          let e3;
          ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, f2)), d2 += e3, s2 -= c2;
        }
        break;
      default:
        for (; K(i2) > 0; ) {
          if (!h2)
            throw new RangeError("a starting point is required for balancing calendar units");
          let e3;
          ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, p2)), d2 += e3, i2 -= c2;
        }
        for (; K(s2) > 0; ) {
          if (!h2)
            throw new RangeError("a starting point is required for balancing calendar units");
          let e3;
          ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, f2)), d2 += e3, s2 -= c2;
        }
        for (; K(l2) > 0; ) {
          if (!h2)
            throw new RangeError("a starting point is required for balancing calendar units");
          let e3;
          ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, S2)), d2 += e3, l2 -= c2;
        }
    }
    return { years: i2, months: s2, weeks: l2, days: d2 };
  }
  function CalculateOffsetShift(e2, t2, r2, o2, n2) {
    if (IsTemporalZonedDateTime(e2)) {
      const a2 = GetSlot(e2, T), i2 = GetSlot(e2, p), s2 = GetSlot(e2, u), l2 = GetOffsetNanosecondsFor(i2, a2), d2 = AddZonedDateTime(a2, i2, s2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
      return GetOffsetNanosecondsFor(i2, new (GetIntrinsic("%Temporal.Instant%"))(d2)) - l2;
    }
    return 0;
  }
  function CreateNegatedTemporalDuration(e2) {
    return new (GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e2, f), -GetSlot(e2, y), -GetSlot(e2, S), -GetSlot(e2, w), -GetSlot(e2, g), -GetSlot(e2, I), -GetSlot(e2, D), -GetSlot(e2, G), -GetSlot(e2, v), -GetSlot(e2, O));
  }
  function ConstrainToRange(e2, t2, r2) {
    return V(r2, X(t2, e2));
  }
  function ConstrainISODate(e2, t2, r2) {
    const o2 = ConstrainToRange(t2, 1, 12);
    return { year: e2, month: o2, day: ConstrainToRange(r2, 1, ISODaysInMonth(e2, o2)) };
  }
  function RejectToRange(e2, t2, r2) {
    if (e2 < t2 || e2 > r2)
      throw new RangeError(`value out of range: ${t2} <= ${e2} <= ${r2}`);
  }
  function RejectISODate(e2, t2, r2) {
    RejectToRange(t2, 1, 12), RejectToRange(r2, 1, ISODaysInMonth(e2, t2));
  }
  function RejectDateRange(e2, t2, r2) {
    RejectDateTimeRange(e2, t2, r2, 12, 0, 0, 0, 0, 0);
  }
  function RejectTime(e2, t2, r2, o2, n2, a2) {
    RejectToRange(e2, 0, 23), RejectToRange(t2, 0, 59), RejectToRange(r2, 0, 59), RejectToRange(o2, 0, 999), RejectToRange(n2, 0, 999), RejectToRange(a2, 0, 999);
  }
  function RejectDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
    RejectISODate(e2, t2, r2), RejectTime(o2, n2, a2, i2, s2, l2);
  }
  function RejectDateTimeRange(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
    if (RejectToRange(e2, -271821, 275760), -271821 === e2 && null == GetEpochFromISOParts(e2, t2, r2 + 1, o2, n2, a2, i2, s2, l2 - 1) || 275760 === e2 && null == GetEpochFromISOParts(e2, t2, r2 - 1, o2, n2, a2, i2, s2, l2 + 1))
      throw new RangeError("DateTime outside of supported range");
  }
  function ValidateEpochNanoseconds(t2) {
    if (import_jsbi.default.lessThan(t2, ge) || import_jsbi.default.greaterThan(t2, Ie))
      throw new RangeError("Instant outside of supported range");
  }
  function RejectDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
    const m2 = DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2);
    for (const c2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2]) {
      if (!oe(c2))
        throw new RangeError("infinite values not allowed as duration fields");
      const e3 = ee(c2);
      if (0 !== e3 && e3 !== m2)
        throw new RangeError("mixed-sign values not allowed as duration fields");
    }
  }
  function DifferenceISODate(e2, t2, r2, o2, n2, a2, i2) {
    switch (i2) {
      case "year":
      case "month": {
        const s2 = -CompareISODate(e2, t2, r2, o2, n2, a2);
        if (0 === s2)
          return { years: 0, months: 0, weeks: 0, days: 0 };
        const l2 = { year: e2, month: t2, day: r2 }, d2 = { year: o2, month: n2, day: a2 };
        let m2 = d2.year - l2.year, c2 = AddISODate(e2, t2, r2, m2, 0, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2);
        if (0 === h2)
          return "year" === i2 ? { years: m2, months: 0, weeks: 0, days: 0 } : { years: 0, months: 12 * m2, weeks: 0, days: 0 };
        let u2 = d2.month - l2.month;
        if (h2 !== s2 && (m2 -= s2, u2 += 12 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2), 0 === h2)
          return "year" === i2 ? { years: m2, months: u2, weeks: 0, days: 0 } : { years: 0, months: u2 + 12 * m2, weeks: 0, days: 0 };
        h2 !== s2 && (u2 -= s2, u2 === -s2 && (m2 -= s2, u2 = 11 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"));
        let T2 = 0;
        return T2 = c2.month === d2.month ? d2.day - c2.day : s2 < 0 ? -c2.day - (ISODaysInMonth(d2.year, d2.month) - d2.day) : d2.day + (ISODaysInMonth(c2.year, c2.month) - c2.day), "month" === i2 && (u2 += 12 * m2, m2 = 0), { years: m2, months: u2, weeks: 0, days: T2 };
      }
      case "week":
      case "day": {
        let s2, l2, d2;
        CompareISODate(e2, t2, r2, o2, n2, a2) < 0 ? (l2 = { year: e2, month: t2, day: r2 }, s2 = { year: o2, month: n2, day: a2 }, d2 = 1) : (l2 = { year: o2, month: n2, day: a2 }, s2 = { year: e2, month: t2, day: r2 }, d2 = -1);
        let m2 = DayOfYear(s2.year, s2.month, s2.day) - DayOfYear(l2.year, l2.month, l2.day);
        for (let e3 = l2.year; e3 < s2.year; ++e3)
          m2 += LeapYear(e3) ? 366 : 365;
        let c2 = 0;
        return "week" === i2 && (c2 = Q(m2 / 7), m2 %= 7), c2 *= d2, m2 *= d2, { years: 0, months: 0, weeks: c2, days: m2 };
      }
      default:
        throw new Error("assert not reached");
    }
  }
  function DifferenceTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
    let h2 = i2 - e2, u2 = s2 - t2, T2 = l2 - r2, p2 = d2 - o2, f2 = m2 - n2, y2 = c2 - a2;
    const S2 = DurationSign(0, 0, 0, 0, h2, u2, T2, p2, f2, y2);
    h2 *= S2, u2 *= S2, T2 *= S2, p2 *= S2, f2 *= S2, y2 *= S2;
    let w2 = 0;
    if ({ deltaDays: w2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), 0 != w2)
      throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
    return h2 *= S2, u2 *= S2, T2 *= S2, p2 *= S2, f2 *= S2, y2 *= S2, { hours: h2, minutes: u2, seconds: T2, milliseconds: p2, microseconds: f2, nanoseconds: y2 };
  }
  function DifferenceInstant(t2, r2, o2, n2, a2) {
    const i2 = import_jsbi.default.subtract(r2, t2), s2 = import_jsbi.default.remainder(i2, import_jsbi.default.BigInt(864e11)), l2 = import_jsbi.default.subtract(i2, s2), d2 = RoundNumberToIncrement(s2, Ne[n2] * o2, a2), m2 = import_jsbi.default.add(l2, d2), c2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(m2, pe)), h2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(m2, pe), pe)), u2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(m2, fe), pe));
    return { seconds: import_jsbi.default.toNumber(import_jsbi.default.divide(m2, ye)), milliseconds: u2, microseconds: h2, nanoseconds: c2 };
  }
  function DifferenceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, S2, w2, g2) {
    let I2 = e2, D2 = t2, G2 = r2, { hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 } = DifferenceTime(o2, n2, a2, i2, s2, l2, h2, u2, T2, p2, f2, y2);
    const R2 = DurationSign(0, 0, 0, 0, v2, O2, C2, E2, b2, M2);
    CompareISODate(d2, m2, c2, I2, D2, G2) === -R2 && ({ year: I2, month: D2, day: G2 } = BalanceISODate(I2, D2, G2 - R2), { hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 } = BalanceDuration(-R2, v2, O2, C2, E2, b2, M2, w2));
    const Z2 = CreateTemporalDate(I2, D2, G2, S2), P2 = CreateTemporalDate(d2, m2, c2, S2), F2 = MergeLargestUnitOption(g2, LargerOfTwoTemporalUnits("day", w2));
    let { years: Y2, months: j2, weeks: $2, days: B2 } = CalendarDateUntil(S2, Z2, P2, F2);
    return { days: B2, hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 } = BalanceDuration(B2, v2, O2, C2, E2, b2, M2, w2), { years: Y2, months: j2, weeks: $2, days: B2, hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 };
  }
  function DifferenceZonedDateTime(t2, r2, o2, u2, T2, p2) {
    const f2 = import_jsbi.default.subtract(r2, t2);
    if (import_jsbi.default.equal(f2, he))
      return { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
    const y2 = GetIntrinsic("%Temporal.Instant%"), S2 = new y2(t2), w2 = new y2(r2), g2 = BuiltinTimeZoneGetPlainDateTimeFor(o2, S2, u2), I2 = BuiltinTimeZoneGetPlainDateTimeFor(o2, w2, u2);
    let { years: D2, months: G2, weeks: v2, days: O2 } = DifferenceISODateTime(GetSlot(g2, n), GetSlot(g2, a), GetSlot(g2, i), GetSlot(g2, s), GetSlot(g2, l), GetSlot(g2, d), GetSlot(g2, m), GetSlot(g2, c), GetSlot(g2, h), GetSlot(I2, n), GetSlot(I2, a), GetSlot(I2, i), GetSlot(I2, s), GetSlot(I2, l), GetSlot(I2, d), GetSlot(I2, m), GetSlot(I2, c), GetSlot(I2, h), u2, T2, p2);
    const C2 = AddZonedDateTime(S2, o2, u2, D2, G2, v2, 0, 0, 0, 0, 0, 0, 0);
    let E2 = import_jsbi.default.subtract(r2, C2);
    const b2 = CreateTemporalZonedDateTime(C2, o2, u2);
    ({ nanoseconds: E2, days: O2 } = NanosecondsToDays(E2, b2));
    const { hours: M2, minutes: R2, seconds: Z2, milliseconds: P2, microseconds: F2, nanoseconds: Y2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(E2), "hour");
    return { years: D2, months: G2, weeks: v2, days: O2, hours: M2, minutes: R2, seconds: Z2, milliseconds: P2, microseconds: F2, nanoseconds: Y2 };
  }
  function DifferenceTemporalInstant(e2, t2, o2, n2) {
    const a2 = ToTemporalInstant(o2);
    let i2, s2;
    [i2, s2] = "until" === e2 ? [t2, a2] : [a2, t2];
    const l2 = GetOptionsObject(n2), d2 = GetTemporalUnit(l2, "smallestUnit", "time", "nanosecond"), m2 = LargerOfTwoTemporalUnits("second", d2);
    let c2 = GetTemporalUnit(l2, "largestUnit", "time", "auto");
    if ("auto" === c2 && (c2 = m2), LargerOfTwoTemporalUnits(c2, d2) !== c2)
      throw new RangeError(`largestUnit ${c2} cannot be smaller than smallestUnit ${d2}`);
    const h2 = ToTemporalRoundingMode(l2, "trunc"), u2 = ToTemporalRoundingIncrement(l2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[d2], false), T2 = GetSlot(i2, r), p2 = GetSlot(s2, r);
    let f2, y2, { seconds: S2, milliseconds: w2, microseconds: g2, nanoseconds: I2 } = DifferenceInstant(T2, p2, u2, d2, h2);
    ({ hours: f2, minutes: y2, seconds: S2, milliseconds: w2, microseconds: g2, nanoseconds: I2 } = BalanceDuration(0, 0, 0, S2, w2, g2, I2, c2));
    return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, f2, y2, S2, w2, g2, I2);
  }
  function DifferenceTemporalPlainDate(e2, t2, r2, o2) {
    const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDate(r2), i2 = GetSlot(t2, u), s2 = GetSlot(a2, u), l2 = ToString(i2), d2 = ToString(s2);
    if (l2 !== d2)
      throw new RangeError(`cannot compute difference between dates of ${l2} and ${d2} calendars`);
    const m2 = GetOptionsObject(o2), c2 = GetTemporalUnit(m2, "smallestUnit", "date", "day"), h2 = LargerOfTwoTemporalUnits("day", c2);
    let T2 = GetTemporalUnit(m2, "largestUnit", "date", "auto");
    if ("auto" === T2 && (T2 = h2), LargerOfTwoTemporalUnits(T2, c2) !== T2)
      throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${c2}`);
    let p2 = ToTemporalRoundingMode(m2, "trunc");
    "since" === e2 && (p2 = NegateTemporalRoundingMode(p2));
    const f2 = ToTemporalRoundingIncrement(m2, void 0, false), y2 = MergeLargestUnitOption(m2, T2);
    let { years: S2, months: w2, weeks: g2, days: I2 } = CalendarDateUntil(i2, t2, a2, y2);
    "day" === c2 && 1 === f2 || ({ years: S2, months: w2, weeks: g2, days: I2 } = RoundDuration(S2, w2, g2, I2, 0, 0, 0, 0, 0, 0, f2, c2, p2, t2));
    return new (GetIntrinsic("%Temporal.Duration%"))(n2 * S2, n2 * w2, n2 * g2, n2 * I2, 0, 0, 0, 0, 0, 0);
  }
  function DifferenceTemporalPlainDateTime(e2, t2, r2, o2) {
    const T2 = "since" === e2 ? -1 : 1, p2 = ToTemporalDateTime(r2), f2 = GetSlot(t2, u), y2 = GetSlot(p2, u), S2 = ToString(f2), w2 = ToString(y2);
    if (S2 !== w2)
      throw new RangeError(`cannot compute difference between dates of ${S2} and ${w2} calendars`);
    const g2 = GetOptionsObject(o2), I2 = GetTemporalUnit(g2, "smallestUnit", "datetime", "nanosecond"), D2 = LargerOfTwoTemporalUnits("day", I2);
    let G2 = GetTemporalUnit(g2, "largestUnit", "datetime", "auto");
    if ("auto" === G2 && (G2 = D2), LargerOfTwoTemporalUnits(G2, I2) !== G2)
      throw new RangeError(`largestUnit ${G2} cannot be smaller than smallestUnit ${I2}`);
    let v2 = ToTemporalRoundingMode(g2, "trunc");
    "since" === e2 && (v2 = NegateTemporalRoundingMode(v2));
    const O2 = ToTemporalDateTimeRoundingIncrement(g2, I2);
    let { years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = DifferenceISODateTime(GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(p2, n), GetSlot(p2, a), GetSlot(p2, i), GetSlot(p2, s), GetSlot(p2, l), GetSlot(p2, d), GetSlot(p2, m), GetSlot(p2, c), GetSlot(p2, h), f2, G2, g2);
    const $2 = TemporalDateTimeToDate(t2);
    ({ years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = RoundDuration(C2, E2, b2, M2, R2, Z2, P2, F2, Y2, j2, O2, I2, v2, $2)), { days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(M2, R2, Z2, P2, F2, Y2, j2, G2);
    return new (GetIntrinsic("%Temporal.Duration%"))(T2 * C2, T2 * E2, T2 * b2, T2 * M2, T2 * R2, T2 * Z2, T2 * P2, T2 * F2, T2 * Y2, T2 * j2);
  }
  function DifferenceTemporalPlainTime(e2, t2, r2, o2) {
    const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalTime(r2), i2 = GetOptionsObject(o2);
    let u2 = GetTemporalUnit(i2, "largestUnit", "time", "auto");
    "auto" === u2 && (u2 = "hour");
    const T2 = GetTemporalUnit(i2, "smallestUnit", "time", "nanosecond");
    if (LargerOfTwoTemporalUnits(u2, T2) !== u2)
      throw new RangeError(`largestUnit ${u2} cannot be smaller than smallestUnit ${T2}`);
    let p2 = ToTemporalRoundingMode(i2, "trunc");
    "since" === e2 && (p2 = NegateTemporalRoundingMode(p2));
    const f2 = ToTemporalRoundingIncrement(i2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[T2], false);
    let { hours: y2, minutes: S2, seconds: w2, milliseconds: g2, microseconds: I2, nanoseconds: D2 } = DifferenceTime(GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(a2, s), GetSlot(a2, l), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h));
    ({ hours: y2, minutes: S2, seconds: w2, milliseconds: g2, microseconds: I2, nanoseconds: D2 } = RoundDuration(0, 0, 0, 0, y2, S2, w2, g2, I2, D2, f2, T2, p2)), { hours: y2, minutes: S2, seconds: w2, milliseconds: g2, microseconds: I2, nanoseconds: D2 } = BalanceDuration(0, y2, S2, w2, g2, I2, D2, u2);
    return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, n2 * y2, n2 * S2, n2 * w2, n2 * g2, n2 * I2, n2 * D2);
  }
  function DifferenceTemporalPlainYearMonth(e2, t2, r2, o2) {
    const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalYearMonth(r2), i2 = GetSlot(t2, u), s2 = GetSlot(a2, u), l2 = ToString(i2), d2 = ToString(s2);
    if (l2 !== d2)
      throw new RangeError(`cannot compute difference between months of ${l2} and ${d2} calendars`);
    const m2 = GetOptionsObject(o2), c2 = Me.reduce((e3, [t3, r3, o3]) => ("date" === o3 && "week" !== r3 && "day" !== r3 && e3.push(r3, t3), e3), []), h2 = GetTemporalUnit(m2, "smallestUnit", "date", "month");
    if ("week" === h2 || "day" === h2)
      throw new RangeError(`smallestUnit must be one of ${c2.join(", ")}, not ${h2}`);
    let T2 = GetTemporalUnit(m2, "largestUnit", "date", "auto");
    if ("week" === T2 || "day" === T2)
      throw new RangeError(`largestUnit must be one of ${c2.join(", ")}, not ${T2}`);
    if ("auto" === T2 && (T2 = "year"), LargerOfTwoTemporalUnits(T2, h2) !== T2)
      throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${h2}`);
    let p2 = ToTemporalRoundingMode(m2, "trunc");
    "since" === e2 && (p2 = NegateTemporalRoundingMode(p2));
    const f2 = ToTemporalRoundingIncrement(m2, void 0, false), y2 = CalendarFields(i2, ["monthCode", "year"]), S2 = PrepareTemporalFields(a2, y2, []);
    S2.day = 1;
    const w2 = PrepareTemporalFields(t2, y2, []);
    w2.day = 1;
    const g2 = CalendarDateFromFields(i2, S2), I2 = CalendarDateFromFields(i2, w2), D2 = MergeLargestUnitOption(m2, T2);
    let { years: G2, months: v2 } = CalendarDateUntil(i2, I2, g2, D2);
    "month" === h2 && 1 === f2 || ({ years: G2, months: v2 } = RoundDuration(G2, v2, 0, 0, 0, 0, 0, 0, 0, 0, f2, h2, p2, I2));
    return new (GetIntrinsic("%Temporal.Duration%"))(n2 * G2, n2 * v2, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  function DifferenceTemporalZonedDateTime(e2, t2, o2, n2) {
    const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalZonedDateTime(o2), s2 = GetSlot(t2, u), l2 = GetSlot(i2, u), d2 = ToString(s2), m2 = ToString(l2);
    if (d2 !== m2)
      throw new RangeError(`cannot compute difference between dates of ${d2} and ${m2} calendars`);
    const c2 = GetOptionsObject(n2), h2 = GetTemporalUnit(c2, "smallestUnit", "datetime", "nanosecond"), T2 = LargerOfTwoTemporalUnits("hour", h2);
    let f2 = GetTemporalUnit(c2, "largestUnit", "datetime", "auto");
    if ("auto" === f2 && (f2 = T2), LargerOfTwoTemporalUnits(f2, h2) !== f2)
      throw new RangeError(`largestUnit ${f2} cannot be smaller than smallestUnit ${h2}`);
    let y2 = ToTemporalRoundingMode(c2, "trunc");
    "since" === e2 && (y2 = NegateTemporalRoundingMode(y2));
    const S2 = ToTemporalDateTimeRoundingIncrement(c2, h2), w2 = GetSlot(t2, r), g2 = GetSlot(i2, r);
    let I2, D2, G2, v2, O2, C2, E2, b2, M2, R2;
    if ("year" !== f2 && "month" !== f2 && "week" !== f2 && "day" !== f2)
      I2 = 0, D2 = 0, G2 = 0, v2 = 0, { seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = DifferenceInstant(w2, g2, S2, h2, y2), { hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = BalanceDuration(0, 0, 0, E2, b2, M2, R2, f2);
    else {
      const e3 = GetSlot(t2, p);
      if (!TimeZoneEquals(e3, GetSlot(i2, p)))
        throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
      const r2 = MergeLargestUnitOption(c2, f2);
      ({ years: I2, months: D2, weeks: G2, days: v2, hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = DifferenceZonedDateTime(w2, g2, e3, s2, f2, r2)), { years: I2, months: D2, weeks: G2, days: v2, hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = RoundDuration(I2, D2, G2, v2, O2, C2, E2, b2, M2, R2, S2, h2, y2, t2), { years: I2, months: D2, weeks: G2, days: v2, hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = AdjustRoundedDurationDays(I2, D2, G2, v2, O2, C2, E2, b2, M2, R2, S2, h2, y2, t2);
    }
    return new (GetIntrinsic("%Temporal.Duration%"))(a2 * I2, a2 * D2, a2 * G2, a2 * v2, a2 * O2, a2 * C2, a2 * E2, a2 * b2, a2 * M2, a2 * R2);
  }
  function AddISODate(e2, t2, r2, o2, n2, a2, i2, s2) {
    let l2 = e2, d2 = t2, m2 = r2, c2 = a2, h2 = i2;
    return l2 += o2, d2 += n2, { year: l2, month: d2 } = BalanceISOYearMonth(l2, d2), { year: l2, month: d2, day: m2 } = RegulateISODate(l2, d2, m2, s2), h2 += 7 * c2, m2 += h2, { year: l2, month: d2, day: m2 } = BalanceISODate(l2, d2, m2), { year: l2, month: d2, day: m2 };
  }
  function AddTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
    let h2 = e2, u2 = t2, T2 = r2, p2 = o2, f2 = n2, y2 = a2;
    h2 += i2, u2 += s2, T2 += l2, p2 += d2, f2 += m2, y2 += c2;
    let S2 = 0;
    return { deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), { deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 };
  }
  function AddDuration(e2, t2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, f2, y2, S2, w2, g2, I2, D2, G2, v2) {
    const O2 = LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(e2, t2, o2, n2, a2, i2, s2, l2, d2, m2), DefaultTemporalLargestUnit(c2, h2, f2, y2, S2, w2, g2, I2, D2, G2));
    let C2, E2, b2, M2, R2, Z2, P2, F2, Y2, j2;
    if (v2)
      if (IsTemporalDate(v2)) {
        const r2 = GetIntrinsic("%Temporal.Duration%"), T2 = GetSlot(v2, u), p2 = new r2(e2, t2, o2, n2, 0, 0, 0, 0, 0, 0), $2 = new r2(c2, h2, f2, y2, 0, 0, 0, 0, 0, 0), B2 = T2.dateAdd, N10 = CalendarDateAdd(T2, v2, p2, void 0, B2), k2 = CalendarDateAdd(T2, N10, $2, void 0, B2), A2 = LargerOfTwoTemporalUnits("day", O2), U2 = le(null);
        U2.largestUnit = A2, { years: C2, months: E2, weeks: b2, days: M2 } = CalendarDateUntil(T2, v2, k2, U2), { days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(M2, a2 + S2, i2 + w2, s2 + g2, l2 + I2, d2 + D2, m2 + G2, O2);
      } else {
        const $2 = GetIntrinsic("%Temporal.Instant%"), B2 = GetSlot(v2, p), N10 = GetSlot(v2, u), k2 = AddZonedDateTime(GetSlot(v2, T), B2, N10, e2, t2, o2, n2, a2, i2, s2, l2, d2, m2), A2 = AddZonedDateTime(new $2(k2), B2, N10, c2, h2, f2, y2, S2, w2, g2, I2, D2, G2);
        "year" !== O2 && "month" !== O2 && "week" !== O2 && "day" !== O2 ? (C2 = 0, E2 = 0, b2 = 0, M2 = 0, { seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = DifferenceInstant(GetSlot(v2, r), A2, 1, "nanosecond", "halfExpand"), { hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(0, 0, 0, P2, F2, Y2, j2, O2)) : { years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = DifferenceZonedDateTime(GetSlot(v2, r), A2, B2, N10, O2, le(null));
      }
    else {
      if ("year" === O2 || "month" === O2 || "week" === O2)
        throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
      C2 = E2 = b2 = 0, { days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(n2 + y2, a2 + S2, i2 + w2, s2 + g2, l2 + I2, d2 + D2, m2 + G2, O2);
    }
    return RejectDuration(C2, E2, b2, M2, R2, Z2, P2, F2, Y2, j2), { years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 };
  }
  function AddInstant(t2, r2, o2, n2, a2, i2, s2) {
    let l2 = he;
    l2 = import_jsbi.default.add(l2, import_jsbi.default.BigInt(s2)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(i2), pe)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(a2), fe)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(n2), ye)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(6e10))), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), import_jsbi.default.BigInt(36e11)));
    const d2 = import_jsbi.default.add(t2, l2);
    return ValidateEpochNanoseconds(d2), d2;
  }
  function AddDateTime(e2, t2, r2, o2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, S2, w2, g2, I2, D2, G2) {
    let v2 = f2, { deltaDays: O2, hour: C2, minute: E2, second: b2, millisecond: M2, microsecond: R2, nanosecond: Z2 } = AddTime(o2, s2, l2, d2, m2, c2, y2, S2, w2, g2, I2, D2);
    v2 += O2;
    const P2 = GetIntrinsic("%Temporal.Duration%"), F2 = CalendarDateAdd(h2, CreateTemporalDate(e2, t2, r2, h2), new P2(u2, T2, p2, v2, 0, 0, 0, 0, 0, 0), G2);
    return { year: GetSlot(F2, n), month: GetSlot(F2, a), day: GetSlot(F2, i), hour: C2, minute: E2, second: b2, millisecond: M2, microsecond: R2, nanosecond: Z2 };
  }
  function AddZonedDateTime(e2, t2, o2, u2, T2, p2, f2, y2, S2, w2, g2, I2, D2, G2) {
    const v2 = GetIntrinsic("%Temporal.Duration%");
    if (0 === DurationSign(u2, T2, p2, f2, 0, 0, 0, 0, 0, 0))
      return AddInstant(GetSlot(e2, r), y2, S2, w2, g2, I2, D2);
    const O2 = BuiltinTimeZoneGetPlainDateTimeFor(t2, e2, o2), C2 = CalendarDateAdd(o2, CreateTemporalDate(GetSlot(O2, n), GetSlot(O2, a), GetSlot(O2, i), o2), new v2(u2, T2, p2, f2, 0, 0, 0, 0, 0, 0), G2), E2 = CreateTemporalDateTime(GetSlot(C2, n), GetSlot(C2, a), GetSlot(C2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(O2, d), GetSlot(O2, m), GetSlot(O2, c), GetSlot(O2, h), o2);
    return AddInstant(GetSlot(BuiltinTimeZoneGetInstantFor(t2, E2, "compatible"), r), y2, S2, w2, g2, I2, D2);
  }
  function AddDurationToOrSubtractDurationFromDuration(e2, t2, r2, o2) {
    const n2 = "subtract" === e2 ? -1 : 1;
    let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2);
    const p2 = ToRelativeTemporalObject(GetOptionsObject(o2));
    ({ years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = AddDuration(GetSlot(t2, f), GetSlot(t2, y), GetSlot(t2, S), GetSlot(t2, w), GetSlot(t2, g), GetSlot(t2, I), GetSlot(t2, D), GetSlot(t2, G), GetSlot(t2, v), GetSlot(t2, O), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, p2));
    return new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, d2, m2, c2, h2, u2, T2);
  }
  function AddDurationToOrSubtractDurationFromInstant(e2, t2, o2) {
    const n2 = "subtract" === e2 ? -1 : 1, { hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = function ToLimitedTemporalDuration(e3, t3) {
      let r2 = ToTemporalDurationRecord(e3);
      for (const e4 of t3)
        if (0 !== r2[e4])
          throw new RangeError(`Duration field ${e4} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
      return r2;
    }(o2, ["years", "months", "weeks", "days"]), c2 = AddInstant(GetSlot(t2, r), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2);
    return new (GetIntrinsic("%Temporal.Instant%"))(c2);
  }
  function AddDurationToOrSubtractDurationFromPlainDateTime(e2, t2, r2, o2) {
    const T2 = "subtract" === e2 ? -1 : 1, { years: p2, months: f2, weeks: y2, days: S2, hours: w2, minutes: g2, seconds: I2, milliseconds: D2, microseconds: G2, nanoseconds: v2 } = ToTemporalDurationRecord(r2), O2 = GetOptionsObject(o2), C2 = GetSlot(t2, u), { year: E2, month: b2, day: M2, hour: R2, minute: Z2, second: P2, millisecond: F2, microsecond: Y2, nanosecond: j2 } = AddDateTime(GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), C2, T2 * p2, T2 * f2, T2 * y2, T2 * S2, T2 * w2, T2 * g2, T2 * I2, T2 * D2, T2 * G2, T2 * v2, O2);
    return CreateTemporalDateTime(E2, b2, M2, R2, Z2, P2, F2, Y2, j2, C2);
  }
  function AddDurationToOrSubtractDurationFromPlainTime(e2, t2, r2) {
    const o2 = "subtract" === e2 ? -1 : 1, { hours: n2, minutes: a2, seconds: i2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = ToTemporalDurationRecord(r2);
    let { hour: f2, minute: y2, second: S2, millisecond: w2, microsecond: g2, nanosecond: I2 } = AddTime(GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), o2 * n2, o2 * a2, o2 * i2, o2 * u2, o2 * T2, o2 * p2);
    ({ hour: f2, minute: y2, second: S2, millisecond: w2, microsecond: g2, nanosecond: I2 } = RegulateTime(f2, y2, S2, w2, g2, I2, "reject"));
    return new (GetIntrinsic("%Temporal.PlainTime%"))(f2, y2, S2, w2, g2, I2);
  }
  function AddDurationToOrSubtractDurationFromPlainYearMonth(e2, t2, r2, o2) {
    let n2 = ToTemporalDurationRecord(r2);
    "subtract" === e2 && (n2 = { years: -n2.years, months: -n2.months, weeks: -n2.weeks, days: -n2.days, hours: -n2.hours, minutes: -n2.minutes, seconds: -n2.seconds, milliseconds: -n2.milliseconds, microseconds: -n2.microseconds, nanoseconds: -n2.nanoseconds });
    let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: T2, nanoseconds: p2 } = n2;
    ({ days: l2 } = BalanceDuration(l2, d2, m2, c2, h2, T2, p2, "day"));
    const f2 = GetOptionsObject(o2), y2 = GetSlot(t2, u), S2 = CalendarFields(y2, ["monthCode", "year"]), w2 = PrepareTemporalFields(t2, S2, []), g2 = DurationSign(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0);
    w2.day = g2 < 0 ? ToPositiveInteger(CalendarDaysInMonth(y2, t2)) : 1;
    const I2 = CalendarDateFromFields(y2, w2), D2 = new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), G2 = se(le(null), f2);
    return CalendarYearMonthFromFields(y2, PrepareTemporalFields(CalendarDateAdd(y2, I2, D2, f2), S2, []), G2);
  }
  function AddDurationToOrSubtractDurationFromZonedDateTime(e2, t2, r2, o2) {
    const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: f2, nanoseconds: y2 } = ToTemporalDurationRecord(r2), S2 = GetOptionsObject(o2), w2 = GetSlot(t2, p), g2 = GetSlot(t2, u);
    return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(t2, T), w2, g2, n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * f2, n2 * y2, S2), w2, g2);
  }
  function RoundNumberToIncrement(t2, r2, o2) {
    if (1 === r2)
      return t2;
    let { quotient: n2, remainder: a2 } = divmod(t2, import_jsbi.default.BigInt(r2));
    if (import_jsbi.default.equal(a2, he))
      return t2;
    const i2 = import_jsbi.default.lessThan(a2, he) ? -1 : 1;
    switch (o2) {
      case "ceil":
        i2 > 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
        break;
      case "floor":
        i2 < 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
        break;
      case "trunc":
        break;
      case "halfExpand":
        import_jsbi.default.toNumber(abs(import_jsbi.default.multiply(a2, import_jsbi.default.BigInt(2)))) >= r2 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
    }
    return import_jsbi.default.multiply(n2, import_jsbi.default.BigInt(r2));
  }
  function RoundInstant(t2, r2, o2, n2) {
    let a2 = import_jsbi.default.remainder(t2, import_jsbi.default.BigInt(864e11));
    import_jsbi.default.lessThan(a2, he) && (a2 = import_jsbi.default.add(a2, import_jsbi.default.BigInt(864e11)));
    const i2 = import_jsbi.default.subtract(t2, a2), s2 = RoundNumberToIncrement(a2, Ne[o2] * r2, n2);
    return import_jsbi.default.add(i2, s2);
  }
  function RoundISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2 = 864e11) {
    const { deltaDays: u2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: S2, nanosecond: w2 } = RoundTime(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { year: g2, month: I2, day: D2 } = BalanceISODate(e2, t2, r2 + u2);
    return { year: g2, month: I2, day: D2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: S2, nanosecond: w2 };
  }
  function RoundTime(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2 = 864e11) {
    let c2 = he;
    switch (l2) {
      case "day":
      case "hour":
        c2 = import_jsbi.default.BigInt(t2);
      case "minute":
        c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, Te), import_jsbi.default.BigInt(r2));
      case "second":
        c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, Te), import_jsbi.default.BigInt(o2));
      case "millisecond":
        c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, pe), import_jsbi.default.BigInt(n2));
      case "microsecond":
        c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, pe), import_jsbi.default.BigInt(a2));
      case "nanosecond":
        c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, pe), import_jsbi.default.BigInt(i2));
    }
    const h2 = "day" === l2 ? m2 : Ne[l2], u2 = RoundNumberToIncrement(c2, h2 * s2, d2), T2 = import_jsbi.default.toNumber(import_jsbi.default.divide(u2, import_jsbi.default.BigInt(h2)));
    switch (l2) {
      case "day":
        return { deltaDays: T2, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };
      case "hour":
        return BalanceTime(T2, 0, 0, 0, 0, 0);
      case "minute":
        return BalanceTime(t2, T2, 0, 0, 0, 0);
      case "second":
        return BalanceTime(t2, r2, T2, 0, 0, 0);
      case "millisecond":
        return BalanceTime(t2, r2, o2, T2, 0, 0);
      case "microsecond":
        return BalanceTime(t2, r2, o2, n2, T2, 0);
      case "nanosecond":
        return BalanceTime(t2, r2, o2, n2, a2, T2);
      default:
        throw new Error(`Invalid unit ${l2}`);
    }
  }
  function DaysUntil(e2, t2) {
    return DifferenceISODate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), "day").days;
  }
  function MoveRelativeDate(e2, t2, r2) {
    const o2 = CalendarDateAdd(e2, t2, r2, void 0);
    return { relativeTo: o2, days: DaysUntil(t2, o2) };
  }
  function MoveRelativeZonedDateTime(e2, t2, r2, o2, n2) {
    const a2 = GetSlot(e2, p), i2 = GetSlot(e2, u);
    return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(e2, T), a2, i2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0), a2, i2);
  }
  function AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, f2, y2) {
    let S2 = t2, w2 = r2, g2 = o2, I2 = n2, D2 = a2, G2 = i2, v2 = s2, O2 = l2, C2 = d2, E2 = m2;
    if (!IsTemporalZonedDateTime(y2) || "year" === h2 || "month" === h2 || "week" === h2 || "day" === h2 || "nanosecond" === h2 && 1 === c2)
      return { years: S2, months: w2, weeks: g2, days: I2, hours: D2, minutes: G2, seconds: v2, milliseconds: O2, microseconds: C2, nanoseconds: E2 };
    let b2 = TotalDurationNanoseconds(0, D2, G2, v2, O2, C2, E2, 0);
    const M2 = ee(import_jsbi.default.toNumber(b2)), R2 = GetSlot(y2, p), Z2 = GetSlot(y2, u), P2 = AddZonedDateTime(GetSlot(y2, T), R2, Z2, S2, w2, g2, I2, 0, 0, 0, 0, 0, 0), F2 = AddZonedDateTime(new (GetIntrinsic("%Temporal.Instant%"))(P2), R2, Z2, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0), Y2 = import_jsbi.default.subtract(F2, P2);
    return import_jsbi.default.greaterThanOrEqual(import_jsbi.default.multiply(import_jsbi.default.subtract(b2, Y2), import_jsbi.default.BigInt(M2)), he) && ({ years: S2, months: w2, weeks: g2, days: I2 } = AddDuration(S2, w2, g2, I2, 0, 0, 0, 0, 0, 0, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0, y2), b2 = RoundInstant(import_jsbi.default.subtract(b2, Y2), c2, h2, f2), { hours: D2, minutes: G2, seconds: v2, milliseconds: O2, microseconds: C2, nanoseconds: E2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(b2), "hour")), { years: S2, months: w2, weeks: g2, days: I2, hours: D2, minutes: G2, seconds: v2, milliseconds: O2, microseconds: C2, nanoseconds: E2 };
  }
  function RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, T2, p2) {
    let f2 = t2, y2 = r2, S2 = o2, w2 = n2, g2 = a2, I2 = i2, D2 = s2, G2 = l2, v2 = d2, O2 = import_jsbi.default.BigInt(m2);
    const C2 = GetIntrinsic("%Temporal.Duration%");
    let E2, b2, M2, R2, Z2 = p2;
    if (Z2) {
      if (IsTemporalZonedDateTime(Z2))
        b2 = Z2, Z2 = ToTemporalDate(Z2);
      else if (!IsTemporalDate(Z2))
        throw new TypeError("starting point must be PlainDate or ZonedDateTime");
      E2 = GetSlot(Z2, u);
    }
    if ("year" === h2 || "month" === h2 || "week" === h2 || "day" === h2) {
      let t3, r3, o3;
      O2 = TotalDurationNanoseconds(0, g2, I2, D2, G2, v2, m2, 0), b2 && (t3 = MoveRelativeZonedDateTime(b2, f2, y2, S2, w2)), { days: r3, nanoseconds: O2, dayLengthNs: o3 } = NanosecondsToDays(O2, t3), M2 = import_jsbi.default.BigInt(o3), w2 += r3, g2 = I2 = D2 = G2 = v2 = 0;
    }
    switch (h2) {
      case "year": {
        if (!E2)
          throw new RangeError("A starting point is required for years rounding");
        const t3 = new C2(f2), r3 = E2.dateAdd, o3 = CalendarDateAdd(E2, Z2, t3, void 0, r3), n3 = CalendarDateAdd(E2, Z2, new C2(f2, y2, S2), void 0, r3);
        Z2 = o3, w2 += DaysUntil(o3, n3);
        const a3 = CalendarDateAdd(E2, Z2, { days: w2 }, void 0, r3), i3 = le(null);
        i3.largestUnit = "year";
        const s3 = CalendarDateUntil(E2, Z2, a3, i3).years;
        f2 += s3;
        const l3 = Z2;
        Z2 = CalendarDateAdd(E2, Z2, { years: s3 }, void 0, r3);
        w2 -= DaysUntil(l3, Z2);
        const d3 = new C2(w2 < 0 ? -1 : 1);
        let { days: m3 } = MoveRelativeDate(E2, Z2, d3);
        m3 = K(m3);
        const h3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(m3), M2);
        O2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(f2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), M2)), O2);
        const u2 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(c2))), T2);
        R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(h3), f2 = import_jsbi.default.toNumber(import_jsbi.default.divide(u2, h3)), O2 = he, y2 = S2 = w2 = 0;
        break;
      }
      case "month": {
        if (!E2)
          throw new RangeError("A starting point is required for months rounding");
        const t3 = new C2(f2, y2), r3 = E2.dateAdd, o3 = CalendarDateAdd(E2, Z2, t3, void 0, r3), n3 = CalendarDateAdd(E2, Z2, new C2(f2, y2, S2), void 0, r3);
        Z2 = o3, w2 += DaysUntil(o3, n3);
        const a3 = ee(w2), i3 = new C2(0, w2 < 0 ? -1 : 1);
        let s3;
        for ({ relativeTo: Z2, days: s3 } = MoveRelativeDate(E2, Z2, i3); K(w2) >= K(s3); )
          y2 += a3, w2 -= s3, { relativeTo: Z2, days: s3 } = MoveRelativeDate(E2, Z2, i3);
        s3 = K(s3);
        const l3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(s3), M2);
        O2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(y2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), M2)), O2);
        const d3 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(c2))), T2);
        R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(l3), y2 = import_jsbi.default.toNumber(import_jsbi.default.divide(d3, l3)), O2 = he, S2 = w2 = 0;
        break;
      }
      case "week": {
        if (!E2)
          throw new RangeError("A starting point is required for weeks rounding");
        const t3 = ee(w2), r3 = new C2(0, 0, w2 < 0 ? -1 : 1);
        let o3;
        for ({ relativeTo: Z2, days: o3 } = MoveRelativeDate(E2, Z2, r3); K(w2) >= K(o3); )
          S2 += t3, w2 -= o3, { relativeTo: Z2, days: o3 } = MoveRelativeDate(E2, Z2, r3);
        o3 = K(o3);
        const n3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(o3), M2);
        O2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(n3, import_jsbi.default.BigInt(S2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), M2)), O2);
        const a3 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(n3, import_jsbi.default.BigInt(c2))), T2);
        R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(n3), S2 = import_jsbi.default.toNumber(import_jsbi.default.divide(a3, n3)), O2 = he, w2 = 0;
        break;
      }
      case "day": {
        const t3 = M2;
        O2 = import_jsbi.default.add(import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(w2)), O2);
        const r3 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(c2))), T2);
        R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(t3), w2 = import_jsbi.default.toNumber(import_jsbi.default.divide(r3, t3)), O2 = he;
        break;
      }
      case "hour": {
        const t3 = 36e11;
        let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(g2), import_jsbi.default.BigInt(36e11));
        r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(I2), import_jsbi.default.BigInt(6e10))), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ye)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
        const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
        g2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, I2 = D2 = G2 = v2 = 0;
        break;
      }
      case "minute": {
        const t3 = 6e10;
        let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(I2), import_jsbi.default.BigInt(6e10));
        r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ye)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
        const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
        I2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, D2 = G2 = v2 = 0;
        break;
      }
      case "second": {
        const t3 = 1e9;
        let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ye);
        r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
        const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
        D2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, G2 = v2 = 0;
        break;
      }
      case "millisecond": {
        const t3 = 1e6;
        let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe);
        r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
        const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
        G2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, v2 = 0;
        break;
      }
      case "microsecond": {
        const t3 = 1e3;
        let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe);
        r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
        const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
        v2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he;
        break;
      }
      case "nanosecond":
        R2 = import_jsbi.default.toNumber(O2), O2 = RoundNumberToIncrement(O2, c2, T2);
    }
    return { years: f2, months: y2, weeks: S2, days: w2, hours: g2, minutes: I2, seconds: D2, milliseconds: G2, microseconds: v2, nanoseconds: import_jsbi.default.toNumber(O2), total: R2 };
  }
  function CompareISODate(e2, t2, r2, o2, n2, a2) {
    for (const [i2, s2] of [[e2, o2], [t2, n2], [r2, a2]])
      if (i2 !== s2)
        return ComparisonResult(i2 - s2);
    return 0;
  }
  function NonNegativeModulo(e2, t2) {
    let r2 = e2 % t2;
    return me(r2, -0) ? 0 : (r2 < 0 && (r2 += t2), r2);
  }
  function ToBigIntExternal(e2) {
    const t2 = ToBigInt(e2);
    return void 0 !== globalThis.BigInt ? globalThis.BigInt(t2.toString(10)) : t2;
  }
  function ToBigInt(t2) {
    if (t2 instanceof import_jsbi.default)
      return t2;
    let r2 = t2;
    if ("object" == typeof t2) {
      const e2 = t2[Symbol.toPrimitive];
      e2 && "function" == typeof e2 && (r2 = ce(e2, t2, ["number"]));
    }
    switch (typeof r2) {
      case "undefined":
      case "object":
      case "number":
      case "symbol":
      default:
        throw new TypeError(`cannot convert ${typeof t2} to bigint`);
      case "string":
        if (!r2.match(/^\s*(?:[+-]?\d+\s*)?$/))
          throw new SyntaxError("invalid BigInt syntax");
      case "bigint":
        try {
          return import_jsbi.default.BigInt(r2.toString());
        } catch (e2) {
          if (e2 instanceof Error && e2.message.startsWith("Invalid integer"))
            throw new SyntaxError(e2.message);
          throw e2;
        }
      case "boolean":
        return r2 ? ue : he;
    }
  }
  var $e = (() => {
    let t2 = import_jsbi.default.BigInt(Date.now() % 1e6);
    return () => {
      const r2 = import_jsbi.default.BigInt(Date.now()), o2 = import_jsbi.default.add(import_jsbi.default.multiply(r2, fe), t2);
      return t2 = import_jsbi.default.remainder(r2, fe), import_jsbi.default.greaterThan(o2, Ie) ? Ie : import_jsbi.default.lessThan(o2, ge) ? ge : o2;
    };
  })();
  function ComparisonResult(e2) {
    return e2 < 0 ? -1 : e2 > 0 ? 1 : e2;
  }
  function GetOptionsObject(e2) {
    if (void 0 === e2)
      return le(null);
    if (IsObject(e2) && null !== e2)
      return e2;
    throw new TypeError("Options parameter must be an object, not " + (null === e2 ? "null" : typeof e2));
  }
  function CreateOnePropObject(e2, t2) {
    const r2 = le(null);
    return r2[e2] = t2, r2;
  }
  function GetOption(e2, t2, r2, o2) {
    let n2 = e2[t2];
    if (void 0 !== n2) {
      if (n2 = ToString(n2), !r2.includes(n2))
        throw new RangeError(`${t2} must be one of ${r2.join(", ")}, not ${n2}`);
      return n2;
    }
    return o2;
  }
  function IsBuiltinCalendar(e2) {
    return z.call(Ce, e2);
  }
  var Be = new RegExp(`^${B.source}$`);
  function bisect(t2, r2, o2, n2 = t2(r2), a2 = t2(o2)) {
    let i2 = import_jsbi.default.BigInt(r2), s2 = import_jsbi.default.BigInt(o2), l2 = n2, d2 = a2;
    for (; import_jsbi.default.greaterThan(import_jsbi.default.subtract(s2, i2), ue); ) {
      const r3 = import_jsbi.default.divide(import_jsbi.default.add(i2, s2), import_jsbi.default.BigInt(2)), o3 = t2(r3);
      if (o3 === l2)
        i2 = r3, l2 = o3;
      else {
        if (o3 !== d2)
          throw new Error(`invalid state in bisection ${l2} - ${o3} - ${d2}`);
        s2 = r3, d2 = o3;
      }
    }
    return s2;
  }
  var Ne = { hour: 36e11, minute: 6e10, second: 1e9, millisecond: 1e6, microsecond: 1e3, nanosecond: 1 };
  var ke = Symbol("date");
  var Ae = Symbol("ym");
  var Ue = Symbol("md");
  var Le = Symbol("time");
  var xe = Symbol("datetime");
  var He = Symbol("zoneddatetime");
  var qe = Symbol("instant");
  var We = Symbol("original");
  var ze = Symbol("timezone");
  var _e = Symbol("timezone-id-given");
  var Je = Symbol("calendar-id");
  var Ve = Symbol("locale");
  var Xe = Symbol("options");
  var descriptor = (e2) => ({ value: e2, enumerable: true, writable: false, configurable: true });
  var Ke = globalThis.Intl.DateTimeFormat;
  var Qe = Object.assign;
  var et = Object.prototype.hasOwnProperty;
  var tt = Reflect.apply;
  function getPropLazy(e2, t2) {
    let r2 = e2[t2];
    return "function" == typeof r2 && (r2 = new Ke(e2[Ve], r2(e2[Xe])), e2[t2] = r2), r2;
  }
  function getResolvedTimeZoneLazy(e2) {
    let t2 = e2[ze];
    return "string" == typeof t2 && (t2 = ToTemporalTimeZone(t2), e2[ze] = t2), t2;
  }
  function DateTimeFormatImpl(e2, t2 = {}) {
    if (!(this instanceof DateTimeFormatImpl))
      return new DateTimeFormatImpl(e2, t2);
    const r2 = void 0 !== t2, o2 = r2 ? Qe({}, t2) : {}, n2 = new Ke(e2, o2), a2 = n2.resolvedOptions();
    if (r2) {
      const e3 = Qe({}, a2);
      for (const t3 in e3)
        tt(et, o2, [t3]) || delete e3[t3];
      this[Xe] = e3;
    } else
      this[Xe] = o2;
    this[_e] = o2.timeZone ? o2.timeZone : null, this[Ve] = a2.locale, this[We] = n2, this[ze] = a2.timeZone, this[Je] = a2.calendar, this[ke] = dateAmend, this[Ae] = yearMonthAmend, this[Ue] = monthDayAmend, this[Le] = timeAmend, this[xe] = datetimeAmend, this[He] = zonedDateTimeAmend, this[qe] = instantAmend;
  }
  Object.defineProperty(DateTimeFormatImpl, "name", { writable: true, value: "DateTimeFormat" }), DateTimeFormatImpl.supportedLocalesOf = function(e2, t2) {
    return Ke.supportedLocalesOf(e2, t2);
  };
  var rt = { resolvedOptions: descriptor(function resolvedOptions() {
    return this[We].resolvedOptions();
  }), format: descriptor(function format3(e2, ...t2) {
    let { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this);
    if (r2 && o2)
      return o2 = adjustFormatterTimeZone(o2, n2), o2.format(r2.epochMilliseconds);
    return this[We].format(e2, ...t2);
  }), formatRange: descriptor(function formatRange(e2, t2) {
    if (isTemporalObject(e2) || isTemporalObject(t2)) {
      if (!sameTemporalType(e2, t2))
        throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
      const { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this), { instant: a2, formatter: i2, timeZone: s2 } = extractOverrides(t2, this);
      if (n2 && s2 && n2 !== s2)
        throw new RangeError("cannot format range between different time zones");
      if (r2 && a2 && o2 && i2 && o2 === i2) {
        return adjustFormatterTimeZone(o2, n2).formatRange(r2.epochMilliseconds, a2.epochMilliseconds);
      }
    }
    return this[We].formatRange(e2, t2);
  }) };
  "formatToParts" in Ke.prototype && (rt.formatToParts = descriptor(function formatToParts(e2, ...t2) {
    let { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this);
    if (r2 && o2)
      return o2 = adjustFormatterTimeZone(o2, n2), o2.formatToParts(r2.epochMilliseconds);
    return this[We].formatToParts(e2, ...t2);
  })), "formatRangeToParts" in Ke.prototype && (rt.formatRangeToParts = descriptor(function formatRangeToParts(e2, t2) {
    if (isTemporalObject(e2) || isTemporalObject(t2)) {
      if (!sameTemporalType(e2, t2))
        throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
      const { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this), { instant: a2, formatter: i2, timeZone: s2 } = extractOverrides(t2, this);
      if (n2 && s2 && n2 !== s2)
        throw new RangeError("cannot format range between different time zones");
      if (r2 && a2 && o2 && i2 && o2 === i2) {
        return adjustFormatterTimeZone(o2, n2).formatRangeToParts(r2.epochMilliseconds, a2.epochMilliseconds);
      }
    }
    return this[We].formatRangeToParts(e2, t2);
  })), DateTimeFormatImpl.prototype = Object.create(Ke.prototype, rt), Object.defineProperty(DateTimeFormatImpl, "prototype", { writable: false, enumerable: false, configurable: false });
  var ot = DateTimeFormatImpl;
  function adjustFormatterTimeZone(e2, t2) {
    if (!t2)
      return e2;
    const r2 = e2.resolvedOptions();
    return r2.timeZone === t2 ? e2 : ((r2.dateStyle || r2.timeStyle) && (delete r2.weekday, delete r2.era, delete r2.year, delete r2.month, delete r2.day, delete r2.hour, delete r2.minute, delete r2.second, delete r2.timeZoneName, delete r2.hourCycle, delete r2.hour12, delete r2.dayPeriod), new Ke(r2.locale, { ...r2, timeZone: t2 }));
  }
  function amend(e2 = {}, t2 = {}) {
    const r2 = Qe({}, e2);
    for (const e3 of ["year", "month", "day", "hour", "minute", "second", "weekday", "dayPeriod", "timeZoneName", "dateStyle", "timeStyle"])
      r2[e3] = e3 in t2 ? t2[e3] : r2[e3], false !== r2[e3] && void 0 !== r2[e3] || delete r2[e3];
    return r2;
  }
  function timeAmend(e2) {
    let t2 = amend(e2, { year: false, month: false, day: false, weekday: false, timeZoneName: false, dateStyle: false });
    return hasTimeOptions(t2) || (t2 = Qe({}, t2, { hour: "numeric", minute: "numeric", second: "numeric" })), t2;
  }
  function yearMonthAmend(e2) {
    let t2 = amend(e2, { day: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
    return "year" in t2 || "month" in t2 || (t2 = Qe(t2, { year: "numeric", month: "numeric" })), t2;
  }
  function monthDayAmend(e2) {
    let t2 = amend(e2, { year: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
    return "month" in t2 || "day" in t2 || (t2 = Qe({}, t2, { month: "numeric", day: "numeric" })), t2;
  }
  function dateAmend(e2) {
    let t2 = amend(e2, { hour: false, minute: false, second: false, dayPeriod: false, timeZoneName: false, timeStyle: false });
    return hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric" })), t2;
  }
  function datetimeAmend(e2) {
    let t2 = amend(e2, { timeZoneName: false });
    return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
  }
  function zonedDateTimeAmend(e2) {
    let t2 = e2;
    return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), void 0 === t2.timeZoneName && (t2.timeZoneName = "short")), t2;
  }
  function instantAmend(e2) {
    let t2 = e2;
    return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
  }
  function hasDateOptions(e2) {
    return "year" in e2 || "month" in e2 || "day" in e2 || "weekday" in e2 || "dateStyle" in e2;
  }
  function hasTimeOptions(e2) {
    return "hour" in e2 || "minute" in e2 || "second" in e2 || "timeStyle" in e2 || "dayPeriod" in e2;
  }
  function isTemporalObject(e2) {
    return IsTemporalDate(e2) || IsTemporalTime(e2) || IsTemporalDateTime(e2) || IsTemporalZonedDateTime(e2) || IsTemporalYearMonth(e2) || IsTemporalMonthDay(e2) || IsTemporalInstant(e2);
  }
  function sameTemporalType(e2, t2) {
    return !(!isTemporalObject(e2) || !isTemporalObject(t2)) && (!(IsTemporalTime(e2) && !IsTemporalTime(t2)) && (!(IsTemporalDate(e2) && !IsTemporalDate(t2)) && (!(IsTemporalDateTime(e2) && !IsTemporalDateTime(t2)) && (!(IsTemporalZonedDateTime(e2) && !IsTemporalZonedDateTime(t2)) && (!(IsTemporalYearMonth(e2) && !IsTemporalYearMonth(t2)) && (!(IsTemporalMonthDay(e2) && !IsTemporalMonthDay(t2)) && !(IsTemporalInstant(e2) && !IsTemporalInstant(t2))))))));
  }
  function extractOverrides(e2, t2) {
    const r2 = GetIntrinsic("%Temporal.PlainDateTime%");
    if (IsTemporalTime(e2)) {
      const o2 = new r2(1970, 1, 1, GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), t2[Je]);
      return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), o2, "compatible"), formatter: getPropLazy(t2, Le) };
    }
    if (IsTemporalYearMonth(e2)) {
      const o2 = GetSlot(e2, n), s2 = GetSlot(e2, a), l2 = GetSlot(e2, i), d2 = ToString(GetSlot(e2, u));
      if (d2 !== t2[Je])
        throw new RangeError(`cannot format PlainYearMonth with calendar ${d2} in locale with calendar ${t2[Je]}`);
      const m2 = new r2(o2, s2, l2, 12, 0, 0, 0, 0, 0, d2);
      return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), m2, "compatible"), formatter: getPropLazy(t2, Ae) };
    }
    if (IsTemporalMonthDay(e2)) {
      const o2 = GetSlot(e2, n), s2 = GetSlot(e2, a), l2 = GetSlot(e2, i), d2 = ToString(GetSlot(e2, u));
      if (d2 !== t2[Je])
        throw new RangeError(`cannot format PlainMonthDay with calendar ${d2} in locale with calendar ${t2[Je]}`);
      const m2 = new r2(o2, s2, l2, 12, 0, 0, 0, 0, 0, d2);
      return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), m2, "compatible"), formatter: getPropLazy(t2, Ue) };
    }
    if (IsTemporalDate(e2)) {
      const o2 = GetSlot(e2, n), s2 = GetSlot(e2, a), l2 = GetSlot(e2, i), d2 = ToString(GetSlot(e2, u));
      if ("iso8601" !== d2 && d2 !== t2[Je])
        throw new RangeError(`cannot format PlainDate with calendar ${d2} in locale with calendar ${t2[Je]}`);
      const m2 = new r2(o2, s2, l2, 12, 0, 0, 0, 0, 0, t2[Je]);
      return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), m2, "compatible"), formatter: getPropLazy(t2, ke) };
    }
    if (IsTemporalDateTime(e2)) {
      const o2 = GetSlot(e2, n), T2 = GetSlot(e2, a), p2 = GetSlot(e2, i), f2 = GetSlot(e2, s), y2 = GetSlot(e2, l), S2 = GetSlot(e2, d), w2 = GetSlot(e2, m), g2 = GetSlot(e2, c), I2 = GetSlot(e2, h), D2 = ToString(GetSlot(e2, u));
      if ("iso8601" !== D2 && D2 !== t2[Je])
        throw new RangeError(`cannot format PlainDateTime with calendar ${D2} in locale with calendar ${t2[Je]}`);
      let G2 = e2;
      return "iso8601" === D2 && (G2 = new r2(o2, T2, p2, f2, y2, S2, w2, g2, I2, t2[Je])), { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), G2, "compatible"), formatter: getPropLazy(t2, xe) };
    }
    if (IsTemporalZonedDateTime(e2)) {
      const r3 = ToString(GetSlot(e2, u));
      if ("iso8601" !== r3 && r3 !== t2[Je])
        throw new RangeError(`cannot format ZonedDateTime with calendar ${r3} in locale with calendar ${t2[Je]}`);
      const o2 = ToString(GetSlot(e2, p));
      if (t2[_e] && t2[_e] !== o2)
        throw new RangeError(`timeZone option ${t2[_e]} doesn't match actual time zone ${o2}`);
      return { instant: GetSlot(e2, T), formatter: getPropLazy(t2, He), timeZone: o2 };
    }
    return IsTemporalInstant(e2) ? { instant: e2, formatter: getPropLazy(t2, qe) } : {};
  }
  var nt = Object.freeze({ __proto__: null, DateTimeFormat: ot });
  var Instant = class {
    constructor(e2) {
      if (arguments.length < 1)
        throw new TypeError("missing argument: epochNanoseconds is required");
      const t2 = ToBigInt(e2);
      ValidateEpochNanoseconds(t2), CreateSlots(this), SetSlot(this, r, t2);
    }
    get epochSeconds() {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      const t2 = GetSlot(this, r);
      return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, ye));
    }
    get epochMilliseconds() {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      const t2 = import_jsbi.default.BigInt(GetSlot(this, r));
      return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, fe));
    }
    get epochMicroseconds() {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      const t2 = import_jsbi.default.BigInt(GetSlot(this, r));
      return ToBigIntExternal(import_jsbi.default.divide(t2, pe));
    }
    get epochNanoseconds() {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      return ToBigIntExternal(import_jsbi.default.BigInt(GetSlot(this, r)));
    }
    add(e2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromInstant("add", this, e2);
    }
    subtract(e2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromInstant("subtract", this, e2);
    }
    until(e2, t2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalInstant("until", this, e2, t2);
    }
    since(e2, t2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalInstant("since", this, e2, t2);
    }
    round(e2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e2)
        throw new TypeError("options parameter is required");
      const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), o2 = GetTemporalUnit(t2, "smallestUnit", "time", je), n2 = ToTemporalRoundingMode(t2, "halfExpand"), a2 = ToTemporalRoundingIncrement(t2, { hour: 24, minute: 1440, second: 86400, millisecond: 864e5, microsecond: 864e8, nanosecond: 864e11 }[o2], true), i2 = RoundInstant(GetSlot(this, r), a2, o2, n2);
      return new Instant(i2);
    }
    equals(t2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      const o2 = ToTemporalInstant(t2), n2 = GetSlot(this, r), a2 = GetSlot(o2, r);
      return import_jsbi.default.equal(import_jsbi.default.BigInt(n2), import_jsbi.default.BigInt(a2));
    }
    toString(e2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      const t2 = GetOptionsObject(e2);
      let o2 = t2.timeZone;
      void 0 !== o2 && (o2 = ToTemporalTimeZone(o2));
      const { precision: n2, unit: a2, increment: i2 } = ToSecondsStringPrecision(t2), s2 = ToTemporalRoundingMode(t2, "trunc"), l2 = RoundInstant(GetSlot(this, r), i2, a2, s2);
      return TemporalInstantToString(new Instant(l2), o2, n2);
    }
    toJSON() {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      return TemporalInstantToString(this, void 0, "auto");
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      return new ot(e2, t2).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.Instant");
    }
    toZonedDateTime(e2) {
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid argument in toZonedDateTime");
      const t2 = e2.calendar;
      if (void 0 === t2)
        throw new TypeError("missing calendar property in toZonedDateTime");
      const o2 = ToTemporalCalendar(t2), n2 = e2.timeZone;
      if (void 0 === n2)
        throw new TypeError("missing timeZone property in toZonedDateTime");
      const a2 = ToTemporalTimeZone(n2);
      return CreateTemporalZonedDateTime(GetSlot(this, r), a2, o2);
    }
    toZonedDateTimeISO(e2) {
      let t2 = e2;
      if (!IsTemporalInstant(this))
        throw new TypeError("invalid receiver");
      if (IsObject(t2)) {
        const e3 = t2.timeZone;
        void 0 !== e3 && (t2 = e3);
      }
      const o2 = ToTemporalTimeZone(t2), n2 = GetISO8601Calendar();
      return CreateTemporalZonedDateTime(GetSlot(this, r), o2, n2);
    }
    static fromEpochSeconds(t2) {
      const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), ye);
      return ValidateEpochNanoseconds(o2), new Instant(o2);
    }
    static fromEpochMilliseconds(t2) {
      const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), fe);
      return ValidateEpochNanoseconds(o2), new Instant(o2);
    }
    static fromEpochMicroseconds(t2) {
      const r2 = ToBigInt(t2), o2 = import_jsbi.default.multiply(r2, pe);
      return ValidateEpochNanoseconds(o2), new Instant(o2);
    }
    static fromEpochNanoseconds(e2) {
      const t2 = ToBigInt(e2);
      return ValidateEpochNanoseconds(t2), new Instant(t2);
    }
    static from(e2) {
      return IsTemporalInstant(e2) ? new Instant(GetSlot(e2, r)) : ToTemporalInstant(e2);
    }
    static compare(t2, o2) {
      const n2 = ToTemporalInstant(t2), a2 = ToTemporalInstant(o2), i2 = GetSlot(n2, r), s2 = GetSlot(a2, r);
      return import_jsbi.default.lessThan(i2, s2) ? -1 : import_jsbi.default.greaterThan(i2, s2) ? 1 : 0;
    }
  };
  MakeIntrinsicClass(Instant, "Temporal.Instant");
  var at = Array.prototype.includes;
  var it = Array.prototype.push;
  var st = globalThis.Intl.DateTimeFormat;
  var lt = Array.prototype.sort;
  var dt = Math.abs;
  var mt = Math.floor;
  var ct = Object.entries;
  var ht = Object.keys;
  var ut = {};
  var Calendar = class {
    constructor(e2) {
      if (arguments.length < 1)
        throw new RangeError("missing argument: id is required");
      const t2 = ToString(e2);
      if (!IsBuiltinCalendar(t2))
        throw new RangeError(`invalid calendar identifier ${t2}`);
      CreateSlots(this), SetSlot(this, C, t2);
    }
    get id() {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return ToString(this);
    }
    dateFromFields(e2, t2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid fields");
      const r2 = GetOptionsObject(t2);
      return ut[GetSlot(this, C)].dateFromFields(e2, r2, this);
    }
    yearMonthFromFields(e2, t2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid fields");
      const r2 = GetOptionsObject(t2);
      return ut[GetSlot(this, C)].yearMonthFromFields(e2, r2, this);
    }
    monthDayFromFields(e2, t2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid fields");
      const r2 = GetOptionsObject(t2);
      return ut[GetSlot(this, C)].monthDayFromFields(e2, r2, this);
    }
    fields(e2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      const t2 = [], r2 = /* @__PURE__ */ new Set(["year", "month", "monthCode", "day", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"]);
      for (const o2 of e2) {
        if ("string" != typeof o2)
          throw new TypeError("invalid fields");
        if (!r2.has(o2))
          throw new RangeError(`invalid field name ${o2}`);
        r2.delete(o2), it.call(t2, o2);
      }
      return ut[GetSlot(this, C)].fields(t2);
    }
    mergeFields(e2, t2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return ut[GetSlot(this, C)].mergeFields(e2, t2);
    }
    dateAdd(e2, t2, r2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      const o2 = ToTemporalDate(e2), n2 = ToTemporalDuration(t2), a2 = ToTemporalOverflow(GetOptionsObject(r2)), { days: i2 } = BalanceDuration(GetSlot(n2, w), GetSlot(n2, g), GetSlot(n2, I), GetSlot(n2, D), GetSlot(n2, G), GetSlot(n2, v), GetSlot(n2, O), "day");
      return ut[GetSlot(this, C)].dateAdd(o2, GetSlot(n2, f), GetSlot(n2, y), GetSlot(n2, S), i2, a2, this);
    }
    dateUntil(e2, t2, r2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      const o2 = ToTemporalDate(e2), n2 = ToTemporalDate(t2);
      let a2 = GetTemporalUnit(GetOptionsObject(r2), "largestUnit", "date", "auto");
      "auto" === a2 && (a2 = "day");
      const { years: i2, months: s2, weeks: l2, days: d2 } = ut[GetSlot(this, C)].dateUntil(o2, n2, a2);
      return new (GetIntrinsic("%Temporal.Duration%"))(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
    }
    year(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].year(t2);
    }
    month(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      if (IsTemporalMonthDay(t2))
        throw new TypeError("use monthCode on PlainMonthDay instead");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].month(t2);
    }
    monthCode(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].monthCode(t2);
    }
    day(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].day(t2);
    }
    era(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].era(t2);
    }
    eraYear(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].eraYear(t2);
    }
    dayOfWeek(e2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2);
      return ut[GetSlot(this, C)].dayOfWeek(t2);
    }
    dayOfYear(e2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2);
      return ut[GetSlot(this, C)].dayOfYear(t2);
    }
    weekOfYear(e2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2);
      return ut[GetSlot(this, C)].weekOfYear(t2);
    }
    daysInWeek(e2) {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2);
      return ut[GetSlot(this, C)].daysInWeek(t2);
    }
    daysInMonth(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].daysInMonth(t2);
    }
    daysInYear(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].daysInYear(t2);
    }
    monthsInYear(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].monthsInYear(t2);
    }
    inLeapYear(e2) {
      let t2 = e2;
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].inLeapYear(t2);
    }
    toString() {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, C);
    }
    toJSON() {
      if (!IsTemporalCalendar(this))
        throw new TypeError("invalid receiver");
      return ToString(this);
    }
    static from(e2) {
      return ToTemporalCalendar(e2);
    }
  };
  function monthCodeNumberPart(e2) {
    if (!e2.startsWith("M"))
      throw new RangeError(`Invalid month code: ${e2}.  Month codes must start with M.`);
    const t2 = +e2.slice(1);
    if (isNaN(t2))
      throw new RangeError(`Invalid month code: ${e2}`);
    return t2;
  }
  function buildMonthCode(e2, t2 = false) {
    return `M${e2.toString().padStart(2, "0")}${t2 ? "L" : ""}`;
  }
  function resolveNonLunisolarMonth(e2, t2, r2 = 12) {
    let { month: o2, monthCode: n2 } = e2;
    if (void 0 === n2) {
      if (void 0 === o2)
        throw new TypeError("Either month or monthCode are required");
      "reject" === t2 && RejectToRange(o2, 1, r2), "constrain" === t2 && (o2 = ConstrainToRange(o2, 1, r2)), n2 = buildMonthCode(o2);
    } else {
      const e3 = monthCodeNumberPart(n2);
      if (void 0 !== o2 && o2 !== e3)
        throw new RangeError(`monthCode ${n2} and month ${o2} must match if both are present`);
      if (n2 !== buildMonthCode(e3))
        throw new RangeError(`Invalid month code: ${n2}`);
      if (o2 = e3, o2 < 1 || o2 > r2)
        throw new RangeError(`Invalid monthCode: ${n2}`);
    }
    return { ...e2, month: o2, monthCode: n2 };
  }
  MakeIntrinsicClass(Calendar, "Temporal.Calendar"), DefineIntrinsic("Temporal.Calendar.from", Calendar.from), ut.iso8601 = { dateFromFields(e2, t2, r2) {
    const o2 = ToTemporalOverflow(t2);
    let n2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["year", "day"]);
    n2 = resolveNonLunisolarMonth(n2);
    let { year: a2, month: i2, day: s2 } = n2;
    return { year: a2, month: i2, day: s2 } = RegulateISODate(a2, i2, s2, o2), CreateTemporalDate(a2, i2, s2, r2);
  }, yearMonthFromFields(e2, t2, r2) {
    const o2 = ToTemporalOverflow(t2);
    let n2 = PrepareTemporalFields(e2, ["month", "monthCode", "year"], ["year"]);
    n2 = resolveNonLunisolarMonth(n2);
    let { year: a2, month: i2 } = n2;
    return { year: a2, month: i2 } = function RegulateISOYearMonth(e3, t3, r3) {
      let o3 = e3, n3 = t3;
      switch (r3) {
        case "reject":
          RejectISODate(o3, n3, 1);
          break;
        case "constrain":
          ({ year: o3, month: n3 } = ConstrainISODate(o3, n3));
      }
      return { year: o3, month: n3 };
    }(a2, i2, o2), CreateTemporalYearMonth(a2, i2, r2, 1);
  }, monthDayFromFields(e2, t2, r2) {
    const o2 = ToTemporalOverflow(t2);
    let n2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["day"]);
    if (void 0 !== n2.month && void 0 === n2.year && void 0 === n2.monthCode)
      throw new TypeError("either year or monthCode required with month");
    const a2 = void 0 === n2.monthCode;
    n2 = resolveNonLunisolarMonth(n2);
    let { month: i2, day: s2, year: l2 } = n2;
    return { month: i2, day: s2 } = RegulateISODate(a2 ? l2 : 1972, i2, s2, o2), CreateTemporalMonthDay(i2, s2, r2, 1972);
  }, fields: (e2) => e2, mergeFields(e2, t2) {
    const r2 = {};
    for (const t3 of ht(e2))
      "month" !== t3 && "monthCode" !== t3 && (r2[t3] = e2[t3]);
    const o2 = ht(t2);
    for (const e3 of o2)
      r2[e3] = t2[e3];
    if (!at.call(o2, "month") && !at.call(o2, "monthCode")) {
      const { month: t3, monthCode: o3 } = e2;
      void 0 !== t3 && (r2.month = t3), void 0 !== o3 && (r2.monthCode = o3);
    }
    return r2;
  }, dateAdd(e2, t2, r2, o2, s2, l2, d2) {
    let m2 = GetSlot(e2, n), c2 = GetSlot(e2, a), h2 = GetSlot(e2, i);
    return { year: m2, month: c2, day: h2 } = AddISODate(m2, c2, h2, t2, r2, o2, s2, l2), CreateTemporalDate(m2, c2, h2, d2);
  }, dateUntil: (e2, t2, r2) => DifferenceISODate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), r2), year: (e2) => GetSlot(e2, n), era() {
  }, eraYear() {
  }, month: (e2) => GetSlot(e2, a), monthCode: (e2) => buildMonthCode(GetSlot(e2, a)), day: (e2) => GetSlot(e2, i), dayOfWeek: (e2) => DayOfWeek(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i)), dayOfYear: (e2) => DayOfYear(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i)), weekOfYear: (e2) => function WeekOfYear(e3, t2, r2) {
    const o2 = DayOfYear(e3, t2, r2), n2 = DayOfWeek(e3, t2, r2) || 7, a2 = DayOfWeek(e3, 1, 1), i2 = Q((o2 - n2 + 10) / 7);
    return i2 < 1 ? 5 === a2 || 6 === a2 && LeapYear(e3 - 1) ? 53 : 52 : 53 === i2 && (LeapYear(e3) ? 366 : 365) - o2 < 4 - n2 ? 1 : i2;
  }(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i)), daysInWeek: () => 7, daysInMonth: (e2) => ISODaysInMonth(GetSlot(e2, n), GetSlot(e2, a)), daysInYear(e2) {
    let t2 = e2;
    return HasSlot(t2, n) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, n)) ? 366 : 365;
  }, monthsInYear: () => 12, inLeapYear(e2) {
    let t2 = e2;
    return HasSlot(t2, n) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, n));
  } };
  var OneObjectCache = class {
    constructor(e2) {
      if (this.map = /* @__PURE__ */ new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e2) {
        let t2 = 0;
        for (const r2 of e2.map.entries()) {
          if (++t2 > OneObjectCache.MAX_CACHE_ENTRIES)
            break;
          this.map.set(...r2);
        }
      }
    }
    get(e2) {
      const t2 = this.map.get(e2);
      return t2 && (this.hits++, this.report()), this.calls++, t2;
    }
    set(e2, t2) {
      this.map.set(e2, t2), this.misses++, this.report();
    }
    report() {
    }
    setObject(e2) {
      if (OneObjectCache.objectMap.get(e2))
        throw new RangeError("object already cached");
      OneObjectCache.objectMap.set(e2, this), this.report();
    }
    static getCacheForObject(e2) {
      let t2 = OneObjectCache.objectMap.get(e2);
      return t2 || (t2 = new OneObjectCache(), OneObjectCache.objectMap.set(e2, t2)), t2;
    }
  };
  function toUtcIsoDateString({ isoYear: e2, isoMonth: t2, isoDay: r2 }) {
    return `${ISOYearString(e2)}-${ISODateTimePartString(t2)}-${ISODateTimePartString(r2)}T00:00Z`;
  }
  function simpleDateDiff(e2, t2) {
    return { years: e2.year - t2.year, months: e2.month - t2.month, days: e2.day - t2.day };
  }
  OneObjectCache.objectMap = /* @__PURE__ */ new WeakMap(), OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
  var HelperBase = class {
    constructor() {
      this.eraLength = "short", this.hasEra = true;
    }
    getFormatter() {
      return void 0 === this.formatter && (this.formatter = new st(`en-US-u-ca-${this.id}`, { day: "numeric", month: "numeric", year: "numeric", era: this.eraLength, timeZone: "UTC" })), this.formatter;
    }
    isoToCalendarDate(e2, t2) {
      const { year: r2, month: o2, day: n2 } = e2, a2 = JSON.stringify({ func: "isoToCalendarDate", isoYear: r2, isoMonth: o2, isoDay: n2, id: this.id }), i2 = t2.get(a2);
      if (i2)
        return i2;
      const s2 = this.getFormatter();
      let l2, d2;
      try {
        d2 = toUtcIsoDateString({ isoYear: r2, isoMonth: o2, isoDay: n2 }), l2 = s2.formatToParts(new Date(d2));
      } catch (e3) {
        throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear: r2, isoMonth: o2, isoDay: n2 })}`);
      }
      const m2 = {};
      for (let { type: e3, value: t3 } of l2) {
        if ("year" === e3 && (m2.eraYear = +t3), "relatedYear" === e3 && (m2.eraYear = +t3), "month" === e3) {
          const e4 = /^([0-9]*)(.*?)$/.exec(t3);
          if (!e4 || 3 != e4.length || !e4[1] && !e4[2])
            throw new RangeError(`Unexpected month: ${t3}`);
          if (m2.month = e4[1] ? +e4[1] : 1, m2.month < 1)
            throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
          if (m2.month > 13)
            throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
          e4[2] && (m2.monthExtra = e4[2]);
        }
        "day" === e3 && (m2.day = +t3), this.hasEra && "era" === e3 && null != t3 && "" !== t3 && (t3 = t3.split(" (")[0], m2.era = t3.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase());
      }
      if (void 0 === m2.eraYear)
        throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
      if (this.reviseIntlEra) {
        const { era: t3, eraYear: r3 } = this.reviseIntlEra(m2, e2);
        m2.era = t3, m2.eraYear = r3;
      }
      this.checkIcuBugs && this.checkIcuBugs(e2);
      const c2 = this.adjustCalendarDate(m2, t2, "constrain", true);
      if (void 0 === c2.year)
        throw new RangeError(`Missing year converting ${JSON.stringify(e2)}`);
      if (void 0 === c2.month)
        throw new RangeError(`Missing month converting ${JSON.stringify(e2)}`);
      if (void 0 === c2.day)
        throw new RangeError(`Missing day converting ${JSON.stringify(e2)}`);
      return t2.set(a2, c2), ["constrain", "reject"].forEach((r3) => {
        const o3 = JSON.stringify({ func: "calendarToIsoDate", year: c2.year, month: c2.month, day: c2.day, overflow: r3, id: this.id });
        t2.set(o3, e2);
      }), c2;
    }
    validateCalendarDate(e2) {
      const { era: t2, month: r2, year: o2, day: n2, eraYear: a2, monthCode: i2, monthExtra: s2 } = e2;
      if (void 0 !== s2)
        throw new RangeError("Unexpected `monthExtra` value");
      if (void 0 === o2 && void 0 === a2)
        throw new TypeError("year or eraYear is required");
      if (void 0 === r2 && void 0 === i2)
        throw new TypeError("month or monthCode is required");
      if (void 0 === n2)
        throw new RangeError("Missing day");
      if (void 0 !== i2) {
        if ("string" != typeof i2)
          throw new RangeError("monthCode must be a string, not " + typeof i2);
        if (!/^M([01]?\d)(L?)$/.test(i2))
          throw new RangeError(`Invalid monthCode: ${i2}`);
      }
      if (this.constantEra) {
        if (void 0 !== t2 && t2 !== this.constantEra)
          throw new RangeError(`era must be ${this.constantEra}, not ${t2}`);
        if (void 0 !== a2 && void 0 !== o2 && a2 !== o2)
          throw new RangeError(`eraYear ${a2} does not match year ${o2}`);
      }
    }
    adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
      if ("lunisolar" === this.calendarType)
        throw new RangeError("Override required for lunisolar calendars");
      let n2 = e2;
      if (this.validateCalendarDate(n2), this.constantEra) {
        const { year: e3, eraYear: t3 } = n2;
        n2 = { ...n2, era: this.constantEra, year: void 0 !== e3 ? e3 : t3, eraYear: void 0 !== t3 ? t3 : e3 };
      }
      const a2 = this.monthsInYear(n2, t2);
      let { month: i2, monthCode: s2 } = n2;
      return { month: i2, monthCode: s2 } = resolveNonLunisolarMonth(n2, r2, a2), { ...n2, month: i2, monthCode: s2 };
    }
    regulateMonthDayNaive(e2, t2, r2) {
      const o2 = this.monthsInYear(e2, r2);
      let { month: n2, day: a2 } = e2;
      return "reject" === t2 ? (RejectToRange(n2, 1, o2), RejectToRange(a2, 1, this.maximumMonthLength(e2))) : (n2 = ConstrainToRange(n2, 1, o2), a2 = ConstrainToRange(a2, 1, this.maximumMonthLength({ ...e2, month: n2 }))), { ...e2, month: n2, day: a2 };
    }
    calendarToIsoDate(e2, t2 = "constrain", r2) {
      const o2 = e2;
      let n2 = this.adjustCalendarDate(e2, r2, t2, false);
      n2 = this.regulateMonthDayNaive(n2, t2, r2);
      const { year: a2, month: i2, day: s2 } = n2, l2 = JSON.stringify({ func: "calendarToIsoDate", year: a2, month: i2, day: s2, overflow: t2, id: this.id });
      let d2, m2 = r2.get(l2);
      if (m2)
        return m2;
      if (void 0 !== o2.year && void 0 !== o2.month && void 0 !== o2.day && (o2.year !== n2.year || o2.month !== n2.month || o2.day !== n2.day) && (d2 = JSON.stringify({ func: "calendarToIsoDate", year: o2.year, month: o2.month, day: o2.day, overflow: t2, id: this.id }), m2 = r2.get(d2), m2))
        return m2;
      let c2 = this.estimateIsoDate({ year: a2, month: i2, day: s2 });
      const calculateSameMonthResult = (e3) => {
        let o3 = this.addDaysIso(c2, e3);
        if (n2.day > this.minimumMonthLength(n2)) {
          let e4 = this.isoToCalendarDate(o3, r2);
          for (; e4.month !== i2 || e4.year !== a2; ) {
            if ("reject" === t2)
              throw new RangeError(`day ${s2} does not exist in month ${i2} of year ${a2}`);
            o3 = this.addDaysIso(o3, -1), e4 = this.isoToCalendarDate(o3, r2);
          }
        }
        return o3;
      };
      let h2 = 0, u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2);
      if (0 !== T2.years || 0 !== T2.months || 0 !== T2.days) {
        const e3 = 365 * T2.years + 30 * T2.months + T2.days;
        c2 = this.addDaysIso(c2, e3), u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months ? c2 = calculateSameMonthResult(T2.days) : h2 = this.compareCalendarDates(n2, u2);
      }
      let p2 = 8, f2 = false;
      for (; h2; ) {
        c2 = this.addDaysIso(c2, h2 * p2);
        const e3 = u2;
        u2 = this.isoToCalendarDate(c2, r2);
        const a3 = h2;
        if (h2 = this.compareCalendarDates(n2, u2), h2) {
          if (T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months)
            c2 = calculateSameMonthResult(T2.days), h2 = 0, f2 = n2.day > this.minimumMonthLength(n2);
          else if (a3 && h2 !== a3)
            if (p2 > 1)
              p2 /= 2;
            else {
              if ("reject" === t2)
                throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...o2 })}`);
              this.compareCalendarDates(u2, e3) > 0 && (c2 = this.addDaysIso(c2, -1)), f2 = true, h2 = 0;
            }
        }
      }
      if (r2.set(l2, c2), d2 && r2.set(d2, c2), void 0 === n2.year || void 0 === n2.month || void 0 === n2.day || void 0 === n2.monthCode || this.hasEra && (void 0 === n2.era || void 0 === n2.eraYear))
        throw new RangeError("Unexpected missing property");
      if (!f2) {
        const e3 = JSON.stringify({ func: "isoToCalendarDate", isoYear: c2.year, isoMonth: c2.month, isoDay: c2.day, id: this.id });
        r2.set(e3, n2);
      }
      return c2;
    }
    temporalToCalendarDate(e2, t2) {
      const r2 = { year: GetSlot(e2, n), month: GetSlot(e2, a), day: GetSlot(e2, i) };
      return this.isoToCalendarDate(r2, t2);
    }
    compareCalendarDates(e2, t2) {
      const r2 = PrepareTemporalFields(e2, ["day", "month", "year"], ["day", "month", "year"]), o2 = PrepareTemporalFields(t2, ["day", "month", "year"], ["day", "month", "year"]);
      return r2.year !== o2.year ? ComparisonResult(r2.year - o2.year) : r2.month !== o2.month ? ComparisonResult(r2.month - o2.month) : r2.day !== o2.day ? ComparisonResult(r2.day - o2.day) : 0;
    }
    regulateDate(e2, t2 = "constrain", r2) {
      const o2 = this.calendarToIsoDate(e2, t2, r2);
      return this.isoToCalendarDate(o2, r2);
    }
    addDaysIso(e2, t2) {
      return AddISODate(e2.year, e2.month, e2.day, 0, 0, 0, t2, "constrain");
    }
    addDaysCalendar(e2, t2, r2) {
      const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.addDaysIso(o2, t2);
      return this.isoToCalendarDate(n2, r2);
    }
    addMonthsCalendar(e2, t2, r2, o2) {
      let n2 = e2;
      const { day: a2 } = n2;
      for (let e3 = 0, r3 = dt(t2); e3 < r3; e3++) {
        const { month: e4 } = n2, r4 = n2, i2 = t2 < 0 ? -Math.max(a2, this.daysInPreviousMonth(n2, o2)) : this.daysInMonth(n2, o2), s2 = this.calendarToIsoDate(n2, "constrain", o2);
        let l2 = this.addDaysIso(s2, i2);
        if (n2 = this.isoToCalendarDate(l2, o2), t2 > 0) {
          const t3 = this.monthsInYear(r4, o2);
          for (; n2.month - 1 != e4 % t3; )
            l2 = this.addDaysIso(l2, -1), n2 = this.isoToCalendarDate(l2, o2);
        }
        n2.day !== a2 && (n2 = this.regulateDate({ ...n2, day: a2 }, "constrain", o2));
      }
      if ("reject" === r2 && n2.day !== a2)
        throw new RangeError(`Day ${a2} does not exist in resulting calendar month`);
      return n2;
    }
    addCalendar(e2, { years: t2 = 0, months: r2 = 0, weeks: o2 = 0, days: n2 = 0 }, a2, i2) {
      const { year: s2, day: l2, monthCode: d2 } = e2, m2 = this.adjustCalendarDate({ year: s2 + t2, monthCode: d2, day: l2 }, i2), c2 = this.addMonthsCalendar(m2, r2, a2, i2), h2 = n2 + 7 * o2;
      return this.addDaysCalendar(c2, h2, i2);
    }
    untilCalendar(e2, t2, r2, o2) {
      let n2 = 0, a2 = 0, i2 = 0, s2 = 0;
      switch (r2) {
        case "day":
          n2 = this.calendarDaysUntil(e2, t2, o2);
          break;
        case "week": {
          const r3 = this.calendarDaysUntil(e2, t2, o2);
          n2 = r3 % 7, a2 = (r3 - n2) / 7;
          break;
        }
        case "month":
        case "year": {
          const a3 = t2.year - e2.year, l2 = t2.month - e2.month, d2 = t2.day - e2.day, m2 = this.compareCalendarDates(t2, e2);
          if (!m2)
            return { years: 0, months: 0, weeks: 0, days: 0 };
          if ("year" === r2 && a3) {
            s2 = l2 * m2 < 0 || 0 === l2 && d2 * m2 < 0 ? a3 - m2 : a3;
          }
          let c2, h2 = s2 ? this.addCalendar(e2, { years: s2 }, "constrain", o2) : e2;
          do {
            i2 += m2, c2 = h2, h2 = this.addMonthsCalendar(c2, m2, "constrain", o2), h2.day !== e2.day && (h2 = this.regulateDate({ ...h2, day: e2.day }, "constrain", o2));
          } while (this.compareCalendarDates(t2, h2) * m2 >= 0);
          i2 -= m2;
          n2 = this.calendarDaysUntil(c2, t2, o2);
          break;
        }
      }
      return { years: s2, months: i2, weeks: a2, days: n2 };
    }
    daysInMonth(e2, t2) {
      const { day: r2 } = e2, o2 = this.maximumMonthLength(e2), n2 = this.minimumMonthLength(e2);
      if (n2 === o2)
        return n2;
      const a2 = r2 <= o2 - n2 ? o2 : n2, i2 = this.calendarToIsoDate(e2, "constrain", t2), s2 = this.addDaysIso(i2, a2), l2 = this.isoToCalendarDate(s2, t2), d2 = this.addDaysIso(s2, -l2.day);
      return this.isoToCalendarDate(d2, t2).day;
    }
    daysInPreviousMonth(e2, t2) {
      const { day: r2, month: o2, year: n2 } = e2;
      let a2 = { year: o2 > 1 ? n2 : n2 - 1, month: o2, day: 1 };
      const i2 = o2 > 1 ? o2 - 1 : this.monthsInYear(a2, t2);
      a2 = { ...a2, month: i2 };
      const s2 = this.minimumMonthLength(a2), l2 = this.maximumMonthLength(a2);
      if (s2 === l2)
        return l2;
      const d2 = this.calendarToIsoDate(e2, "constrain", t2), m2 = this.addDaysIso(d2, -r2);
      return this.isoToCalendarDate(m2, t2).day;
    }
    startOfCalendarYear(e2) {
      return { year: e2.year, month: 1, monthCode: "M01", day: 1 };
    }
    startOfCalendarMonth(e2) {
      return { year: e2.year, month: e2.month, day: 1 };
    }
    calendarDaysUntil(e2, t2, r2) {
      const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.calendarToIsoDate(t2, "constrain", r2);
      return this.isoDaysUntil(o2, n2);
    }
    isoDaysUntil(e2, t2) {
      return DifferenceISODate(e2.year, e2.month, e2.day, t2.year, t2.month, t2.day, "day").days;
    }
    monthDayFromFields(e2, t2, r2) {
      let o2, n2, a2, i2, s2, { year: l2, month: d2, monthCode: m2, day: c2, era: h2, eraYear: u2 } = e2;
      if (void 0 === m2) {
        if (void 0 === l2 && (void 0 === h2 || void 0 === u2))
          throw new TypeError("`monthCode`, `year`, or `era` and `eraYear` is required");
        ({ monthCode: m2, year: l2 } = this.adjustCalendarDate({ year: l2, month: d2, monthCode: m2, day: c2, era: h2, eraYear: u2 }, r2, t2));
      }
      const { year: T2 } = this.isoToCalendarDate({ year: 1972, month: 1, day: 1 }, r2);
      for (let e3 = 0; e3 < 100; e3++) {
        const l3 = this.adjustCalendarDate({ day: c2, monthCode: m2, year: T2 - e3 }, r2), d3 = this.calendarToIsoDate(l3, "constrain", r2), h3 = this.isoToCalendarDate(d3, r2);
        if ({ year: o2, month: n2, day: a2 } = d3, h3.monthCode === m2 && h3.day === c2)
          return { month: n2, day: a2, year: o2 };
        "constrain" === t2 && (void 0 === i2 || h3.monthCode === i2.monthCode && h3.day > i2.day) && (i2 = h3, s2 = d3);
      }
      if ("constrain" === t2 && void 0 !== s2)
        return s2;
      throw new RangeError(`No recent ${this.id} year with monthCode ${m2} and day ${c2}`);
    }
  };
  var HebrewHelper = class extends HelperBase {
    constructor() {
      super(...arguments), this.id = "hebrew", this.calendarType = "lunisolar", this.months = { Tishri: { leap: 1, regular: 1, monthCode: "M01", days: 30 }, Heshvan: { leap: 2, regular: 2, monthCode: "M02", days: { min: 29, max: 30 } }, Kislev: { leap: 3, regular: 3, monthCode: "M03", days: { min: 29, max: 30 } }, Tevet: { leap: 4, regular: 4, monthCode: "M04", days: 29 }, Shevat: { leap: 5, regular: 5, monthCode: "M05", days: 30 }, Adar: { leap: void 0, regular: 6, monthCode: "M06", days: 29 }, "Adar I": { leap: 6, regular: void 0, monthCode: "M05L", days: 30 }, "Adar II": { leap: 7, regular: void 0, monthCode: "M06", days: 29 }, Nisan: { leap: 8, regular: 7, monthCode: "M07", days: 30 }, Iyar: { leap: 9, regular: 8, monthCode: "M08", days: 29 }, Sivan: { leap: 10, regular: 9, monthCode: "M09", days: 30 }, Tamuz: { leap: 11, regular: 10, monthCode: "M10", days: 29 }, Av: { leap: 12, regular: 11, monthCode: "M11", days: 30 }, Elul: { leap: 13, regular: 12, monthCode: "M12", days: 29 } }, this.hasEra = false;
    }
    inLeapYear(e2) {
      const { year: t2 } = e2;
      return (7 * t2 + 1) % 19 < 7;
    }
    monthsInYear(e2) {
      return this.inLeapYear(e2) ? 13 : 12;
    }
    minimumMonthLength(e2) {
      return this.minMaxMonthLength(e2, "min");
    }
    maximumMonthLength(e2) {
      return this.minMaxMonthLength(e2, "max");
    }
    minMaxMonthLength(e2, t2) {
      const { month: r2, year: o2 } = e2, n2 = this.getMonthCode(o2, r2), a2 = ct(this.months).find((e3) => e3[1].monthCode === n2);
      if (void 0 === a2)
        throw new RangeError(`unmatched Hebrew month: ${r2}`);
      const i2 = a2[1].days;
      return "number" == typeof i2 ? i2 : i2[t2];
    }
    estimateIsoDate(e2) {
      const { year: t2 } = e2;
      return { year: t2 - 3760, month: 1, day: 1 };
    }
    getMonthCode(e2, t2) {
      return this.inLeapYear({ year: e2 }) ? 6 === t2 ? buildMonthCode(5, true) : buildMonthCode(t2 < 6 ? t2 : t2 - 1) : buildMonthCode(t2);
    }
    adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
      let { year: n2, eraYear: a2, month: i2, monthCode: s2, day: l2, monthExtra: d2 } = e2;
      if (void 0 === n2 && void 0 !== a2 && (n2 = a2), void 0 === a2 && void 0 !== n2 && (a2 = n2), o2) {
        if (d2) {
          const e3 = this.months[d2];
          if (!e3)
            throw new RangeError(`Unrecognized month from formatToParts: ${d2}`);
          i2 = this.inLeapYear({ year: n2 }) ? e3.leap : e3.regular;
        }
        s2 = this.getMonthCode(n2, i2);
        return { year: n2, month: i2, day: l2, era: void 0, eraYear: a2, monthCode: s2 };
      }
      if (this.validateCalendarDate(e2), void 0 === i2)
        if (s2.endsWith("L")) {
          if ("M05L" !== s2)
            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${s2}`);
          if (i2 = 6, !this.inLeapYear({ year: n2 })) {
            if ("reject" === r2)
              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${n2} which is not a leap year`);
            i2 = 5, l2 = 30, s2 = "M05";
          }
        } else {
          i2 = monthCodeNumberPart(s2), this.inLeapYear({ year: n2 }) && i2 >= 6 && i2++;
          const e3 = this.monthsInYear({ year: n2 });
          if (i2 < 1 || i2 > e3)
            throw new RangeError(`Invalid monthCode: ${s2}`);
        }
      else if ("reject" === r2 ? (RejectToRange(i2, 1, this.monthsInYear({ year: n2 })), RejectToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))) : (i2 = ConstrainToRange(i2, 1, this.monthsInYear({ year: n2 })), l2 = ConstrainToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))), void 0 === s2)
        s2 = this.getMonthCode(n2, i2);
      else {
        if (this.getMonthCode(n2, i2) !== s2)
          throw new RangeError(`monthCode ${s2} doesn't correspond to month ${i2} in Hebrew year ${n2}`);
      }
      return { ...e2, day: l2, month: i2, monthCode: s2, year: n2, eraYear: a2 };
    }
  };
  var IslamicBaseHelper = class extends HelperBase {
    constructor() {
      super(...arguments), this.calendarType = "lunar", this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, this.DAYS_PER_ISO_YEAR = 365.2425, this.constantEra = "ah";
    }
    inLeapYear(e2, t2) {
      return 30 === this.daysInMonth({ year: e2.year, month: 12, day: 1 }, t2);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength() {
      return 29;
    }
    maximumMonthLength() {
      return 30;
    }
    estimateIsoDate(e2) {
      const { year: t2 } = this.adjustCalendarDate(e2);
      return { year: mt(t2 * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };
    }
  };
  var IslamicHelper = class extends IslamicBaseHelper {
    constructor() {
      super(...arguments), this.id = "islamic";
    }
  };
  var IslamicUmalquraHelper = class extends IslamicBaseHelper {
    constructor() {
      super(...arguments), this.id = "islamic-umalqura";
    }
  };
  var IslamicTblaHelper = class extends IslamicBaseHelper {
    constructor() {
      super(...arguments), this.id = "islamic-tbla";
    }
  };
  var IslamicCivilHelper = class extends IslamicBaseHelper {
    constructor() {
      super(...arguments), this.id = "islamic-civil";
    }
  };
  var IslamicRgsaHelper = class extends IslamicBaseHelper {
    constructor() {
      super(...arguments), this.id = "islamic-rgsa";
    }
  };
  var IslamicCcHelper = class extends IslamicBaseHelper {
    constructor() {
      super(...arguments), this.id = "islamicc";
    }
  };
  var PersianHelper = class extends HelperBase {
    constructor() {
      super(...arguments), this.id = "persian", this.calendarType = "solar", this.constantEra = "ap";
    }
    inLeapYear(e2, t2) {
      return IslamicHelper.prototype.inLeapYear.call(this, e2, t2);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength(e2) {
      const { month: t2 } = e2;
      return 12 === t2 ? 29 : t2 <= 6 ? 31 : 30;
    }
    maximumMonthLength(e2) {
      const { month: t2 } = e2;
      return 12 === t2 ? 30 : t2 <= 6 ? 31 : 30;
    }
    estimateIsoDate(e2) {
      const { year: t2 } = this.adjustCalendarDate(e2);
      return { year: t2 + 621, month: 1, day: 1 };
    }
  };
  var IndianHelper = class extends HelperBase {
    constructor() {
      super(...arguments), this.id = "indian", this.calendarType = "solar", this.constantEra = "saka", this.months = { 1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } }, 2: { length: 31, month: 4, day: 21 }, 3: { length: 31, month: 5, day: 22 }, 4: { length: 31, month: 6, day: 22 }, 5: { length: 31, month: 7, day: 23 }, 6: { length: 31, month: 8, day: 23 }, 7: { length: 30, month: 9, day: 23 }, 8: { length: 30, month: 10, day: 23 }, 9: { length: 30, month: 11, day: 22 }, 10: { length: 30, month: 12, day: 22 }, 11: { length: 30, month: 1, nextYear: true, day: 21 }, 12: { length: 30, month: 2, nextYear: true, day: 20 } }, this.vulnerableToBceBug = "10/11/-79 Saka" !== new Date("0000-01-01T00:00Z").toLocaleDateString("en-US-u-ca-indian", { timeZone: "UTC" });
    }
    inLeapYear(e2) {
      return isGregorianLeapYear(e2.year + 78);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength(e2) {
      return this.getMonthInfo(e2).length;
    }
    maximumMonthLength(e2) {
      return this.getMonthInfo(e2).length;
    }
    getMonthInfo(e2) {
      const { month: t2 } = e2;
      let r2 = this.months[t2];
      if (void 0 === r2)
        throw new RangeError(`Invalid month: ${t2}`);
      return this.inLeapYear(e2) && r2.leap && (r2 = r2.leap), r2;
    }
    estimateIsoDate(e2) {
      const t2 = this.adjustCalendarDate(e2), r2 = this.getMonthInfo(t2);
      return AddISODate(t2.year + 78 + (r2.nextYear ? 1 : 0), r2.month, r2.day, 0, 0, 0, t2.day - 1, "constrain");
    }
    checkIcuBugs(e2) {
      if (this.vulnerableToBceBug && e2.year < 1)
        throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
    }
  };
  function isGregorianLeapYear(e2) {
    return e2 % 4 == 0 && (e2 % 100 != 0 || e2 % 400 == 0);
  }
  var GregorianBaseHelper = class extends HelperBase {
    constructor(e2, t2) {
      super(), this.calendarType = "solar", this.v8IsVulnerableToJulianBug = new Date("+001001-01-01T00:00Z").toLocaleDateString("en-US-u-ca-japanese", { timeZone: "UTC" }).startsWith("12"), this.calendarIsVulnerableToJulianBug = false, this.id = e2;
      const { eras: r2, anchorEra: o2 } = function adjustEras(e3) {
        let t3, r3 = e3;
        if (0 === r3.length)
          throw new RangeError("Invalid era data: eras are required");
        if (1 === r3.length && r3[0].reverseOf)
          throw new RangeError("Invalid era data: anchor era cannot count years backwards");
        if (1 === r3.length && !r3[0].name)
          throw new RangeError("Invalid era data: at least one named era is required");
        if (r3.filter((e4) => null != e4.reverseOf).length > 1)
          throw new RangeError("Invalid era data: only one era can count years backwards");
        r3.forEach((e4) => {
          if (e4.isAnchor || !e4.anchorEpoch && !e4.reverseOf) {
            if (t3)
              throw new RangeError("Invalid era data: cannot have multiple anchor eras");
            t3 = e4, e4.anchorEpoch = { year: e4.hasYearZero ? 0 : 1 };
          } else if (!e4.name)
            throw new RangeError("If era name is blank, it must be the anchor era");
        }), r3 = r3.filter((e4) => e4.name), r3.forEach((e4) => {
          const { reverseOf: t4 } = e4;
          if (t4) {
            const o4 = r3.find((e5) => e5.name === t4);
            if (void 0 === o4)
              throw new RangeError(`Invalid era data: unmatched reverseOf era: ${t4}`);
            e4.reverseOf = o4, e4.anchorEpoch = o4.anchorEpoch, e4.isoEpoch = o4.isoEpoch;
          }
          void 0 === e4.anchorEpoch.month && (e4.anchorEpoch.month = 1), void 0 === e4.anchorEpoch.day && (e4.anchorEpoch.day = 1);
        }), lt.call(r3, (e4, t4) => {
          if (e4.reverseOf)
            return 1;
          if (t4.reverseOf)
            return -1;
          if (!e4.isoEpoch || !t4.isoEpoch)
            throw new RangeError("Invalid era data: missing ISO epoch");
          return t4.isoEpoch.year - e4.isoEpoch.year;
        });
        const o3 = r3[r3.length - 1].reverseOf;
        if (o3 && o3 !== r3[r3.length - 2])
          throw new RangeError("Invalid era data: invalid reverse-sign era");
        return r3.forEach((e4, t4) => {
          e4.genericName = "era" + (r3.length - 1 - t4);
        }), { eras: r3, anchorEra: t3 || r3[0] };
      }(t2);
      this.anchorEra = o2, this.eras = r2;
    }
    inLeapYear(e2) {
      const { year: t2 } = this.estimateIsoDate({ month: 1, day: 1, year: e2.year });
      return isGregorianLeapYear(t2);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength(e2) {
      const { month: t2 } = e2;
      return 2 === t2 ? this.inLeapYear(e2) ? 29 : 28 : [4, 6, 9, 11].indexOf(t2) >= 0 ? 30 : 31;
    }
    maximumMonthLength(e2) {
      return this.minimumMonthLength(e2);
    }
    completeEraYear(e2) {
      const checkField = (t3, r3) => {
        const o3 = e2[t3];
        if (null != o3 && o3 != r3)
          throw new RangeError(`Input ${t3} ${o3} doesn't match calculated value ${r3}`);
      }, eraFromYear = (t3) => {
        let r3;
        const o3 = { ...e2, year: t3 }, n2 = this.eras.find((e3, n3) => {
          if (n3 === this.eras.length - 1) {
            if (e3.reverseOf) {
              if (t3 > 0)
                throw new RangeError(`Signed year ${t3} is invalid for era ${e3.name}`);
              return r3 = e3.anchorEpoch.year - t3, true;
            }
            return r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true;
          }
          return this.compareCalendarDates(o3, e3.anchorEpoch) >= 0 && (r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true);
        });
        if (!n2)
          throw new RangeError(`Year ${t3} was not matched by any era`);
        return { eraYear: r3, era: n2.name };
      };
      let { year: t2, eraYear: r2, era: o2 } = e2;
      if (null != t2)
        ({ eraYear: r2, era: o2 } = eraFromYear(t2)), checkField("era", o2), checkField("eraYear", r2);
      else {
        if (null == r2)
          throw new RangeError("Either `year` or `eraYear` and `era` are required");
        {
          const e3 = void 0 === o2 ? void 0 : this.eras.find((e4) => e4.name === o2 || e4.genericName === o2);
          if (!e3)
            throw new RangeError(`Era ${o2} (ISO year ${r2}) was not matched by any era`);
          if (r2 < 1 && e3.reverseOf)
            throw new RangeError(`Years in ${o2} era must be positive, not ${t2}`);
          t2 = e3.reverseOf ? e3.anchorEpoch.year - r2 : r2 + e3.anchorEpoch.year - (e3.hasYearZero ? 0 : 1), checkField("year", t2), { eraYear: r2, era: o2 } = eraFromYear(t2);
        }
      }
      return { ...e2, year: t2, eraYear: r2, era: o2 };
    }
    adjustCalendarDate(e2, t2, r2 = "constrain") {
      let o2 = e2;
      const { month: n2, monthCode: a2 } = o2;
      return void 0 === n2 && (o2 = { ...o2, month: monthCodeNumberPart(a2) }), this.validateCalendarDate(o2), o2 = this.completeEraYear(o2), super.adjustCalendarDate(o2, t2, r2);
    }
    estimateIsoDate(e2) {
      const t2 = this.adjustCalendarDate(e2), { year: r2, month: o2, day: n2 } = t2, { anchorEra: a2 } = this;
      return RegulateISODate(r2 + a2.isoEpoch.year - (a2.hasYearZero ? 0 : 1), o2, n2, "constrain");
    }
    checkIcuBugs(e2) {
      if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
        if (CompareISODate(e2.year, e2.month, e2.day, 1582, 10, 15) < 0)
          throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
      }
    }
  };
  var OrthodoxBaseHelper = class extends GregorianBaseHelper {
    constructor(e2, t2) {
      super(e2, t2);
    }
    inLeapYear(e2) {
      const { year: t2 } = e2;
      return (t2 + 1) % 4 == 0;
    }
    monthsInYear() {
      return 13;
    }
    minimumMonthLength(e2) {
      const { month: t2 } = e2;
      return 13 === t2 ? this.inLeapYear(e2) ? 6 : 5 : 30;
    }
    maximumMonthLength(e2) {
      return this.minimumMonthLength(e2);
    }
  };
  var EthioaaHelper = class extends OrthodoxBaseHelper {
    constructor() {
      super("ethioaa", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }]);
    }
  };
  var CopticHelper = class extends OrthodoxBaseHelper {
    constructor() {
      super("coptic", [{ name: "era1", isoEpoch: { year: 284, month: 8, day: 29 } }, { name: "era0", reverseOf: "era1" }]);
    }
  };
  var EthiopicHelper = class extends OrthodoxBaseHelper {
    constructor() {
      super("ethiopic", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }, { name: "era1", isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }]);
    }
  };
  var RocHelper = class extends GregorianBaseHelper {
    constructor() {
      super("roc", [{ name: "minguo", isoEpoch: { year: 1912, month: 1, day: 1 } }, { name: "before-roc", reverseOf: "minguo" }]), this.calendarIsVulnerableToJulianBug = true;
    }
  };
  var BuddhistHelper = class extends GregorianBaseHelper {
    constructor() {
      super("buddhist", [{ name: "be", hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]), this.calendarIsVulnerableToJulianBug = true;
    }
  };
  var GregoryHelper = class extends GregorianBaseHelper {
    constructor() {
      super("gregory", [{ name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]);
    }
    reviseIntlEra(e2) {
      let { era: t2, eraYear: r2 } = e2;
      return "bc" !== t2 && "b" !== t2 || (t2 = "bce"), "ad" !== t2 && "a" !== t2 || (t2 = "ce"), { era: t2, eraYear: r2 };
    }
  };
  var JapaneseHelper = class extends GregorianBaseHelper {
    constructor() {
      super("japanese", [{ name: "reiwa", isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } }, { name: "heisei", isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } }, { name: "showa", isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } }, { name: "taisho", isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } }, { name: "meiji", isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } }, { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]), this.calendarIsVulnerableToJulianBug = true, this.eraLength = "long";
    }
    reviseIntlEra(e2, t2) {
      const { era: r2, eraYear: o2 } = e2, { year: n2 } = t2;
      return this.eras.find((e3) => e3.name === r2) ? { era: r2, eraYear: o2 } : n2 < 1 ? { era: "bce", eraYear: 1 - n2 } : { era: "ce", eraYear: n2 };
    }
  };
  var ChineseBaseHelper = class extends HelperBase {
    constructor() {
      super(...arguments), this.calendarType = "lunisolar", this.hasEra = false;
    }
    inLeapYear(e2, t2) {
      const r2 = this.getMonthList(e2.year, t2);
      return 13 === ct(r2).length;
    }
    monthsInYear(e2, t2) {
      return this.inLeapYear(e2, t2) ? 13 : 12;
    }
    minimumMonthLength() {
      return 29;
    }
    maximumMonthLength() {
      return 30;
    }
    getMonthList(e2, t2) {
      if (void 0 === e2)
        throw new TypeError("Missing year");
      const r2 = JSON.stringify({ func: "getMonthList", calendarYear: e2, id: this.id }), o2 = t2.get(r2);
      if (o2)
        return o2;
      const n2 = this.getFormatter(), getCalendarDate = (e3, t3) => {
        const r3 = toUtcIsoDateString({ isoYear: e3, isoMonth: 2, isoDay: 1 }), o3 = new Date(r3);
        o3.setUTCDate(t3 + 1);
        const a3 = n2.formatToParts(o3), i3 = a3.find((e4) => "month" === e4.type).value, s3 = +a3.find((e4) => "day" === e4.type).value;
        let l3 = a3.find((e4) => "relatedYear" === e4.type);
        if (void 0 === l3)
          throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
        return l3 = +l3.value, { calendarMonthString: i3, calendarDay: s3, calendarYearToVerify: l3 };
      };
      let a2 = 17, { calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2);
      "1" !== i2 && (a2 += 29, { calendarMonthString: i2, calendarDay: s2 } = getCalendarDate(e2, a2)), a2 -= s2 - 5;
      const d2 = {};
      let m2, c2, h2 = 1, u2 = false;
      do {
        ({ calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2)), m2 && (d2[c2].daysInMonth = m2 + 30 - s2), l2 !== e2 ? u2 = true : (d2[i2] = { monthIndex: h2++ }, a2 += 30), m2 = s2, c2 = i2;
      } while (!u2);
      return d2[c2].daysInMonth = m2 + 30 - s2, t2.set(r2, d2), d2;
    }
    estimateIsoDate(e2) {
      const { year: t2, month: r2 } = e2;
      return { year: t2, month: r2 >= 12 ? 12 : r2 + 1, day: 1 };
    }
    adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
      let { year: n2, month: a2, monthExtra: i2, day: s2, monthCode: l2, eraYear: d2 } = e2;
      if (o2) {
        if (n2 = d2, i2 && "bis" !== i2)
          throw new RangeError(`Unexpected leap month suffix: ${i2}`);
        const e3 = buildMonthCode(a2, void 0 !== i2), r3 = `${a2}${i2 || ""}`, o3 = this.getMonthList(n2, t2)[r3];
        if (void 0 === o3)
          throw new RangeError(`Unmatched month ${r3} in Chinese year ${n2}`);
        return a2 = o3.monthIndex, { year: n2, month: a2, day: s2, era: void 0, eraYear: d2, monthCode: e3 };
      }
      if (this.validateCalendarDate(e2), void 0 === n2 && (n2 = d2), void 0 === d2 && (d2 = n2), void 0 === a2) {
        const e3 = this.getMonthList(n2, t2);
        let o3 = l2.replace("L", "bis").slice(1);
        "0" === o3[0] && (o3 = o3.slice(1));
        let i3 = e3[o3];
        if (a2 = i3 && i3.monthIndex, void 0 === a2 && l2.endsWith("L") && !at.call(["M01L", "M12L", "M13L"], l2) && "constrain" === r2) {
          let t3 = l2.slice(1, -1);
          "0" === t3[0] && (t3 = t3.slice(1)), i3 = e3[t3], i3 && ({ daysInMonth: s2, monthIndex: a2 } = i3, l2 = buildMonthCode(t3));
        }
        if (void 0 === a2)
          throw new RangeError(`Unmatched month ${l2} in Chinese year ${n2}`);
      } else if (void 0 === l2) {
        const e3 = this.getMonthList(n2, t2), o3 = ct(e3), i3 = o3.length;
        "reject" === r2 ? (RejectToRange(a2, 1, i3), RejectToRange(s2, 1, this.maximumMonthLength())) : (a2 = ConstrainToRange(a2, 1, i3), s2 = ConstrainToRange(s2, 1, this.maximumMonthLength()));
        const d3 = o3.find(([, e4]) => e4.monthIndex === a2);
        if (void 0 === d3)
          throw new RangeError(`Invalid month ${a2} in Chinese year ${n2}`);
        l2 = buildMonthCode(d3[0].replace("bis", ""), -1 !== d3[0].indexOf("bis"));
      } else {
        const e3 = this.getMonthList(n2, t2);
        let r3 = l2.replace("L", "bis").slice(1);
        "0" === r3[0] && (r3 = r3.slice(1));
        const o3 = e3[r3];
        if (!o3)
          throw new RangeError(`Unmatched monthCode ${l2} in Chinese year ${n2}`);
        if (a2 !== o3.monthIndex)
          throw new RangeError(`monthCode ${l2} doesn't correspond to month ${a2} in Chinese year ${n2}`);
      }
      return { ...e2, year: n2, eraYear: d2, month: a2, monthCode: l2, day: s2 };
    }
  };
  var ChineseHelper = class extends ChineseBaseHelper {
    constructor() {
      super(...arguments), this.id = "chinese";
    }
  };
  var DangiHelper = class extends ChineseBaseHelper {
    constructor() {
      super(...arguments), this.id = "dangi";
    }
  };
  var Tt = { helper: void 0, dateFromFields(e2, t2, r2) {
    const o2 = ToTemporalOverflow(t2), n2 = new OneObjectCache(), a2 = PrepareTemporalFields(e2, ["day", "era", "eraYear", "month", "monthCode", "year"], ["day"]), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate(a2, o2, n2), d2 = CreateTemporalDate(i2, s2, l2, r2);
    return n2.setObject(d2), d2;
  }, yearMonthFromFields(e2, t2, r2) {
    const o2 = ToTemporalOverflow(t2), n2 = new OneObjectCache(), a2 = PrepareTemporalFields(e2, ["era", "eraYear", "month", "monthCode", "year"], []), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate({ ...a2, day: 1 }, o2, n2), d2 = CreateTemporalYearMonth(i2, s2, r2, l2);
    return n2.setObject(d2), d2;
  }, monthDayFromFields(e2, t2, r2) {
    const o2 = ToTemporalOverflow(t2), n2 = new OneObjectCache(), a2 = PrepareTemporalFields(e2, ["day", "era", "eraYear", "month", "monthCode", "year"], ["day"]), { year: i2, month: s2, day: l2 } = this.helper.monthDayFromFields(a2, o2, n2), d2 = CreateTemporalMonthDay(s2, l2, r2, i2);
    return n2.setObject(d2), d2;
  }, fields(e2) {
    let t2 = e2;
    return at.call(t2, "year") && (t2 = [...t2, "era", "eraYear"]), t2;
  }, mergeFields(e2, t2) {
    const r2 = { ...e2 }, o2 = { ...t2 }, { month: n2, monthCode: a2, year: i2, era: s2, eraYear: l2, ...d2 } = r2, { month: m2, monthCode: c2, year: h2, era: u2, eraYear: T2 } = o2;
    return void 0 === m2 && void 0 === c2 && (d2.month = n2, d2.monthCode = a2), void 0 === h2 && void 0 === u2 && void 0 === T2 && (d2.year = i2), { ...d2, ...o2 };
  }, dateAdd(e2, t2, r2, o2, n2, a2, i2) {
    const s2 = OneObjectCache.getCacheForObject(e2), l2 = this.helper.temporalToCalendarDate(e2, s2), d2 = this.helper.addCalendar(l2, { years: t2, months: r2, weeks: o2, days: n2 }, a2, s2), m2 = this.helper.calendarToIsoDate(d2, "constrain", s2), { year: c2, month: h2, day: u2 } = m2, T2 = CreateTemporalDate(c2, h2, u2, i2);
    return new OneObjectCache(s2).setObject(T2), T2;
  }, dateUntil(e2, t2, r2) {
    const o2 = OneObjectCache.getCacheForObject(e2), n2 = OneObjectCache.getCacheForObject(t2), a2 = this.helper.temporalToCalendarDate(e2, o2), i2 = this.helper.temporalToCalendarDate(t2, n2);
    return this.helper.untilCalendar(a2, i2, r2, o2);
  }, year(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).year;
  }, month(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).month;
  }, day(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).day;
  }, era(e2) {
    if (!this.helper.hasEra)
      return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).era;
  }, eraYear(e2) {
    if (!this.helper.hasEra)
      return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).eraYear;
  }, monthCode(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).monthCode;
  }, dayOfWeek: (e2) => ut.iso8601.dayOfWeek(e2), dayOfYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.isoToCalendarDate(e2, t2), o2 = this.helper.startOfCalendarYear(r2);
    return this.helper.calendarDaysUntil(o2, r2, t2) + 1;
  }, weekOfYear: (e2) => ut.iso8601.weekOfYear(e2), daysInWeek: (e2) => ut.iso8601.daysInWeek(e2), daysInMonth(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2), o2 = this.helper.maximumMonthLength(r2);
    if (o2 === this.helper.minimumMonthLength(r2))
      return o2;
    const n2 = this.helper.startOfCalendarMonth(r2), a2 = this.helper.addMonthsCalendar(n2, 1, "constrain", t2);
    return this.helper.calendarDaysUntil(n2, a2, t2);
  }, daysInYear(e2) {
    let t2 = e2;
    HasSlot(t2, n) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2), a2 = this.helper.startOfCalendarYear(o2), i2 = this.helper.addCalendar(a2, { years: 1 }, "constrain", r2);
    return this.helper.calendarDaysUntil(a2, i2, r2);
  }, monthsInYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2);
    return this.helper.monthsInYear(r2, t2);
  }, inLeapYear(e2) {
    let t2 = e2;
    HasSlot(t2, n) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2);
    return this.helper.inLeapYear(o2, r2);
  } };
  for (const e2 of [HebrewHelper, PersianHelper, EthiopicHelper, EthioaaHelper, CopticHelper, ChineseHelper, DangiHelper, RocHelper, IndianHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper]) {
    const t2 = new e2();
    ut[t2.id] = { ...Tt, helper: t2 };
  }
  var PlainDate = class {
    constructor(e2, t2, r2, o2 = GetISO8601Calendar()) {
      const n2 = ToIntegerThrowOnInfinity(e2), a2 = ToIntegerThrowOnInfinity(t2), i2 = ToIntegerThrowOnInfinity(r2), s2 = ToTemporalCalendar(o2);
      if (arguments.length < 3)
        throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");
      CreateTemporalDateSlots(this, n2, a2, i2, s2);
    }
    get calendar() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, u);
    }
    get era() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarEra(GetSlot(this, u), this);
    }
    get eraYear() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarEraYear(GetSlot(this, u), this);
    }
    get year() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarYear(GetSlot(this, u), this);
    }
    get month() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarMonth(GetSlot(this, u), this);
    }
    get monthCode() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthCode(GetSlot(this, u), this);
    }
    get day() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarDay(GetSlot(this, u), this);
    }
    get dayOfWeek() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarDayOfWeek(GetSlot(this, u), this);
    }
    get dayOfYear() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarDayOfYear(GetSlot(this, u), this);
    }
    get weekOfYear() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarWeekOfYear(GetSlot(this, u), this);
    }
    get daysInWeek() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInWeek(GetSlot(this, u), this);
    }
    get daysInMonth() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInMonth(GetSlot(this, u), this);
    }
    get daysInYear() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInYear(GetSlot(this, u), this);
    }
    get monthsInYear() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthsInYear(GetSlot(this, u), this);
    }
    get inLeapYear() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return CalendarInLeapYear(GetSlot(this, u), this);
    }
    with(e2, t2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid argument");
      RejectObjectWithCalendarOrTimeZone(e2);
      const r2 = GetSlot(this, u), o2 = CalendarFields(r2, ["day", "month", "monthCode", "year"]), n2 = PrepareTemporalFields(e2, o2, "partial");
      if (!n2)
        throw new TypeError("invalid date-like");
      let a2 = PrepareTemporalFields(this, o2, []);
      a2 = CalendarMergeFields(r2, a2, n2), a2 = PrepareTemporalFields(a2, o2, []);
      return CalendarDateFromFields(r2, a2, GetOptionsObject(t2));
    }
    withCalendar(e2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalCalendar(e2);
      return new PlainDate(GetSlot(this, n), GetSlot(this, a), GetSlot(this, i), t2);
    }
    add(e2, t2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      const r2 = ToTemporalDuration(e2), o2 = GetOptionsObject(t2);
      return CalendarDateAdd(GetSlot(this, u), this, r2, o2);
    }
    subtract(e2, t2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      const r2 = CreateNegatedTemporalDuration(ToTemporalDuration(e2)), o2 = GetOptionsObject(t2);
      return CalendarDateAdd(GetSlot(this, u), this, r2, o2);
    }
    until(e2, t2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainDate("until", this, e2, t2);
    }
    since(e2, t2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainDate("since", this, e2, t2);
    }
    equals(e2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2);
      for (const e3 of [n, a, i]) {
        if (GetSlot(this, e3) !== GetSlot(t2, e3))
          return false;
      }
      return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
    }
    toString(e2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return TemporalDateToString(this, ToShowCalendarOption(GetOptionsObject(e2)));
    }
    toJSON() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return TemporalDateToString(this);
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return new ot(e2, t2).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
    }
    toPlainDateTime(e2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      const t2 = GetSlot(this, n), r2 = GetSlot(this, a), o2 = GetSlot(this, i), T2 = GetSlot(this, u);
      if (void 0 === e2)
        return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, T2);
      const p2 = ToTemporalTime(e2);
      return CreateTemporalDateTime(t2, r2, o2, GetSlot(p2, s), GetSlot(p2, l), GetSlot(p2, d), GetSlot(p2, m), GetSlot(p2, c), GetSlot(p2, h), T2);
    }
    toZonedDateTime(e2) {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      let t2, o2;
      if (IsObject(e2)) {
        const r2 = e2.timeZone;
        void 0 === r2 ? t2 = ToTemporalTimeZone(e2) : (t2 = ToTemporalTimeZone(r2), o2 = e2.plainTime);
      } else
        t2 = ToTemporalTimeZone(e2);
      const T2 = GetSlot(this, n), p2 = GetSlot(this, a), f2 = GetSlot(this, i), y2 = GetSlot(this, u);
      let S2 = 0, w2 = 0, g2 = 0, I2 = 0, D2 = 0, G2 = 0;
      void 0 !== o2 && (o2 = ToTemporalTime(o2), S2 = GetSlot(o2, s), w2 = GetSlot(o2, l), g2 = GetSlot(o2, d), I2 = GetSlot(o2, m), D2 = GetSlot(o2, c), G2 = GetSlot(o2, h));
      return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(t2, CreateTemporalDateTime(T2, p2, f2, S2, w2, g2, I2, D2, G2, y2), "compatible"), r), t2, y2);
    }
    toPlainYearMonth() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      const e2 = GetSlot(this, u);
      return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
    }
    toPlainMonthDay() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      const e2 = GetSlot(this, u);
      return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
    }
    getISOFields() {
      if (!IsTemporalDate(this))
        throw new TypeError("invalid receiver");
      return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoMonth: GetSlot(this, a), isoYear: GetSlot(this, n) };
    }
    static from(e2, t2) {
      const r2 = GetOptionsObject(t2);
      return IsTemporalDate(e2) ? (ToTemporalOverflow(r2), CreateTemporalDate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, u))) : ToTemporalDate(e2, r2);
    }
    static compare(e2, t2) {
      const r2 = ToTemporalDate(e2), o2 = ToTemporalDate(t2);
      return CompareISODate(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(o2, n), GetSlot(o2, a), GetSlot(o2, i));
    }
  };
  MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
  var PlainDateTime = class {
    constructor(e2, t2, r2, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = GetISO8601Calendar()) {
      const m2 = ToIntegerThrowOnInfinity(e2), c2 = ToIntegerThrowOnInfinity(t2), h2 = ToIntegerThrowOnInfinity(r2), u2 = ToIntegerThrowOnInfinity(o2), T2 = ToIntegerThrowOnInfinity(n2), p2 = ToIntegerThrowOnInfinity(a2), f2 = ToIntegerThrowOnInfinity(i2), y2 = ToIntegerThrowOnInfinity(s2), S2 = ToIntegerThrowOnInfinity(l2), w2 = ToTemporalCalendar(d2);
      if (arguments.length < 3)
        throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");
      CreateTemporalDateTimeSlots(this, m2, c2, h2, u2, T2, p2, f2, y2, S2, w2);
    }
    get calendar() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, u);
    }
    get year() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarYear(GetSlot(this, u), this);
    }
    get month() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarMonth(GetSlot(this, u), this);
    }
    get monthCode() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthCode(GetSlot(this, u), this);
    }
    get day() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDay(GetSlot(this, u), this);
    }
    get hour() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, s);
    }
    get minute() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, l);
    }
    get second() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, d);
    }
    get millisecond() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, m);
    }
    get microsecond() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, c);
    }
    get nanosecond() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, h);
    }
    get era() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarEra(GetSlot(this, u), this);
    }
    get eraYear() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarEraYear(GetSlot(this, u), this);
    }
    get dayOfWeek() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDayOfWeek(GetSlot(this, u), this);
    }
    get dayOfYear() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDayOfYear(GetSlot(this, u), this);
    }
    get weekOfYear() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarWeekOfYear(GetSlot(this, u), this);
    }
    get daysInWeek() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInWeek(GetSlot(this, u), this);
    }
    get daysInYear() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInYear(GetSlot(this, u), this);
    }
    get daysInMonth() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInMonth(GetSlot(this, u), this);
    }
    get monthsInYear() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthsInYear(GetSlot(this, u), this);
    }
    get inLeapYear() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarInLeapYear(GetSlot(this, u), this);
    }
    with(e2, t2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid argument");
      RejectObjectWithCalendarOrTimeZone(e2);
      const r2 = GetOptionsObject(t2), o2 = GetSlot(this, u), n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), a2 = PrepareTemporalFields(e2, n2, "partial");
      if (!a2)
        throw new TypeError("invalid date-time-like");
      let i2 = PrepareTemporalFields(this, n2, []);
      i2 = CalendarMergeFields(o2, i2, a2), i2 = PrepareTemporalFields(i2, n2, []);
      const { year: s2, month: l2, day: d2, hour: m2, minute: c2, second: h2, millisecond: T2, microsecond: p2, nanosecond: f2 } = InterpretTemporalDateTimeFields(o2, i2, r2);
      return CreateTemporalDateTime(s2, l2, d2, m2, c2, h2, T2, p2, f2, o2);
    }
    withPlainTime(e2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetSlot(this, n), r2 = GetSlot(this, a), o2 = GetSlot(this, i), T2 = GetSlot(this, u);
      if (void 0 === e2)
        return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, T2);
      const p2 = ToTemporalTime(e2);
      return CreateTemporalDateTime(t2, r2, o2, GetSlot(p2, s), GetSlot(p2, l), GetSlot(p2, d), GetSlot(p2, m), GetSlot(p2, c), GetSlot(p2, h), T2);
    }
    withPlainDate(e2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, n), o2 = GetSlot(t2, a), T2 = GetSlot(t2, i);
      let p2 = GetSlot(t2, u);
      const f2 = GetSlot(this, s), y2 = GetSlot(this, l), S2 = GetSlot(this, d), w2 = GetSlot(this, m), g2 = GetSlot(this, c), I2 = GetSlot(this, h);
      return p2 = ConsolidateCalendars(GetSlot(this, u), p2), CreateTemporalDateTime(r2, o2, T2, f2, y2, S2, w2, g2, I2, p2);
    }
    withCalendar(e2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalCalendar(e2);
      return new PlainDateTime(GetSlot(this, n), GetSlot(this, a), GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), t2);
    }
    add(e2, t2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromPlainDateTime("add", this, e2, t2);
    }
    subtract(e2, t2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromPlainDateTime("subtract", this, e2, t2);
    }
    until(e2, t2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainDateTime("until", this, e2, t2);
    }
    since(e2, t2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainDateTime("since", this, e2, t2);
    }
    round(e2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e2)
        throw new TypeError("options parameter is required");
      const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = GetTemporalUnit(t2, "smallestUnit", "time", je, ["day"]), o2 = ToTemporalRoundingMode(t2, "halfExpand"), T2 = ToTemporalRoundingIncrement(t2, { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[r2], false);
      let p2 = GetSlot(this, n), f2 = GetSlot(this, a), y2 = GetSlot(this, i), S2 = GetSlot(this, s), w2 = GetSlot(this, l), g2 = GetSlot(this, d), I2 = GetSlot(this, m), D2 = GetSlot(this, c), G2 = GetSlot(this, h);
      return { year: p2, month: f2, day: y2, hour: S2, minute: w2, second: g2, millisecond: I2, microsecond: D2, nanosecond: G2 } = RoundISODateTime(p2, f2, y2, S2, w2, g2, I2, D2, G2, T2, r2, o2), CreateTemporalDateTime(p2, f2, y2, S2, w2, g2, I2, D2, G2, GetSlot(this, u));
    }
    equals(e2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDateTime(e2);
      for (const e3 of [n, a, i, s, l, d, m, c, h]) {
        if (GetSlot(this, e3) !== GetSlot(t2, e3))
          return false;
      }
      return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
    }
    toString(e2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2);
      return TemporalDateTimeToString(this, r2, ToShowCalendarOption(t2), { unit: o2, increment: n2, roundingMode: ToTemporalRoundingMode(t2, "trunc") });
    }
    toJSON() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return TemporalDateTimeToString(this, "auto");
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return new ot(e2, t2).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
    }
    toZonedDateTime(e2, t2) {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const o2 = ToTemporalTimeZone(e2);
      return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(o2, this, ToTemporalDisambiguation(GetOptionsObject(t2))), r), o2, GetSlot(this, u));
    }
    toPlainDate() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return TemporalDateTimeToDate(this);
    }
    toPlainYearMonth() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const e2 = GetSlot(this, u);
      return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
    }
    toPlainMonthDay() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      const e2 = GetSlot(this, u);
      return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
    }
    toPlainTime() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return TemporalDateTimeToTime(this);
    }
    getISOFields() {
      if (!IsTemporalDateTime(this))
        throw new TypeError("invalid receiver");
      return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoHour: GetSlot(this, s), isoMicrosecond: GetSlot(this, c), isoMillisecond: GetSlot(this, m), isoMinute: GetSlot(this, l), isoMonth: GetSlot(this, a), isoNanosecond: GetSlot(this, h), isoSecond: GetSlot(this, d), isoYear: GetSlot(this, n) };
    }
    static from(e2, t2) {
      const r2 = GetOptionsObject(t2);
      return IsTemporalDateTime(e2) ? (ToTemporalOverflow(r2), CreateTemporalDateTime(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u))) : ToTemporalDateTime(e2, r2);
    }
    static compare(e2, t2) {
      const r2 = ToTemporalDateTime(e2), o2 = ToTemporalDateTime(t2);
      for (const e3 of [n, a, i, s, l, d, m, c, h]) {
        const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
        if (t3 !== n2)
          return ComparisonResult(t3 - n2);
      }
      return 0;
    }
  };
  MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
  var Duration = class {
    constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = 0) {
      const m2 = ToIntegerWithoutRounding(e2), c2 = ToIntegerWithoutRounding(t2), h2 = ToIntegerWithoutRounding(r2), u2 = ToIntegerWithoutRounding(o2), T2 = ToIntegerWithoutRounding(n2), p2 = ToIntegerWithoutRounding(a2), C2 = ToIntegerWithoutRounding(i2), E2 = ToIntegerWithoutRounding(s2), b2 = ToIntegerWithoutRounding(l2), M2 = ToIntegerWithoutRounding(d2);
      RejectDuration(m2, c2, h2, u2, T2, p2, C2, E2, b2, M2), CreateSlots(this), SetSlot(this, f, m2), SetSlot(this, y, c2), SetSlot(this, S, h2), SetSlot(this, w, u2), SetSlot(this, g, T2), SetSlot(this, I, p2), SetSlot(this, D, C2), SetSlot(this, G, E2), SetSlot(this, v, b2), SetSlot(this, O, M2);
    }
    get years() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, f);
    }
    get months() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, y);
    }
    get weeks() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, S);
    }
    get days() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, w);
    }
    get hours() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, g);
    }
    get minutes() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, I);
    }
    get seconds() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, D);
    }
    get milliseconds() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, G);
    }
    get microseconds() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, v);
    }
    get nanoseconds() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, O);
    }
    get sign() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return DurationSign(GetSlot(this, f), GetSlot(this, y), GetSlot(this, S), GetSlot(this, w), GetSlot(this, g), GetSlot(this, I), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, O));
    }
    get blank() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return 0 === DurationSign(GetSlot(this, f), GetSlot(this, y), GetSlot(this, S), GetSlot(this, w), GetSlot(this, g), GetSlot(this, I), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, O));
    }
    with(e2) {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      const t2 = PrepareTemporalFields(e2, ["days", "hours", "microseconds", "milliseconds", "minutes", "months", "nanoseconds", "seconds", "weeks", "years"], "partial");
      if (!t2)
        throw new TypeError("invalid duration-like");
      const { years: r2 = GetSlot(this, f), months: o2 = GetSlot(this, y), weeks: n2 = GetSlot(this, S), days: a2 = GetSlot(this, w), hours: i2 = GetSlot(this, g), minutes: s2 = GetSlot(this, I), seconds: l2 = GetSlot(this, D), milliseconds: d2 = GetSlot(this, G), microseconds: m2 = GetSlot(this, v), nanoseconds: c2 = GetSlot(this, O) } = t2;
      return new Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
    }
    negated() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return CreateNegatedTemporalDuration(this);
    }
    abs() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return new Duration(Math.abs(GetSlot(this, f)), Math.abs(GetSlot(this, y)), Math.abs(GetSlot(this, S)), Math.abs(GetSlot(this, w)), Math.abs(GetSlot(this, g)), Math.abs(GetSlot(this, I)), Math.abs(GetSlot(this, D)), Math.abs(GetSlot(this, G)), Math.abs(GetSlot(this, v)), Math.abs(GetSlot(this, O)));
    }
    add(e2, t2) {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromDuration("add", this, e2, t2);
    }
    subtract(e2, t2) {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromDuration("subtract", this, e2, t2);
    }
    round(e2) {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e2)
        throw new TypeError("options parameter is required");
      let t2 = GetSlot(this, f), r2 = GetSlot(this, y), o2 = GetSlot(this, S), n2 = GetSlot(this, w), a2 = GetSlot(this, g), i2 = GetSlot(this, I), s2 = GetSlot(this, D), l2 = GetSlot(this, G), d2 = GetSlot(this, v), m2 = GetSlot(this, O), c2 = DefaultTemporalLargestUnit(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
      const h2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2);
      let T2 = GetTemporalUnit(h2, "smallestUnit", "datetime", void 0), p2 = true;
      T2 || (p2 = false, T2 = "nanosecond"), c2 = LargerOfTwoTemporalUnits(c2, T2);
      let C2 = GetTemporalUnit(h2, "largestUnit", "datetime", void 0, ["auto"]), E2 = true;
      if (C2 || (E2 = false, C2 = c2), "auto" === C2 && (C2 = c2), !p2 && !E2)
        throw new RangeError("at least one of smallestUnit or largestUnit is required");
      if (LargerOfTwoTemporalUnits(C2, T2) !== C2)
        throw new RangeError(`largestUnit ${C2} cannot be smaller than smallestUnit ${T2}`);
      const b2 = ToTemporalRoundingMode(h2, "halfExpand"), M2 = ToTemporalDateTimeRoundingIncrement(h2, T2);
      let R2 = ToRelativeTemporalObject(h2);
      return { years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, C2, R2), { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, M2, T2, b2, R2), { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, M2, T2, b2, R2), { years: t2, months: r2, weeks: o2, days: n2 } = function BalanceDurationRelative(e3, t3, r3, o3, n3, a3) {
        let i3 = e3, s3 = t3, l3 = r3, d3 = o3;
        const m3 = GetIntrinsic("%Temporal.Duration%"), c3 = DurationSign(i3, s3, l3, d3, 0, 0, 0, 0, 0, 0);
        if (0 === c3)
          return { years: i3, months: s3, weeks: l3, days: d3 };
        let h3, T3;
        a3 && (T3 = ToTemporalDate(a3), h3 = GetSlot(T3, u));
        const p3 = new m3(c3), f2 = new m3(0, c3), S2 = new m3(0, 0, c3);
        switch (n3) {
          case "year": {
            if (!h3)
              throw new RangeError("a starting point is required for years balancing");
            let e4, t4, r4;
            for ({ relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, p3); K(d3) >= K(t4); )
              d3 -= t4, i3 += c3, T3 = e4, { relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, p3);
            for ({ relativeTo: e4, days: r4 } = MoveRelativeDate(h3, T3, f2); K(d3) >= K(r4); )
              d3 -= r4, s3 += c3, T3 = e4, { relativeTo: e4, days: r4 } = MoveRelativeDate(h3, T3, f2);
            const o4 = h3.dateAdd;
            e4 = CalendarDateAdd(h3, T3, p3, void 0, o4);
            const n4 = h3.dateUntil, a4 = le(null);
            a4.largestUnit = "month";
            let l4 = CalendarDateUntil(h3, T3, e4, a4, n4), m4 = GetSlot(l4, y);
            for (; K(s3) >= K(m4); ) {
              s3 -= m4, i3 += c3, T3 = e4, e4 = CalendarDateAdd(h3, T3, p3, void 0, o4);
              const t5 = le(null);
              t5.largestUnit = "month", l4 = CalendarDateUntil(h3, T3, e4, t5, n4), m4 = GetSlot(l4, y);
            }
            break;
          }
          case "month": {
            if (!h3)
              throw new RangeError("a starting point is required for months balancing");
            let e4, t4;
            for ({ relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, f2); K(d3) >= K(t4); )
              d3 -= t4, s3 += c3, T3 = e4, { relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, f2);
            break;
          }
          case "week": {
            if (!h3)
              throw new RangeError("a starting point is required for weeks balancing");
            let e4, t4;
            for ({ relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, S2); K(d3) >= K(t4); )
              d3 -= t4, l3 += c3, T3 = e4, { relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, S2);
            break;
          }
        }
        return { years: i3, months: s3, weeks: l3, days: d3 };
      }(t2, r2, o2, n2, C2, R2), IsTemporalZonedDateTime(R2) && (R2 = MoveRelativeZonedDateTime(R2, t2, r2, o2, 0)), { days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = BalanceDuration(n2, a2, i2, s2, l2, d2, m2, C2, R2), new Duration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
    }
    total(e2) {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      let t2 = GetSlot(this, f), r2 = GetSlot(this, y), o2 = GetSlot(this, S), n2 = GetSlot(this, w), a2 = GetSlot(this, g), i2 = GetSlot(this, I), s2 = GetSlot(this, D), l2 = GetSlot(this, G), d2 = GetSlot(this, v), m2 = GetSlot(this, O);
      if (void 0 === e2)
        throw new TypeError("options argument is required");
      const c2 = "string" == typeof e2 ? CreateOnePropObject("unit", e2) : GetOptionsObject(e2), h2 = GetTemporalUnit(c2, "unit", "datetime", je), u2 = ToRelativeTemporalObject(c2);
      let T2;
      ({ years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, h2, u2)), IsTemporalZonedDateTime(u2) && (T2 = MoveRelativeZonedDateTime(u2, t2, r2, o2, 0)), { days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = BalanceDuration(n2, a2, i2, s2, l2, d2, m2, h2, T2);
      const { total: p2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, 1, h2, "trunc", u2);
      return p2;
    }
    toString(e2) {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2);
      if ("minute" === r2)
        throw new RangeError('smallestUnit must not be "minute"');
      return TemporalDurationToString(this, r2, { unit: o2, increment: n2, roundingMode: ToTemporalRoundingMode(t2, "trunc") });
    }
    toJSON() {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return TemporalDurationToString(this);
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalDuration(this))
        throw new TypeError("invalid receiver");
      return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e2, t2).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), TemporalDurationToString(this));
    }
    valueOf() {
      throw new TypeError("use compare() to compare Temporal.Duration");
    }
    static from(e2) {
      return IsTemporalDuration(e2) ? new Duration(GetSlot(e2, f), GetSlot(e2, y), GetSlot(e2, S), GetSlot(e2, w), GetSlot(e2, g), GetSlot(e2, I), GetSlot(e2, D), GetSlot(e2, G), GetSlot(e2, v), GetSlot(e2, O)) : ToTemporalDuration(e2);
    }
    static compare(t2, r2, o2) {
      const n2 = ToTemporalDuration(t2), a2 = ToTemporalDuration(r2), i2 = ToRelativeTemporalObject(GetOptionsObject(o2)), s2 = GetSlot(n2, f), l2 = GetSlot(n2, y), d2 = GetSlot(n2, S);
      let m2 = GetSlot(n2, w);
      const c2 = GetSlot(n2, g), h2 = GetSlot(n2, I), u2 = GetSlot(n2, D), T2 = GetSlot(n2, G), p2 = GetSlot(n2, v);
      let C2 = GetSlot(n2, O);
      const E2 = GetSlot(a2, f), b2 = GetSlot(a2, y), M2 = GetSlot(a2, S);
      let R2 = GetSlot(a2, w);
      const Z2 = GetSlot(a2, g), P2 = GetSlot(a2, I), F2 = GetSlot(a2, D), Y2 = GetSlot(a2, G), j2 = GetSlot(a2, v);
      let $2 = GetSlot(a2, O);
      const B2 = CalculateOffsetShift(i2, s2, l2, d2, m2), N10 = CalculateOffsetShift(i2, E2, b2, M2, R2);
      0 === s2 && 0 === E2 && 0 === l2 && 0 === b2 && 0 === d2 && 0 === M2 || ({ days: m2 } = UnbalanceDurationRelative(s2, l2, d2, m2, "day", i2), { days: R2 } = UnbalanceDurationRelative(E2, b2, M2, R2, "day", i2));
      const k2 = TotalDurationNanoseconds(m2, c2, h2, u2, T2, p2, C2, B2), A2 = TotalDurationNanoseconds(R2, Z2, P2, F2, Y2, j2, $2, N10);
      return ComparisonResult(import_jsbi.default.toNumber(import_jsbi.default.subtract(k2, A2)));
    }
  };
  MakeIntrinsicClass(Duration, "Temporal.Duration");
  var pt = Object.create;
  var PlainMonthDay = class {
    constructor(e2, t2, r2 = GetISO8601Calendar(), o2 = 1972) {
      const n2 = ToIntegerThrowOnInfinity(e2), a2 = ToIntegerThrowOnInfinity(t2), i2 = ToTemporalCalendar(r2), s2 = ToIntegerThrowOnInfinity(o2);
      if (arguments.length < 2)
        throw new RangeError("missing argument: isoMonth and isoDay are required");
      CreateTemporalMonthDaySlots(this, n2, a2, i2, s2);
    }
    get monthCode() {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthCode(GetSlot(this, u), this);
    }
    get day() {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      return CalendarDay(GetSlot(this, u), this);
    }
    get calendar() {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, u);
    }
    with(e2, t2) {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid argument");
      RejectObjectWithCalendarOrTimeZone(e2);
      const r2 = GetSlot(this, u), o2 = CalendarFields(r2, ["day", "month", "monthCode", "year"]), n2 = PrepareTemporalFields(e2, o2, "partial");
      if (!n2)
        throw new TypeError("invalid month-day-like");
      let a2 = PrepareTemporalFields(this, o2, []);
      a2 = CalendarMergeFields(r2, a2, n2), a2 = PrepareTemporalFields(a2, o2, []);
      return CalendarMonthDayFromFields(r2, a2, GetOptionsObject(t2));
    }
    equals(e2) {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalMonthDay(e2);
      for (const e3 of [a, i, n]) {
        if (GetSlot(this, e3) !== GetSlot(t2, e3))
          return false;
      }
      return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
    }
    toString(e2) {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      return TemporalMonthDayToString(this, ToShowCalendarOption(GetOptionsObject(e2)));
    }
    toJSON() {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      return TemporalMonthDayToString(this);
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      return new ot(e2, t2).format(this);
    }
    valueOf() {
      throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
    }
    toPlainDate(e2) {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("argument should be an object");
      const t2 = GetSlot(this, u), r2 = CalendarFields(t2, ["day", "monthCode"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["year"]);
      let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
      a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
      const i2 = pt(null);
      return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
    }
    getISOFields() {
      if (!IsTemporalMonthDay(this))
        throw new TypeError("invalid receiver");
      return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoMonth: GetSlot(this, a), isoYear: GetSlot(this, n) };
    }
    static from(e2, t2) {
      const r2 = GetOptionsObject(t2);
      return IsTemporalMonthDay(e2) ? (ToTemporalOverflow(r2), CreateTemporalMonthDay(GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, u), GetSlot(e2, n))) : ToTemporalMonthDay(e2, r2);
    }
  };
  MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
  var instant = () => new (GetIntrinsic("%Temporal.Instant%"))($e());
  var plainDateTime = (e2, t2 = timeZone()) => {
    const r2 = ToTemporalTimeZone(t2), o2 = ToTemporalCalendar(e2);
    return BuiltinTimeZoneGetPlainDateTimeFor(r2, instant(), o2);
  };
  var plainDateTimeISO = (e2 = timeZone()) => {
    const t2 = ToTemporalTimeZone(e2), r2 = GetISO8601Calendar();
    return BuiltinTimeZoneGetPlainDateTimeFor(t2, instant(), r2);
  };
  var zonedDateTime = (e2, t2 = timeZone()) => {
    const r2 = ToTemporalTimeZone(t2), o2 = ToTemporalCalendar(e2);
    return CreateTemporalZonedDateTime($e(), r2, o2);
  };
  var timeZone = () => function SystemTimeZone() {
    const e2 = new J("en-us");
    return new (GetIntrinsic("%Temporal.TimeZone%"))(ParseTemporalTimeZone(e2.resolvedOptions().timeZone));
  }();
  var ft = { instant, plainDateTime, plainDateTimeISO, plainDate: (e2, t2 = timeZone()) => TemporalDateTimeToDate(plainDateTime(e2, t2)), plainDateISO: (e2 = timeZone()) => TemporalDateTimeToDate(plainDateTimeISO(e2)), plainTimeISO: (e2 = timeZone()) => TemporalDateTimeToTime(plainDateTimeISO(e2)), timeZone, zonedDateTime, zonedDateTimeISO: (e2 = timeZone()) => zonedDateTime(GetISO8601Calendar(), e2), [Symbol.toStringTag]: "Temporal.Now" };
  Object.defineProperty(ft, Symbol.toStringTag, { value: "Temporal.Now", writable: false, enumerable: false, configurable: true });
  var yt = Object.assign;
  function TemporalTimeToString(e2, t2, r2) {
    let o2 = GetSlot(e2, s), n2 = GetSlot(e2, l), a2 = GetSlot(e2, d), i2 = GetSlot(e2, m), u2 = GetSlot(e2, c), T2 = GetSlot(e2, h);
    if (r2) {
      const { unit: e3, increment: t3, roundingMode: s2 } = r2;
      ({ hour: o2, minute: n2, second: a2, millisecond: i2, microsecond: u2, nanosecond: T2 } = RoundTime(o2, n2, a2, i2, u2, T2, t3, e3, s2));
    }
    return `${ISODateTimePartString(o2)}:${ISODateTimePartString(n2)}${FormatSecondsStringPart(a2, i2, u2, T2, t2)}`;
  }
  var PlainTime = class {
    constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0) {
      const i2 = ToIntegerThrowOnInfinity(e2), T2 = ToIntegerThrowOnInfinity(t2), p2 = ToIntegerThrowOnInfinity(r2), f2 = ToIntegerThrowOnInfinity(o2), y2 = ToIntegerThrowOnInfinity(n2), S2 = ToIntegerThrowOnInfinity(a2);
      RejectTime(i2, T2, p2, f2, y2, S2), CreateSlots(this), SetSlot(this, s, i2), SetSlot(this, l, T2), SetSlot(this, d, p2), SetSlot(this, m, f2), SetSlot(this, c, y2), SetSlot(this, h, S2), SetSlot(this, u, GetISO8601Calendar());
    }
    get calendar() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, u);
    }
    get hour() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, s);
    }
    get minute() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, l);
    }
    get second() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, d);
    }
    get millisecond() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, m);
    }
    get microsecond() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, c);
    }
    get nanosecond() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, h);
    }
    with(e2, t2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid argument");
      RejectObjectWithCalendarOrTimeZone(e2);
      const r2 = ToTemporalTimeRecord(e2, "partial"), o2 = ToTemporalOverflow(GetOptionsObject(t2)), n2 = ToTemporalTimeRecord(this);
      let { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = yt(n2, r2);
      return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = RegulateTime(a2, i2, s2, l2, d2, m2, o2), new PlainTime(a2, i2, s2, l2, d2, m2);
    }
    add(e2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromPlainTime("add", this, e2);
    }
    subtract(e2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromPlainTime("subtract", this, e2);
    }
    until(e2, t2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainTime("until", this, e2, t2);
    }
    since(e2, t2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainTime("since", this, e2, t2);
    }
    round(e2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e2)
        throw new TypeError("options parameter is required");
      const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = GetTemporalUnit(t2, "smallestUnit", "time", je), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = ToTemporalRoundingIncrement(t2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[r2], false);
      let a2 = GetSlot(this, s), i2 = GetSlot(this, l), u2 = GetSlot(this, d), T2 = GetSlot(this, m), p2 = GetSlot(this, c), f2 = GetSlot(this, h);
      return { hour: a2, minute: i2, second: u2, millisecond: T2, microsecond: p2, nanosecond: f2 } = RoundTime(a2, i2, u2, T2, p2, f2, n2, r2, o2), new PlainTime(a2, i2, u2, T2, p2, f2);
    }
    equals(e2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalTime(e2);
      for (const e3 of [s, l, d, m, c, h]) {
        if (GetSlot(this, e3) !== GetSlot(t2, e3))
          return false;
      }
      return true;
    }
    toString(e2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2);
      return TemporalTimeToString(this, r2, { unit: o2, increment: n2, roundingMode: ToTemporalRoundingMode(t2, "trunc") });
    }
    toJSON() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return TemporalTimeToString(this, "auto");
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return new ot(e2, t2).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
    }
    toPlainDateTime(e2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, n), o2 = GetSlot(t2, a), T2 = GetSlot(t2, i), p2 = GetSlot(t2, u);
      return CreateTemporalDateTime(r2, o2, T2, GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), p2);
    }
    toZonedDateTime(e2) {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid argument");
      const t2 = e2.plainDate;
      if (void 0 === t2)
        throw new TypeError("missing date property");
      const o2 = ToTemporalDate(t2), T2 = e2.timeZone;
      if (void 0 === T2)
        throw new TypeError("missing timeZone property");
      const p2 = ToTemporalTimeZone(T2), f2 = GetSlot(o2, n), y2 = GetSlot(o2, a), S2 = GetSlot(o2, i), w2 = GetSlot(o2, u), g2 = GetSlot(this, s), I2 = GetSlot(this, l), D2 = GetSlot(this, d), G2 = GetSlot(this, m), v2 = GetSlot(this, c), O2 = GetSlot(this, h);
      return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(p2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, S2, g2, I2, D2, G2, v2, O2, w2), "compatible"), r), p2, w2);
    }
    getISOFields() {
      if (!IsTemporalTime(this))
        throw new TypeError("invalid receiver");
      return { calendar: GetSlot(this, u), isoHour: GetSlot(this, s), isoMicrosecond: GetSlot(this, c), isoMillisecond: GetSlot(this, m), isoMinute: GetSlot(this, l), isoNanosecond: GetSlot(this, h), isoSecond: GetSlot(this, d) };
    }
    static from(e2, t2) {
      const r2 = ToTemporalOverflow(GetOptionsObject(t2));
      return IsTemporalTime(e2) ? new PlainTime(GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h)) : ToTemporalTime(e2, r2);
    }
    static compare(e2, t2) {
      const r2 = ToTemporalTime(e2), o2 = ToTemporalTime(t2);
      for (const e3 of [s, l, d, m, c, h]) {
        const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
        if (t3 !== n2)
          return ComparisonResult(t3 - n2);
      }
      return 0;
    }
  };
  MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
  var TimeZone = class {
    constructor(e2) {
      if (arguments.length < 1)
        throw new RangeError("missing argument: identifier is required");
      const t2 = GetCanonicalTimeZoneIdentifier(e2);
      CreateSlots(this), SetSlot(this, o, t2);
    }
    get id() {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      return ToString(this);
    }
    getOffsetNanosecondsFor(e2) {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalInstant(e2), n2 = GetSlot(this, o);
      return TestTimeZoneOffsetString(n2) ? ParseTimeZoneOffsetString(n2) : GetIANATimeZoneOffsetNanoseconds(GetSlot(t2, r), n2);
    }
    getOffsetStringFor(e2) {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      return BuiltinTimeZoneGetOffsetStringFor(this, ToTemporalInstant(e2));
    }
    getPlainDateTimeFor(e2, t2 = GetISO8601Calendar()) {
      return BuiltinTimeZoneGetPlainDateTimeFor(this, ToTemporalInstant(e2), ToTemporalCalendar(t2));
    }
    getInstantFor(e2, t2) {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      return BuiltinTimeZoneGetInstantFor(this, ToTemporalDateTime(e2), ToTemporalDisambiguation(GetOptionsObject(t2)));
    }
    getPossibleInstantsFor(t2) {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      const r2 = ToTemporalDateTime(t2), u2 = GetIntrinsic("%Temporal.Instant%"), T2 = GetSlot(this, o);
      if (TestTimeZoneOffsetString(T2)) {
        const t3 = GetEpochFromISOParts(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h));
        if (null === t3)
          throw new RangeError("DateTime outside of supported range");
        const o2 = ParseTimeZoneOffsetString(T2);
        return [new u2(import_jsbi.default.subtract(t3, import_jsbi.default.BigInt(o2)))];
      }
      return function GetIANATimeZoneEpochValue(t3, r3, o2, n2, a2, i2, s2, l2, d2, m2) {
        const c2 = GetEpochFromISOParts(r3, o2, n2, a2, i2, s2, l2, d2, m2);
        if (null === c2)
          throw new RangeError("DateTime outside of supported range");
        let h2 = import_jsbi.default.subtract(c2, we);
        import_jsbi.default.lessThan(h2, ge) && (h2 = c2);
        let u3 = import_jsbi.default.add(c2, we);
        import_jsbi.default.greaterThan(u3, Ie) && (u3 = c2);
        const T3 = GetIANATimeZoneOffsetNanoseconds(h2, t3), p2 = GetIANATimeZoneOffsetNanoseconds(u3, t3);
        return (T3 === p2 ? [T3] : [T3, p2]).map((h3) => {
          const u4 = import_jsbi.default.subtract(c2, import_jsbi.default.BigInt(h3)), T4 = GetIANATimeZoneDateTimeParts(u4, t3);
          if (r3 === T4.year && o2 === T4.month && n2 === T4.day && a2 === T4.hour && i2 === T4.minute && s2 === T4.second && l2 === T4.millisecond && d2 === T4.microsecond && m2 === T4.nanosecond)
            return u4;
        }).filter((e2) => void 0 !== e2);
      }(T2, GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h)).map((e2) => new u2(e2));
    }
    getNextTransition(t2) {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      const n2 = ToTemporalInstant(t2), a2 = GetSlot(this, o);
      if (TestTimeZoneOffsetString(a2) || "UTC" === a2)
        return null;
      let i2 = GetSlot(n2, r);
      const s2 = GetIntrinsic("%Temporal.Instant%");
      return i2 = function GetIANATimeZoneNextTransition(t3, r2) {
        const o2 = import_jsbi.default.add(t3, ve), n3 = maxJSBI(afterLatestPossibleTzdbRuleChange(), o2);
        let a3 = maxJSBI(De, t3);
        const i3 = GetIANATimeZoneOffsetNanoseconds(a3, r2);
        let s3 = a3, l2 = i3;
        for (; i3 === l2 && import_jsbi.default.lessThan(import_jsbi.default.BigInt(a3), n3); )
          s3 = import_jsbi.default.add(a3, Oe), l2 = GetIANATimeZoneOffsetNanoseconds(s3, r2), i3 === l2 && (a3 = s3);
        return i3 === l2 ? null : bisect((e2) => GetIANATimeZoneOffsetNanoseconds(e2, r2), a3, s3, i3, l2);
      }(i2, a2), null === i2 ? null : new s2(i2);
    }
    getPreviousTransition(e2) {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalInstant(e2), n2 = GetSlot(this, o);
      if (TestTimeZoneOffsetString(n2) || "UTC" === n2)
        return null;
      let a2 = GetSlot(t2, r);
      const i2 = GetIntrinsic("%Temporal.Instant%");
      return a2 = GetIANATimeZonePreviousTransition(a2, n2), null === a2 ? null : new i2(a2);
    }
    toString() {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      return ToString(GetSlot(this, o));
    }
    toJSON() {
      if (!IsTemporalTimeZone(this))
        throw new TypeError("invalid receiver");
      return ToString(this);
    }
    static from(e2) {
      return ToTemporalTimeZone(e2);
    }
  };
  MakeIntrinsicClass(TimeZone, "Temporal.TimeZone");
  var St = Object.create;
  var PlainYearMonth = class {
    constructor(e2, t2, r2 = GetISO8601Calendar(), o2 = 1) {
      const n2 = ToIntegerThrowOnInfinity(e2), a2 = ToIntegerThrowOnInfinity(t2), i2 = ToTemporalCalendar(r2), s2 = ToIntegerThrowOnInfinity(o2);
      if (arguments.length < 2)
        throw new RangeError("missing argument: isoYear and isoMonth are required");
      CreateTemporalYearMonthSlots(this, n2, a2, i2, s2);
    }
    get year() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarYear(GetSlot(this, u), this);
    }
    get month() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarMonth(GetSlot(this, u), this);
    }
    get monthCode() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthCode(GetSlot(this, u), this);
    }
    get calendar() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, u);
    }
    get era() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarEra(GetSlot(this, u), this);
    }
    get eraYear() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarEraYear(GetSlot(this, u), this);
    }
    get daysInMonth() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInMonth(GetSlot(this, u), this);
    }
    get daysInYear() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInYear(GetSlot(this, u), this);
    }
    get monthsInYear() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthsInYear(GetSlot(this, u), this);
    }
    get inLeapYear() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return CalendarInLeapYear(GetSlot(this, u), this);
    }
    with(e2, t2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid argument");
      RejectObjectWithCalendarOrTimeZone(e2);
      const r2 = GetSlot(this, u), o2 = CalendarFields(r2, ["month", "monthCode", "year"]), n2 = PrepareTemporalFields(e2, o2, "partial");
      if (!n2)
        throw new TypeError("invalid year-month-like");
      let a2 = PrepareTemporalFields(this, o2, []);
      a2 = CalendarMergeFields(r2, a2, n2), a2 = PrepareTemporalFields(a2, o2, []);
      return CalendarYearMonthFromFields(r2, a2, GetOptionsObject(t2));
    }
    add(e2, t2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromPlainYearMonth("add", this, e2, t2);
    }
    subtract(e2, t2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromPlainYearMonth("subtract", this, e2, t2);
    }
    until(e2, t2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainYearMonth("until", this, e2, t2);
    }
    since(e2, t2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalPlainYearMonth("since", this, e2, t2);
    }
    equals(e2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalYearMonth(e2);
      for (const e3 of [n, a, i]) {
        if (GetSlot(this, e3) !== GetSlot(t2, e3))
          return false;
      }
      return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
    }
    toString(e2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return TemporalYearMonthToString(this, ToShowCalendarOption(GetOptionsObject(e2)));
    }
    toJSON() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return TemporalYearMonthToString(this);
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return new ot(e2, t2).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
    }
    toPlainDate(e2) {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("argument should be an object");
      const t2 = GetSlot(this, u), r2 = CalendarFields(t2, ["monthCode", "year"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["day"]);
      let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
      a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
      const i2 = St(null);
      return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
    }
    getISOFields() {
      if (!IsTemporalYearMonth(this))
        throw new TypeError("invalid receiver");
      return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoMonth: GetSlot(this, a), isoYear: GetSlot(this, n) };
    }
    static from(e2, t2) {
      const r2 = GetOptionsObject(t2);
      return IsTemporalYearMonth(e2) ? (ToTemporalOverflow(r2), CreateTemporalYearMonth(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, u), GetSlot(e2, i))) : ToTemporalYearMonth(e2, r2);
    }
    static compare(e2, t2) {
      const r2 = ToTemporalYearMonth(e2), o2 = ToTemporalYearMonth(t2);
      return CompareISODate(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(o2, n), GetSlot(o2, a), GetSlot(o2, i));
    }
  };
  MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
  var ZonedDateTime = class {
    constructor(e2, t2, r2 = GetISO8601Calendar()) {
      if (arguments.length < 1)
        throw new TypeError("missing argument: epochNanoseconds is required");
      CreateTemporalZonedDateTimeSlots(this, ToBigInt(e2), ToTemporalTimeZone(t2), ToTemporalCalendar(r2));
    }
    get calendar() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, u);
    }
    get timeZone() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(this, p);
    }
    get year() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarYear(GetSlot(this, u), dateTime(this));
    }
    get month() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarMonth(GetSlot(this, u), dateTime(this));
    }
    get monthCode() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthCode(GetSlot(this, u), dateTime(this));
    }
    get day() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDay(GetSlot(this, u), dateTime(this));
    }
    get hour() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(dateTime(this), s);
    }
    get minute() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(dateTime(this), l);
    }
    get second() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(dateTime(this), d);
    }
    get millisecond() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(dateTime(this), m);
    }
    get microsecond() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(dateTime(this), c);
    }
    get nanosecond() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetSlot(dateTime(this), h);
    }
    get era() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarEra(GetSlot(this, u), dateTime(this));
    }
    get eraYear() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarEraYear(GetSlot(this, u), dateTime(this));
    }
    get epochSeconds() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetSlot(this, r);
      return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, ye));
    }
    get epochMilliseconds() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetSlot(this, r);
      return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, fe));
    }
    get epochMicroseconds() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetSlot(this, r);
      return ToBigIntExternal(import_jsbi.default.divide(t2, pe));
    }
    get epochNanoseconds() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return ToBigIntExternal(GetSlot(this, r));
    }
    get dayOfWeek() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDayOfWeek(GetSlot(this, u), dateTime(this));
    }
    get dayOfYear() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDayOfYear(GetSlot(this, u), dateTime(this));
    }
    get weekOfYear() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarWeekOfYear(GetSlot(this, u), dateTime(this));
    }
    get hoursInDay() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = dateTime(this), o2 = GetIntrinsic("%Temporal.PlainDateTime%"), s2 = GetSlot(t2, n), l2 = GetSlot(t2, a), d2 = GetSlot(t2, i), m2 = new o2(s2, l2, d2, 0, 0, 0, 0, 0, 0), c2 = AddISODate(s2, l2, d2, 0, 0, 0, 1, "reject"), h2 = new o2(c2.year, c2.month, c2.day, 0, 0, 0, 0, 0, 0), u2 = GetSlot(this, p), T2 = GetSlot(BuiltinTimeZoneGetInstantFor(u2, m2, "compatible"), r), f2 = GetSlot(BuiltinTimeZoneGetInstantFor(u2, h2, "compatible"), r);
      return import_jsbi.default.toNumber(import_jsbi.default.subtract(f2, T2)) / 36e11;
    }
    get daysInWeek() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInWeek(GetSlot(this, u), dateTime(this));
    }
    get daysInMonth() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInMonth(GetSlot(this, u), dateTime(this));
    }
    get daysInYear() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarDaysInYear(GetSlot(this, u), dateTime(this));
    }
    get monthsInYear() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarMonthsInYear(GetSlot(this, u), dateTime(this));
    }
    get inLeapYear() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return CalendarInLeapYear(GetSlot(this, u), dateTime(this));
    }
    get offset() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, p), GetSlot(this, T));
    }
    get offsetNanoseconds() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return GetOffsetNanosecondsFor(GetSlot(this, p), GetSlot(this, T));
    }
    with(e2, t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      if (!IsObject(e2))
        throw new TypeError("invalid zoned-date-time-like");
      RejectObjectWithCalendarOrTimeZone(e2);
      const r2 = GetOptionsObject(t2), o2 = ToTemporalDisambiguation(r2), n2 = ToTemporalOffset(r2, "prefer"), a2 = GetSlot(this, p), i2 = GetSlot(this, u), s2 = ArrayPush(CalendarFields(i2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), "offset"), l2 = PrepareTemporalFields(e2, s2, "partial"), d2 = ArrayPush(s2, "timeZone");
      let m2 = PrepareTemporalFields(this, d2, ["timeZone", "offset"]);
      m2 = CalendarMergeFields(i2, m2, l2), m2 = PrepareTemporalFields(m2, d2, ["timeZone", "offset"]);
      let { year: c2, month: h2, day: T2, hour: f2, minute: y2, second: S2, millisecond: w2, microsecond: g2, nanosecond: I2 } = InterpretTemporalDateTimeFields(i2, m2, r2);
      return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(c2, h2, T2, f2, y2, S2, w2, g2, I2, "option", ParseTimeZoneOffsetString(m2.offset), a2, o2, n2, false), GetSlot(this, p), i2);
    }
    withPlainDate(e2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalDate(e2), o2 = GetSlot(t2, n), T2 = GetSlot(t2, a), f2 = GetSlot(t2, i);
      let y2 = GetSlot(t2, u);
      const S2 = dateTime(this), w2 = GetSlot(S2, s), g2 = GetSlot(S2, l), I2 = GetSlot(S2, d), D2 = GetSlot(S2, m), G2 = GetSlot(S2, c), v2 = GetSlot(S2, h);
      y2 = ConsolidateCalendars(GetSlot(this, u), y2);
      const O2 = GetSlot(this, p);
      return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(O2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(o2, T2, f2, w2, g2, I2, D2, G2, v2, y2), "compatible"), r), O2, y2);
    }
    withPlainTime(e2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetIntrinsic("%Temporal.PlainTime%"), o2 = void 0 === e2 ? new t2() : ToTemporalTime(e2), T2 = dateTime(this), f2 = GetSlot(T2, n), y2 = GetSlot(T2, a), S2 = GetSlot(T2, i), w2 = GetSlot(this, u), g2 = GetSlot(o2, s), I2 = GetSlot(o2, l), D2 = GetSlot(o2, d), G2 = GetSlot(o2, m), v2 = GetSlot(o2, c), O2 = GetSlot(o2, h), C2 = GetSlot(this, p);
      return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(C2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, S2, g2, I2, D2, G2, v2, O2, w2), "compatible"), r), C2, w2);
    }
    withTimeZone(e2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalTimeZone(e2);
      return CreateTemporalZonedDateTime(GetSlot(this, r), t2, GetSlot(this, u));
    }
    withCalendar(e2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = ToTemporalCalendar(e2);
      return CreateTemporalZonedDateTime(GetSlot(this, r), GetSlot(this, p), t2);
    }
    add(e2, t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromZonedDateTime("add", this, e2, t2);
    }
    subtract(e2, t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return AddDurationToOrSubtractDurationFromZonedDateTime("subtract", this, e2, t2);
    }
    until(e2, t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalZonedDateTime("until", this, e2, t2);
    }
    since(e2, t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return DifferenceTemporalZonedDateTime("since", this, e2, t2);
    }
    round(t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      if (void 0 === t2)
        throw new TypeError("options parameter is required");
      const o2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2), f2 = GetTemporalUnit(o2, "smallestUnit", "time", je, ["day"]), y2 = ToTemporalRoundingMode(o2, "halfExpand"), S2 = ToTemporalRoundingIncrement(o2, { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[f2], false), w2 = dateTime(this);
      let g2 = GetSlot(w2, n), I2 = GetSlot(w2, a), D2 = GetSlot(w2, i), G2 = GetSlot(w2, s), v2 = GetSlot(w2, l), O2 = GetSlot(w2, d), C2 = GetSlot(w2, m), E2 = GetSlot(w2, c), b2 = GetSlot(w2, h);
      const M2 = GetIntrinsic("%Temporal.PlainDateTime%"), R2 = GetSlot(this, p), Z2 = GetSlot(this, u), P2 = BuiltinTimeZoneGetInstantFor(R2, new M2(GetSlot(w2, n), GetSlot(w2, a), GetSlot(w2, i), 0, 0, 0, 0, 0, 0), "compatible"), F2 = AddZonedDateTime(P2, R2, Z2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0), Y2 = import_jsbi.default.subtract(F2, import_jsbi.default.BigInt(GetSlot(P2, r)));
      if (import_jsbi.default.equal(Y2, he))
        throw new RangeError("cannot round a ZonedDateTime in a calendar with zero-length days");
      ({ year: g2, month: I2, day: D2, hour: G2, minute: v2, second: O2, millisecond: C2, microsecond: E2, nanosecond: b2 } = RoundISODateTime(g2, I2, D2, G2, v2, O2, C2, E2, b2, S2, f2, y2, import_jsbi.default.toNumber(Y2)));
      return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(g2, I2, D2, G2, v2, O2, C2, E2, b2, "option", GetOffsetNanosecondsFor(R2, GetSlot(this, T)), R2, "compatible", "prefer", false), R2, GetSlot(this, u));
    }
    equals(t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const o2 = ToTemporalZonedDateTime(t2), n2 = GetSlot(this, r), a2 = GetSlot(o2, r);
      return !!import_jsbi.default.equal(import_jsbi.default.BigInt(n2), import_jsbi.default.BigInt(a2)) && (!!TimeZoneEquals(GetSlot(this, p), GetSlot(o2, p)) && CalendarEquals(GetSlot(this, u), GetSlot(o2, u)));
    }
    toString(e2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2), a2 = ToTemporalRoundingMode(t2, "trunc");
      return TemporalZonedDateTimeToString(this, r2, ToShowCalendarOption(t2), function ToShowTimeZoneNameOption(e3) {
        return GetOption(e3, "timeZoneName", ["auto", "never"], "auto");
      }(t2), function ToShowOffsetOption(e3) {
        return GetOption(e3, "offset", ["auto", "never"], "auto");
      }(t2), { unit: o2, increment: n2, roundingMode: a2 });
    }
    toLocaleString(e2, t2) {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return new ot(e2, t2).format(this);
    }
    toJSON() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return TemporalZonedDateTimeToString(this, "auto");
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
    }
    startOfDay() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const e2 = dateTime(this), t2 = GetIntrinsic("%Temporal.PlainDateTime%"), o2 = GetSlot(this, u), s2 = new t2(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), 0, 0, 0, 0, 0, 0, o2), l2 = GetSlot(this, p);
      return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(l2, s2, "compatible"), r), l2, o2);
    }
    toInstant() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, r));
    }
    toPlainDate() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return TemporalDateTimeToDate(dateTime(this));
    }
    toPlainTime() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return TemporalDateTimeToTime(dateTime(this));
    }
    toPlainDateTime() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      return dateTime(this);
    }
    toPlainYearMonth() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const e2 = GetSlot(this, u);
      return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
    }
    toPlainMonthDay() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const e2 = GetSlot(this, u);
      return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
    }
    getISOFields() {
      if (!IsTemporalZonedDateTime(this))
        throw new TypeError("invalid receiver");
      const e2 = dateTime(this), t2 = GetSlot(this, p);
      return { calendar: GetSlot(this, u), isoDay: GetSlot(e2, i), isoHour: GetSlot(e2, s), isoMicrosecond: GetSlot(e2, c), isoMillisecond: GetSlot(e2, m), isoMinute: GetSlot(e2, l), isoMonth: GetSlot(e2, a), isoNanosecond: GetSlot(e2, h), isoSecond: GetSlot(e2, d), isoYear: GetSlot(e2, n), offset: BuiltinTimeZoneGetOffsetStringFor(t2, GetSlot(this, T)), timeZone: t2 };
    }
    static from(e2, t2) {
      const o2 = GetOptionsObject(t2);
      return IsTemporalZonedDateTime(e2) ? (ToTemporalOverflow(o2), ToTemporalDisambiguation(o2), ToTemporalOffset(o2, "reject"), CreateTemporalZonedDateTime(GetSlot(e2, r), GetSlot(e2, p), GetSlot(e2, u))) : ToTemporalZonedDateTime(e2, o2);
    }
    static compare(t2, o2) {
      const n2 = ToTemporalZonedDateTime(t2), a2 = ToTemporalZonedDateTime(o2), i2 = GetSlot(n2, r), s2 = GetSlot(a2, r);
      return import_jsbi.default.lessThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? -1 : import_jsbi.default.greaterThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? 1 : 0;
    }
  };
  function dateTime(e2) {
    return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(e2, p), GetSlot(e2, T), GetSlot(e2, u));
  }
  MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
  var wt = Object.freeze({ __proto__: null, Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, Now: ft, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime });
  var gt = [Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime];
  for (const e2 of gt) {
    const t2 = Object.getOwnPropertyDescriptor(e2, "prototype");
    (t2.configurable || t2.enumerable || t2.writable) && (t2.configurable = false, t2.enumerable = false, t2.writable = false, Object.defineProperty(e2, "prototype", t2));
  }

  // node_modules/ipfs-unixfs-exporter/esm/src/index.js
  init_virtual_process_polyfill();
  var import_err_code9 = __toESM(require_err_code(), 1);

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/cid.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/varint.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/vendor/varint.js
  init_virtual_process_polyfill();
  var encode_12 = encode6;
  var MSB2 = 128;
  var REST2 = 127;
  var MSBALL2 = ~REST2;
  var INT2 = Math.pow(2, 31);
  function encode6(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT2) {
      out[offset++] = num & 255 | MSB2;
      num /= 128;
    }
    while (num & MSBALL2) {
      out[offset++] = num & 255 | MSB2;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode6.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode8 = read3;
  var MSB$12 = 128;
  var REST$12 = 127;
  function read3(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
    do {
      if (counter >= l2) {
        read3.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b2 = buf2[counter++];
      res += shift < 28 ? (b2 & REST$12) << shift : (b2 & REST$12) * Math.pow(2, shift);
      shift += 7;
    } while (b2 >= MSB$12);
    read3.bytes = counter - offset;
    return res;
  }
  var N12 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N52 = Math.pow(2, 35);
  var N62 = Math.pow(2, 42);
  var N72 = Math.pow(2, 49);
  var N82 = Math.pow(2, 56);
  var N92 = Math.pow(2, 63);
  var length2 = function(value) {
    return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
  };
  var varint2 = {
    encode: encode_12,
    decode: decode8,
    encodingLength: length2
  };
  var _brrp_varint2 = varint2;
  var varint_default2 = _brrp_varint2;

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/varint.js
  var decode9 = (data, offset = 0) => {
    const code8 = varint_default2.decode(data, offset);
    return [
      code8,
      varint_default2.decode.bytes
    ];
  };
  var encodeTo2 = (int, target, offset = 0) => {
    varint_default2.encode(int, target, offset);
    return target;
  };
  var encodingLength2 = (int) => {
    return varint_default2.encodingLength(int);
  };

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/hashes/digest.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bytes.js
  init_virtual_process_polyfill();
  var empty2 = new Uint8Array(0);
  var equals4 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce2 = (o2) => {
    if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
      return o2;
    if (o2 instanceof ArrayBuffer)
      return new Uint8Array(o2);
    if (ArrayBuffer.isView(o2)) {
      return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/hashes/digest.js
  var create2 = (code8, digest3) => {
    const size = digest3.byteLength;
    const sizeOffset = encodingLength2(code8);
    const digestOffset = sizeOffset + encodingLength2(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo2(code8, bytes, 0);
    encodeTo2(size, bytes, sizeOffset);
    bytes.set(digest3, digestOffset);
    return new Digest2(code8, size, digest3, bytes);
  };
  var decode10 = (multihash) => {
    const bytes = coerce2(multihash);
    const [code8, sizeOffset] = decode9(bytes);
    const [size, digestOffset] = decode9(bytes.subarray(sizeOffset));
    const digest3 = bytes.subarray(sizeOffset + digestOffset);
    if (digest3.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest2(code8, size, digest3, bytes);
  };
  var equals5 = (a2, b2) => {
    if (a2 === b2) {
      return true;
    } else {
      return a2.code === b2.code && a2.size === b2.size && equals4(a2.bytes, b2.bytes);
    }
  };
  var Digest2 = class {
    constructor(code8, size, digest3, bytes) {
      this.code = code8;
      this.size = size;
      this.digest = digest3;
      this.bytes = bytes;
    }
  };

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base58.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/vendor/base-x.js
  init_virtual_process_polyfill();
  function base2(ALPHABET, name6) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
      BASE_MAP[j2] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET.length; i2++) {
      var x2 = ALPHABET.charAt(i2);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode21(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length7 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length7) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        pbegin++;
      }
      var it2 = size - length7;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length7 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length7) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length7;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j3 = zeroes;
      while (it4 !== size) {
        vch[j3++] = b256[it4++];
      }
      return vch;
    }
    function decode32(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name6} character`);
    }
    return {
      encode: encode21,
      decodeUnsafe,
      decode: decode32
    };
  }
  var src2 = base2;
  var _brrp__multiformats_scope_baseX2 = src2;
  var base_x_default2 = _brrp__multiformats_scope_baseX2;

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base.js
  var Encoder3 = class {
    constructor(name6, prefix, baseEncode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder2 = class {
    constructor(name6, prefix, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or2(this, decoder);
    }
  };
  var ComposedDecoder2 = class {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or2(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or2 = (left, right) => new ComposedDecoder2({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  var Codec2 = class {
    constructor(name6, prefix, baseEncode, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder3(name6, prefix, baseEncode);
      this.decoder = new Decoder2(name6, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from4 = ({ name: name6, prefix, encode: encode21, decode: decode32 }) => new Codec2(name6, prefix, encode21, decode32);
  var baseX2 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
    const { encode: encode21, decode: decode32 } = base_x_default2(alphabet2, name6);
    return from4({
      prefix,
      name: name6,
      encode: encode21,
      decode: (text) => coerce2(decode32(text))
    });
  };
  var decode11 = (string2, alphabet2, bitsPerChar, name6) => {
    const codes = {};
    for (let i2 = 0; i2 < alphabet2.length; ++i2) {
      codes[alphabet2[i2]] = i2;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i2 = 0; i2 < end; ++i2) {
      const value = codes[string2[i2]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name6} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode7 = (data, alphabet2, bitsPerChar) => {
    const pad2 = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      buffer2 = buffer2 << 8 | data[i2];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer2 >> bits];
      }
    }
    if (bits) {
      out += alphabet2[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad2) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc46482 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from4({
      prefix,
      name: name6,
      encode(input) {
        return encode7(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode11(input, alphabet2, bitsPerChar, name6);
      }
    });
  };

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base58.js
  var base58btc2 = baseX2({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr2 = baseX2({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base32.js
  init_virtual_process_polyfill();
  var base322 = rfc46482({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper2 = rfc46482({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad2 = rfc46482({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper2 = rfc46482({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex2 = rfc46482({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper2 = rfc46482({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad2 = rfc46482({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper2 = rfc46482({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z2 = rfc46482({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/cid.js
  var CID2 = class {
    constructor(version8, code8, multihash, bytes) {
      this.code = code8;
      this.version = version8;
      this.multihash = multihash;
      this.bytes = bytes;
      this.byteOffset = bytes.byteOffset;
      this.byteLength = bytes.byteLength;
      this.asCID = this;
      this._baseCache = /* @__PURE__ */ new Map();
      Object.defineProperties(this, {
        byteOffset: hidden,
        byteLength: hidden,
        code: readonly2,
        version: readonly2,
        multihash: readonly2,
        bytes: readonly2,
        _baseCache: hidden,
        asCID: hidden
      });
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        default: {
          const { code: code8, multihash } = this;
          if (code8 !== DAG_PB_CODE2) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE2) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID2.createV0(multihash);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code8, digest: digest3 } = this.multihash;
          const multihash = create2(code8, digest3);
          return CID2.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return other && this.code === other.code && this.version === other.version && equals5(this.multihash, other.multihash);
    }
    toString(base7) {
      const { bytes, version: version8, _baseCache } = this;
      switch (version8) {
        case 0:
          return toStringV02(bytes, _baseCache, base7 || base58btc2.encoder);
        default:
          return toStringV12(bytes, _baseCache, base7 || base322.encoder);
      }
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
      deprecate2(/^0\.0/, IS_CID_DEPRECATION);
      return !!(value && (value[cidSymbol2] || value.asCID === value));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
      if (value instanceof CID2) {
        return value;
      } else if (value != null && value.asCID === value) {
        const { version: version8, code: code8, multihash, bytes } = value;
        return new CID2(version8, code8, multihash, bytes || encodeCID2(version8, code8, multihash.bytes));
      } else if (value != null && value[cidSymbol2] === true) {
        const { version: version8, multihash, code: code8 } = value;
        const digest3 = decode10(multihash);
        return CID2.create(version8, code8, digest3);
      } else {
        return null;
      }
    }
    static create(version8, code8, digest3) {
      if (typeof code8 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      switch (version8) {
        case 0: {
          if (code8 !== DAG_PB_CODE2) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
          } else {
            return new CID2(version8, code8, digest3, digest3.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID2(version8, code8, digest3.bytes);
          return new CID2(version8, code8, digest3, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest3) {
      return CID2.create(0, DAG_PB_CODE2, digest3);
    }
    static createV1(code8, digest3) {
      return CID2.create(1, code8, digest3);
    }
    static decode(bytes) {
      const [cid, remainder] = CID2.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes) {
      const specs = CID2.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest3 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? CID2.createV0(digest3) : CID2.createV1(specs.codec, digest3);
      return [
        cid,
        bytes.subarray(specs.size)
      ];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i2, length7] = decode9(initialBytes.subarray(offset));
        offset += length7;
        return i2;
      };
      let version8 = next();
      let codec = DAG_PB_CODE2;
      if (version8 === 18) {
        version8 = 0;
        offset = 0;
      } else if (version8 === 1) {
        codec = next();
      }
      if (version8 !== 0 && version8 !== 1) {
        throw new RangeError(`Invalid CID version ${version8}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return {
        version: version8,
        codec,
        multihashCode,
        digestSize,
        multihashSize,
        size
      };
    }
    static parse(source, base7) {
      const [prefix, bytes] = parseCIDtoBytes2(source, base7);
      const cid = CID2.decode(bytes);
      cid._baseCache.set(prefix, source);
      return cid;
    }
  };
  var parseCIDtoBytes2 = (source, base7) => {
    switch (source[0]) {
      case "Q": {
        const decoder = base7 || base58btc2;
        return [
          base58btc2.prefix,
          decoder.decode(`${base58btc2.prefix}${source}`)
        ];
      }
      case base58btc2.prefix: {
        const decoder = base7 || base58btc2;
        return [
          base58btc2.prefix,
          decoder.decode(source)
        ];
      }
      case base322.prefix: {
        const decoder = base7 || base322;
        return [
          base322.prefix,
          decoder.decode(source)
        ];
      }
      default: {
        if (base7 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [
          source[0],
          base7.decode(source)
        ];
      }
    }
  };
  var toStringV02 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    if (prefix !== base58btc2.prefix) {
      throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV12 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE2 = 112;
  var SHA_256_CODE2 = 18;
  var encodeCID2 = (version8, code8, multihash) => {
    const codeOffset = encodingLength2(version8);
    const hashOffset = codeOffset + encodingLength2(code8);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo2(version8, bytes, 0);
    encodeTo2(code8, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
  var readonly2 = {
    writable: false,
    configurable: false,
    enumerable: true
  };
  var hidden = {
    writable: false,
    enumerable: false,
    configurable: false
  };
  var version3 = "0.0.0-dev";
  var deprecate2 = (range, message) => {
    if (range.test(version3)) {
      console.warn(message);
    } else {
      throw new Error(message);
    }
  };
  var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
  init_virtual_process_polyfill();
  var import_err_code8 = __toESM(require_err_code(), 1);

  // node_modules/@ipld/dag-pb/esm/src/index.js
  var src_exports2 = {};
  __export(src_exports2, {
    code: () => code2,
    createLink: () => createLink,
    createNode: () => createNode,
    decode: () => decode16,
    encode: () => encode10,
    name: () => name2,
    prepare: () => prepare,
    validate: () => validate
  });
  init_virtual_process_polyfill();

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/cid.js
  init_virtual_process_polyfill();

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/varint.js
  init_virtual_process_polyfill();

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/vendor/varint.js
  init_virtual_process_polyfill();
  var encode_13 = encode8;
  var MSB3 = 128;
  var REST3 = 127;
  var MSBALL3 = ~REST3;
  var INT3 = Math.pow(2, 31);
  function encode8(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT3) {
      out[offset++] = num & 255 | MSB3;
      num /= 128;
    }
    while (num & MSBALL3) {
      out[offset++] = num & 255 | MSB3;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode8.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode12 = read4;
  var MSB$13 = 128;
  var REST$13 = 127;
  function read4(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
    do {
      if (counter >= l2) {
        read4.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b2 = buf2[counter++];
      res += shift < 28 ? (b2 & REST$13) << shift : (b2 & REST$13) * Math.pow(2, shift);
      shift += 7;
    } while (b2 >= MSB$13);
    read4.bytes = counter - offset;
    return res;
  }
  var N13 = Math.pow(2, 7);
  var N23 = Math.pow(2, 14);
  var N33 = Math.pow(2, 21);
  var N43 = Math.pow(2, 28);
  var N53 = Math.pow(2, 35);
  var N63 = Math.pow(2, 42);
  var N73 = Math.pow(2, 49);
  var N83 = Math.pow(2, 56);
  var N93 = Math.pow(2, 63);
  var length3 = function(value) {
    return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
  };
  var varint3 = {
    encode: encode_13,
    decode: decode12,
    encodingLength: length3
  };
  var _brrp_varint3 = varint3;
  var varint_default3 = _brrp_varint3;

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/varint.js
  var decode13 = (data, offset = 0) => {
    const code8 = varint_default3.decode(data, offset);
    return [
      code8,
      varint_default3.decode.bytes
    ];
  };
  var encodeTo3 = (int, target, offset = 0) => {
    varint_default3.encode(int, target, offset);
    return target;
  };
  var encodingLength3 = (int) => {
    return varint_default3.encodingLength(int);
  };

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/hashes/digest.js
  init_virtual_process_polyfill();

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bytes.js
  init_virtual_process_polyfill();
  var empty3 = new Uint8Array(0);
  var equals6 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce3 = (o2) => {
    if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
      return o2;
    if (o2 instanceof ArrayBuffer)
      return new Uint8Array(o2);
    if (ArrayBuffer.isView(o2)) {
      return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/hashes/digest.js
  var create3 = (code8, digest3) => {
    const size = digest3.byteLength;
    const sizeOffset = encodingLength3(code8);
    const digestOffset = sizeOffset + encodingLength3(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo3(code8, bytes, 0);
    encodeTo3(size, bytes, sizeOffset);
    bytes.set(digest3, digestOffset);
    return new Digest3(code8, size, digest3, bytes);
  };
  var decode14 = (multihash) => {
    const bytes = coerce3(multihash);
    const [code8, sizeOffset] = decode13(bytes);
    const [size, digestOffset] = decode13(bytes.subarray(sizeOffset));
    const digest3 = bytes.subarray(sizeOffset + digestOffset);
    if (digest3.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest3(code8, size, digest3, bytes);
  };
  var equals7 = (a2, b2) => {
    if (a2 === b2) {
      return true;
    } else {
      return a2.code === b2.code && a2.size === b2.size && equals6(a2.bytes, b2.bytes);
    }
  };
  var Digest3 = class {
    constructor(code8, size, digest3, bytes) {
      this.code = code8;
      this.size = size;
      this.digest = digest3;
      this.bytes = bytes;
    }
  };

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base58.js
  init_virtual_process_polyfill();

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base.js
  init_virtual_process_polyfill();

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/vendor/base-x.js
  init_virtual_process_polyfill();
  function base3(ALPHABET, name6) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
      BASE_MAP[j2] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET.length; i2++) {
      var x2 = ALPHABET.charAt(i2);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode21(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length7 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length7) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        pbegin++;
      }
      var it2 = size - length7;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length7 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length7) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length7;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j3 = zeroes;
      while (it4 !== size) {
        vch[j3++] = b256[it4++];
      }
      return vch;
    }
    function decode32(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name6} character`);
    }
    return {
      encode: encode21,
      decodeUnsafe,
      decode: decode32
    };
  }
  var src3 = base3;
  var _brrp__multiformats_scope_baseX3 = src3;
  var base_x_default3 = _brrp__multiformats_scope_baseX3;

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base.js
  var Encoder4 = class {
    constructor(name6, prefix, baseEncode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder3 = class {
    constructor(name6, prefix, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or3(this, decoder);
    }
  };
  var ComposedDecoder3 = class {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or3(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or3 = (left, right) => new ComposedDecoder3({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  var Codec3 = class {
    constructor(name6, prefix, baseEncode, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder4(name6, prefix, baseEncode);
      this.decoder = new Decoder3(name6, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from5 = ({ name: name6, prefix, encode: encode21, decode: decode32 }) => new Codec3(name6, prefix, encode21, decode32);
  var baseX3 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
    const { encode: encode21, decode: decode32 } = base_x_default3(alphabet2, name6);
    return from5({
      prefix,
      name: name6,
      encode: encode21,
      decode: (text) => coerce3(decode32(text))
    });
  };
  var decode15 = (string2, alphabet2, bitsPerChar, name6) => {
    const codes = {};
    for (let i2 = 0; i2 < alphabet2.length; ++i2) {
      codes[alphabet2[i2]] = i2;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i2 = 0; i2 < end; ++i2) {
      const value = codes[string2[i2]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name6} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode9 = (data, alphabet2, bitsPerChar) => {
    const pad2 = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      buffer2 = buffer2 << 8 | data[i2];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer2 >> bits];
      }
    }
    if (bits) {
      out += alphabet2[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad2) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc46483 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from5({
      prefix,
      name: name6,
      encode(input) {
        return encode9(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode15(input, alphabet2, bitsPerChar, name6);
      }
    });
  };

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base58.js
  var base58btc3 = baseX3({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr3 = baseX3({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base32.js
  init_virtual_process_polyfill();
  var base323 = rfc46483({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper3 = rfc46483({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad3 = rfc46483({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper3 = rfc46483({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex3 = rfc46483({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper3 = rfc46483({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad3 = rfc46483({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper3 = rfc46483({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z3 = rfc46483({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/cid.js
  var CID3 = class {
    constructor(version8, code8, multihash, bytes) {
      this.code = code8;
      this.version = version8;
      this.multihash = multihash;
      this.bytes = bytes;
      this.byteOffset = bytes.byteOffset;
      this.byteLength = bytes.byteLength;
      this.asCID = this;
      this._baseCache = /* @__PURE__ */ new Map();
      Object.defineProperties(this, {
        byteOffset: hidden2,
        byteLength: hidden2,
        code: readonly3,
        version: readonly3,
        multihash: readonly3,
        bytes: readonly3,
        _baseCache: hidden2,
        asCID: hidden2
      });
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        default: {
          const { code: code8, multihash } = this;
          if (code8 !== DAG_PB_CODE3) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE3) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID3.createV0(multihash);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code8, digest: digest3 } = this.multihash;
          const multihash = create3(code8, digest3);
          return CID3.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return other && this.code === other.code && this.version === other.version && equals7(this.multihash, other.multihash);
    }
    toString(base7) {
      const { bytes, version: version8, _baseCache } = this;
      switch (version8) {
        case 0:
          return toStringV03(bytes, _baseCache, base7 || base58btc3.encoder);
        default:
          return toStringV13(bytes, _baseCache, base7 || base323.encoder);
      }
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
      deprecate3(/^0\.0/, IS_CID_DEPRECATION2);
      return !!(value && (value[cidSymbol3] || value.asCID === value));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
      if (value instanceof CID3) {
        return value;
      } else if (value != null && value.asCID === value) {
        const { version: version8, code: code8, multihash, bytes } = value;
        return new CID3(version8, code8, multihash, bytes || encodeCID3(version8, code8, multihash.bytes));
      } else if (value != null && value[cidSymbol3] === true) {
        const { version: version8, multihash, code: code8 } = value;
        const digest3 = decode14(multihash);
        return CID3.create(version8, code8, digest3);
      } else {
        return null;
      }
    }
    static create(version8, code8, digest3) {
      if (typeof code8 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      switch (version8) {
        case 0: {
          if (code8 !== DAG_PB_CODE3) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
          } else {
            return new CID3(version8, code8, digest3, digest3.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID3(version8, code8, digest3.bytes);
          return new CID3(version8, code8, digest3, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest3) {
      return CID3.create(0, DAG_PB_CODE3, digest3);
    }
    static createV1(code8, digest3) {
      return CID3.create(1, code8, digest3);
    }
    static decode(bytes) {
      const [cid, remainder] = CID3.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes) {
      const specs = CID3.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce3(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest3 = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? CID3.createV0(digest3) : CID3.createV1(specs.codec, digest3);
      return [
        cid,
        bytes.subarray(specs.size)
      ];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i2, length7] = decode13(initialBytes.subarray(offset));
        offset += length7;
        return i2;
      };
      let version8 = next();
      let codec = DAG_PB_CODE3;
      if (version8 === 18) {
        version8 = 0;
        offset = 0;
      } else if (version8 === 1) {
        codec = next();
      }
      if (version8 !== 0 && version8 !== 1) {
        throw new RangeError(`Invalid CID version ${version8}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return {
        version: version8,
        codec,
        multihashCode,
        digestSize,
        multihashSize,
        size
      };
    }
    static parse(source, base7) {
      const [prefix, bytes] = parseCIDtoBytes3(source, base7);
      const cid = CID3.decode(bytes);
      cid._baseCache.set(prefix, source);
      return cid;
    }
  };
  var parseCIDtoBytes3 = (source, base7) => {
    switch (source[0]) {
      case "Q": {
        const decoder = base7 || base58btc3;
        return [
          base58btc3.prefix,
          decoder.decode(`${base58btc3.prefix}${source}`)
        ];
      }
      case base58btc3.prefix: {
        const decoder = base7 || base58btc3;
        return [
          base58btc3.prefix,
          decoder.decode(source)
        ];
      }
      case base323.prefix: {
        const decoder = base7 || base323;
        return [
          base323.prefix,
          decoder.decode(source)
        ];
      }
      default: {
        if (base7 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [
          source[0],
          base7.decode(source)
        ];
      }
    }
  };
  var toStringV03 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    if (prefix !== base58btc3.prefix) {
      throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV13 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE3 = 112;
  var SHA_256_CODE3 = 18;
  var encodeCID3 = (version8, code8, multihash) => {
    const codeOffset = encodingLength3(version8);
    const hashOffset = codeOffset + encodingLength3(code8);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo3(version8, bytes, 0);
    encodeTo3(code8, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");
  var readonly3 = {
    writable: false,
    configurable: false,
    enumerable: true
  };
  var hidden2 = {
    writable: false,
    enumerable: false,
    configurable: false
  };
  var version4 = "0.0.0-dev";
  var deprecate3 = (range, message) => {
    if (range.test(version4)) {
      console.warn(message);
    } else {
      throw new Error(message);
    }
  };
  var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

  // node_modules/@ipld/dag-pb/esm/src/pb-decode.js
  init_virtual_process_polyfill();
  var textDecoder3 = new TextDecoder();
  function decodeVarint(bytes, offset) {
    let v2 = 0;
    for (let shift = 0; ; shift += 7) {
      if (shift >= 64) {
        throw new Error("protobuf: varint overflow");
      }
      if (offset >= bytes.length) {
        throw new Error("protobuf: unexpected end of data");
      }
      const b2 = bytes[offset++];
      v2 += shift < 28 ? (b2 & 127) << shift : (b2 & 127) * 2 ** shift;
      if (b2 < 128) {
        break;
      }
    }
    return [
      v2,
      offset
    ];
  }
  function decodeBytes(bytes, offset) {
    let byteLen;
    [byteLen, offset] = decodeVarint(bytes, offset);
    const postOffset = offset + byteLen;
    if (byteLen < 0 || postOffset < 0) {
      throw new Error("protobuf: invalid length");
    }
    if (postOffset > bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    return [
      bytes.subarray(offset, postOffset),
      postOffset
    ];
  }
  function decodeKey(bytes, index) {
    let wire;
    [wire, index] = decodeVarint(bytes, index);
    return [
      wire & 7,
      wire >> 3,
      index
    ];
  }
  function decodeLink(bytes) {
    const link = {};
    const l2 = bytes.length;
    let index = 0;
    while (index < l2) {
      let wireType, fieldNum;
      [wireType, fieldNum, index] = decodeKey(bytes, index);
      if (fieldNum === 1) {
        if (link.Hash) {
          throw new Error("protobuf: (PBLink) duplicate Hash section");
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
        }
        if (link.Name !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
        }
        if (link.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
        }
        ;
        [link.Hash, index] = decodeBytes(bytes, index);
      } else if (fieldNum === 2) {
        if (link.Name !== void 0) {
          throw new Error("protobuf: (PBLink) duplicate Name section");
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
        }
        if (link.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
        }
        let byts;
        [byts, index] = decodeBytes(bytes, index);
        link.Name = textDecoder3.decode(byts);
      } else if (fieldNum === 3) {
        if (link.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) duplicate Tsize section");
        }
        if (wireType !== 0) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
        }
        ;
        [link.Tsize, index] = decodeVarint(bytes, index);
      } else {
        throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
      }
    }
    if (index > l2) {
      throw new Error("protobuf: (PBLink) unexpected end of data");
    }
    return link;
  }
  function decodeNode(bytes) {
    const l2 = bytes.length;
    let index = 0;
    let links2;
    let linksBeforeData = false;
    let data;
    while (index < l2) {
      let wireType, fieldNum;
      [wireType, fieldNum, index] = decodeKey(bytes, index);
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
      }
      if (fieldNum === 1) {
        if (data) {
          throw new Error("protobuf: (PBNode) duplicate Data section");
        }
        ;
        [data, index] = decodeBytes(bytes, index);
        if (links2) {
          linksBeforeData = true;
        }
      } else if (fieldNum === 2) {
        if (linksBeforeData) {
          throw new Error("protobuf: (PBNode) duplicate Links section");
        } else if (!links2) {
          links2 = [];
        }
        let byts;
        [byts, index] = decodeBytes(bytes, index);
        links2.push(decodeLink(byts));
      } else {
        throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
      }
    }
    if (index > l2) {
      throw new Error("protobuf: (PBNode) unexpected end of data");
    }
    const node = {};
    if (data) {
      node.Data = data;
    }
    node.Links = links2 || [];
    return node;
  }

  // node_modules/@ipld/dag-pb/esm/src/pb-encode.js
  init_virtual_process_polyfill();
  var textEncoder3 = new TextEncoder();
  var maxInt32 = 2 ** 32;
  var maxUInt32 = 2 ** 31;
  function encodeLink(link, bytes) {
    let i2 = bytes.length;
    if (typeof link.Tsize === "number") {
      if (link.Tsize < 0) {
        throw new Error("Tsize cannot be negative");
      }
      if (!Number.isSafeInteger(link.Tsize)) {
        throw new Error("Tsize too large for encoding");
      }
      i2 = encodeVarint(bytes, i2, link.Tsize) - 1;
      bytes[i2] = 24;
    }
    if (typeof link.Name === "string") {
      const nameBytes = textEncoder3.encode(link.Name);
      i2 -= nameBytes.length;
      bytes.set(nameBytes, i2);
      i2 = encodeVarint(bytes, i2, nameBytes.length) - 1;
      bytes[i2] = 18;
    }
    if (link.Hash) {
      i2 -= link.Hash.length;
      bytes.set(link.Hash, i2);
      i2 = encodeVarint(bytes, i2, link.Hash.length) - 1;
      bytes[i2] = 10;
    }
    return bytes.length - i2;
  }
  function encodeNode(node) {
    const size = sizeNode(node);
    const bytes = new Uint8Array(size);
    let i2 = size;
    if (node.Data) {
      i2 -= node.Data.length;
      bytes.set(node.Data, i2);
      i2 = encodeVarint(bytes, i2, node.Data.length) - 1;
      bytes[i2] = 10;
    }
    if (node.Links) {
      for (let index = node.Links.length - 1; index >= 0; index--) {
        const size2 = encodeLink(node.Links[index], bytes.subarray(0, i2));
        i2 -= size2;
        i2 = encodeVarint(bytes, i2, size2) - 1;
        bytes[i2] = 18;
      }
    }
    return bytes;
  }
  function sizeLink(link) {
    let n2 = 0;
    if (link.Hash) {
      const l2 = link.Hash.length;
      n2 += 1 + l2 + sov(l2);
    }
    if (typeof link.Name === "string") {
      const l2 = textEncoder3.encode(link.Name).length;
      n2 += 1 + l2 + sov(l2);
    }
    if (typeof link.Tsize === "number") {
      n2 += 1 + sov(link.Tsize);
    }
    return n2;
  }
  function sizeNode(node) {
    let n2 = 0;
    if (node.Data) {
      const l2 = node.Data.length;
      n2 += 1 + l2 + sov(l2);
    }
    if (node.Links) {
      for (const link of node.Links) {
        const l2 = sizeLink(link);
        n2 += 1 + l2 + sov(l2);
      }
    }
    return n2;
  }
  function encodeVarint(bytes, offset, v2) {
    offset -= sov(v2);
    const base7 = offset;
    while (v2 >= maxUInt32) {
      bytes[offset++] = v2 & 127 | 128;
      v2 /= 128;
    }
    while (v2 >= 128) {
      bytes[offset++] = v2 & 127 | 128;
      v2 >>>= 7;
    }
    bytes[offset] = v2;
    return base7;
  }
  function sov(x2) {
    if (x2 % 2 === 0) {
      x2++;
    }
    return Math.floor((len64(x2) + 6) / 7);
  }
  function len64(x2) {
    let n2 = 0;
    if (x2 >= maxInt32) {
      x2 = Math.floor(x2 / maxInt32);
      n2 = 32;
    }
    if (x2 >= 1 << 16) {
      x2 >>>= 16;
      n2 += 16;
    }
    if (x2 >= 1 << 8) {
      x2 >>>= 8;
      n2 += 8;
    }
    return n2 + len8tab[x2];
  }
  var len8tab = [
    0,
    1,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8
  ];

  // node_modules/@ipld/dag-pb/esm/src/util.js
  init_virtual_process_polyfill();
  var pbNodeProperties = [
    "Data",
    "Links"
  ];
  var pbLinkProperties = [
    "Hash",
    "Name",
    "Tsize"
  ];
  var textEncoder4 = new TextEncoder();
  function linkComparator(a2, b2) {
    if (a2 === b2) {
      return 0;
    }
    const abuf = a2.Name ? textEncoder4.encode(a2.Name) : [];
    const bbuf = b2.Name ? textEncoder4.encode(b2.Name) : [];
    let x2 = abuf.length;
    let y2 = bbuf.length;
    for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
      if (abuf[i2] !== bbuf[i2]) {
        x2 = abuf[i2];
        y2 = bbuf[i2];
        break;
      }
    }
    return x2 < y2 ? -1 : y2 < x2 ? 1 : 0;
  }
  function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p2) => !properties.includes(p2));
  }
  function asLink(link) {
    if (typeof link.asCID === "object") {
      const Hash = CID3.asCID(link);
      if (!Hash) {
        throw new TypeError("Invalid DAG-PB form");
      }
      return { Hash };
    }
    if (typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form");
    }
    const pbl = {};
    if (link.Hash) {
      let cid = CID3.asCID(link.Hash);
      try {
        if (!cid) {
          if (typeof link.Hash === "string") {
            cid = CID3.parse(link.Hash);
          } else if (link.Hash instanceof Uint8Array) {
            cid = CID3.decode(link.Hash);
          }
        }
      } catch (e2) {
        throw new TypeError(`Invalid DAG-PB form: ${e2.message}`);
      }
      if (cid) {
        pbl.Hash = cid;
      }
    }
    if (!pbl.Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    if (typeof link.Name === "string") {
      pbl.Name = link.Name;
    }
    if (typeof link.Tsize === "number") {
      pbl.Tsize = link.Tsize;
    }
    return pbl;
  }
  function prepare(node) {
    if (node instanceof Uint8Array || typeof node === "string") {
      node = { Data: node };
    }
    if (typeof node !== "object" || Array.isArray(node)) {
      throw new TypeError("Invalid DAG-PB form");
    }
    const pbn = {};
    if (node.Data !== void 0) {
      if (typeof node.Data === "string") {
        pbn.Data = textEncoder4.encode(node.Data);
      } else if (node.Data instanceof Uint8Array) {
        pbn.Data = node.Data;
      } else {
        throw new TypeError("Invalid DAG-PB form");
      }
    }
    if (node.Links !== void 0) {
      if (Array.isArray(node.Links)) {
        pbn.Links = node.Links.map(asLink);
        pbn.Links.sort(linkComparator);
      } else {
        throw new TypeError("Invalid DAG-PB form");
      }
    } else {
      pbn.Links = [];
    }
    return pbn;
  }
  function validate(node) {
    if (!node || typeof node !== "object" || Array.isArray(node)) {
      throw new TypeError("Invalid DAG-PB form");
    }
    if (!hasOnlyProperties(node, pbNodeProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties)");
    }
    if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
      throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
    }
    if (!Array.isArray(node.Links)) {
      throw new TypeError("Invalid DAG-PB form (Links must be an array)");
    }
    for (let i2 = 0; i2 < node.Links.length; i2++) {
      const link = node.Links[i2];
      if (!link || typeof link !== "object" || Array.isArray(link)) {
        throw new TypeError("Invalid DAG-PB form (bad link object)");
      }
      if (!hasOnlyProperties(link, pbLinkProperties)) {
        throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
      }
      if (!link.Hash) {
        throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
      }
      if (link.Hash.asCID !== link.Hash) {
        throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
      }
      if (link.Name !== void 0 && typeof link.Name !== "string") {
        throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
      }
      if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (i2 > 0 && linkComparator(link, node.Links[i2 - 1]) === -1) {
        throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
      }
    }
  }
  function createNode(data, links2 = []) {
    return prepare({
      Data: data,
      Links: links2
    });
  }
  function createLink(name6, size, cid) {
    return asLink({
      Hash: cid,
      Name: name6,
      Tsize: size
    });
  }

  // node_modules/@ipld/dag-pb/esm/src/index.js
  var name2 = "dag-pb";
  var code2 = 112;
  function encode10(node) {
    validate(node);
    const pbn = {};
    if (node.Links) {
      pbn.Links = node.Links.map((l2) => {
        const link = {};
        if (l2.Hash) {
          link.Hash = l2.Hash.bytes;
        }
        if (l2.Name !== void 0) {
          link.Name = l2.Name;
        }
        if (l2.Tsize !== void 0) {
          link.Tsize = l2.Tsize;
        }
        return link;
      });
    }
    if (node.Data) {
      pbn.Data = node.Data;
    }
    return encodeNode(pbn);
  }
  function decode16(bytes) {
    const pbn = decodeNode(bytes);
    const node = {};
    if (pbn.Data) {
      node.Data = pbn.Data;
    }
    if (pbn.Links) {
      node.Links = pbn.Links.map((l2) => {
        const link = {};
        try {
          link.Hash = CID3.decode(l2.Hash);
        } catch (e2) {
        }
        if (!link.Hash) {
          throw new Error("Invalid Hash field found in link, expected CID");
        }
        if (l2.Name !== void 0) {
          link.Name = l2.Name;
        }
        if (l2.Tsize !== void 0) {
          link.Tsize = l2.Tsize;
        }
        return link;
      });
    }
    return node;
  }

  // node_modules/ipfs-unixfs-exporter/node_modules/@ipld/dag-cbor/esm/index.js
  init_virtual_process_polyfill();
  var CID_CBOR_TAG2 = 42;
  function cidDecoder2(bytes) {
    if (bytes[0] !== 0) {
      throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
    }
    return CID2.decode(bytes.subarray(1));
  }
  var decodeOptions2 = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    strict: true,
    useMaps: false,
    tags: []
  };
  decodeOptions2.tags[CID_CBOR_TAG2] = cidDecoder2;
  var code3 = 113;
  var decode17 = (data) => decode6(data, decodeOptions2);

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/codecs/raw.js
  init_virtual_process_polyfill();
  var code4 = 85;

  // node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/hashes/identity.js
  init_virtual_process_polyfill();
  var code5 = 0;
  var name3 = "identity";
  var encode11 = coerce2;
  var digest = (input) => create2(code5, encode11(input));
  var identity = {
    code: code5,
    name: name3,
    encode: encode11,
    digest
  };

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
  init_virtual_process_polyfill();
  var import_err_code4 = __toESM(require_err_code(), 1);

  // node_modules/ipfs-unixfs/esm/src/index.js
  init_virtual_process_polyfill();
  var import_err_code = __toESM(require_err_code(), 1);

  // node_modules/ipfs-unixfs/esm/src/unixfs.js
  init_virtual_process_polyfill();
  var import_minimal = __toESM(require_minimal2(), 1);
  var $Reader = import_minimal.default.Reader;
  var $Writer = import_minimal.default.Writer;
  var $util = import_minimal.default.util;
  var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
  var Data = $root.Data = (() => {
    function Data2(p2) {
      this.blocksizes = [];
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    Data2.prototype.Type = 0;
    Data2.prototype.Data = $util.newBuffer([]);
    Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data2.prototype.blocksizes = $util.emptyArray;
    Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data2.prototype.mode = 0;
    Data2.prototype.mtime = null;
    Data2.encode = function encode21(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      w2.uint32(8).int32(m2.Type);
      if (m2.Data != null && Object.hasOwnProperty.call(m2, "Data"))
        w2.uint32(18).bytes(m2.Data);
      if (m2.filesize != null && Object.hasOwnProperty.call(m2, "filesize"))
        w2.uint32(24).uint64(m2.filesize);
      if (m2.blocksizes != null && m2.blocksizes.length) {
        for (var i2 = 0; i2 < m2.blocksizes.length; ++i2)
          w2.uint32(32).uint64(m2.blocksizes[i2]);
      }
      if (m2.hashType != null && Object.hasOwnProperty.call(m2, "hashType"))
        w2.uint32(40).uint64(m2.hashType);
      if (m2.fanout != null && Object.hasOwnProperty.call(m2, "fanout"))
        w2.uint32(48).uint64(m2.fanout);
      if (m2.mode != null && Object.hasOwnProperty.call(m2, "mode"))
        w2.uint32(56).uint32(m2.mode);
      if (m2.mtime != null && Object.hasOwnProperty.call(m2, "mtime"))
        $root.UnixTime.encode(m2.mtime, w2.uint32(66).fork()).ldelim();
      return w2;
    };
    Data2.decode = function decode32(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Data();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 1:
            m2.Type = r2.int32();
            break;
          case 2:
            m2.Data = r2.bytes();
            break;
          case 3:
            m2.filesize = r2.uint64();
            break;
          case 4:
            if (!(m2.blocksizes && m2.blocksizes.length))
              m2.blocksizes = [];
            if ((t2 & 7) === 2) {
              var c22 = r2.uint32() + r2.pos;
              while (r2.pos < c22)
                m2.blocksizes.push(r2.uint64());
            } else
              m2.blocksizes.push(r2.uint64());
            break;
          case 5:
            m2.hashType = r2.uint64();
            break;
          case 6:
            m2.fanout = r2.uint64();
            break;
          case 7:
            m2.mode = r2.uint32();
            break;
          case 8:
            m2.mtime = $root.UnixTime.decode(r2, r2.uint32());
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      if (!m2.hasOwnProperty("Type"))
        throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
      return m2;
    };
    Data2.fromObject = function fromObject2(d2) {
      if (d2 instanceof $root.Data)
        return d2;
      var m2 = new $root.Data();
      switch (d2.Type) {
        case "Raw":
        case 0:
          m2.Type = 0;
          break;
        case "Directory":
        case 1:
          m2.Type = 1;
          break;
        case "File":
        case 2:
          m2.Type = 2;
          break;
        case "Metadata":
        case 3:
          m2.Type = 3;
          break;
        case "Symlink":
        case 4:
          m2.Type = 4;
          break;
        case "HAMTShard":
        case 5:
          m2.Type = 5;
          break;
      }
      if (d2.Data != null) {
        if (typeof d2.Data === "string")
          $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
        else if (d2.Data.length)
          m2.Data = d2.Data;
      }
      if (d2.filesize != null) {
        if ($util.Long)
          (m2.filesize = $util.Long.fromValue(d2.filesize)).unsigned = true;
        else if (typeof d2.filesize === "string")
          m2.filesize = parseInt(d2.filesize, 10);
        else if (typeof d2.filesize === "number")
          m2.filesize = d2.filesize;
        else if (typeof d2.filesize === "object")
          m2.filesize = new $util.LongBits(d2.filesize.low >>> 0, d2.filesize.high >>> 0).toNumber(true);
      }
      if (d2.blocksizes) {
        if (!Array.isArray(d2.blocksizes))
          throw TypeError(".Data.blocksizes: array expected");
        m2.blocksizes = [];
        for (var i2 = 0; i2 < d2.blocksizes.length; ++i2) {
          if ($util.Long)
            (m2.blocksizes[i2] = $util.Long.fromValue(d2.blocksizes[i2])).unsigned = true;
          else if (typeof d2.blocksizes[i2] === "string")
            m2.blocksizes[i2] = parseInt(d2.blocksizes[i2], 10);
          else if (typeof d2.blocksizes[i2] === "number")
            m2.blocksizes[i2] = d2.blocksizes[i2];
          else if (typeof d2.blocksizes[i2] === "object")
            m2.blocksizes[i2] = new $util.LongBits(d2.blocksizes[i2].low >>> 0, d2.blocksizes[i2].high >>> 0).toNumber(true);
        }
      }
      if (d2.hashType != null) {
        if ($util.Long)
          (m2.hashType = $util.Long.fromValue(d2.hashType)).unsigned = true;
        else if (typeof d2.hashType === "string")
          m2.hashType = parseInt(d2.hashType, 10);
        else if (typeof d2.hashType === "number")
          m2.hashType = d2.hashType;
        else if (typeof d2.hashType === "object")
          m2.hashType = new $util.LongBits(d2.hashType.low >>> 0, d2.hashType.high >>> 0).toNumber(true);
      }
      if (d2.fanout != null) {
        if ($util.Long)
          (m2.fanout = $util.Long.fromValue(d2.fanout)).unsigned = true;
        else if (typeof d2.fanout === "string")
          m2.fanout = parseInt(d2.fanout, 10);
        else if (typeof d2.fanout === "number")
          m2.fanout = d2.fanout;
        else if (typeof d2.fanout === "object")
          m2.fanout = new $util.LongBits(d2.fanout.low >>> 0, d2.fanout.high >>> 0).toNumber(true);
      }
      if (d2.mode != null) {
        m2.mode = d2.mode >>> 0;
      }
      if (d2.mtime != null) {
        if (typeof d2.mtime !== "object")
          throw TypeError(".Data.mtime: object expected");
        m2.mtime = $root.UnixTime.fromObject(d2.mtime);
      }
      return m2;
    };
    Data2.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.arrays || o2.defaults) {
        d2.blocksizes = [];
      }
      if (o2.defaults) {
        d2.Type = o2.enums === String ? "Raw" : 0;
        if (o2.bytes === String)
          d2.Data = "";
        else {
          d2.Data = [];
          if (o2.bytes !== Array)
            d2.Data = $util.newBuffer(d2.Data);
        }
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, true);
          d2.filesize = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.filesize = o2.longs === String ? "0" : 0;
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, true);
          d2.hashType = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.hashType = o2.longs === String ? "0" : 0;
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, true);
          d2.fanout = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.fanout = o2.longs === String ? "0" : 0;
        d2.mode = 0;
        d2.mtime = null;
      }
      if (m2.Type != null && m2.hasOwnProperty("Type")) {
        d2.Type = o2.enums === String ? $root.Data.DataType[m2.Type] : m2.Type;
      }
      if (m2.Data != null && m2.hasOwnProperty("Data")) {
        d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
      }
      if (m2.filesize != null && m2.hasOwnProperty("filesize")) {
        if (typeof m2.filesize === "number")
          d2.filesize = o2.longs === String ? String(m2.filesize) : m2.filesize;
        else
          d2.filesize = o2.longs === String ? $util.Long.prototype.toString.call(m2.filesize) : o2.longs === Number ? new $util.LongBits(m2.filesize.low >>> 0, m2.filesize.high >>> 0).toNumber(true) : m2.filesize;
      }
      if (m2.blocksizes && m2.blocksizes.length) {
        d2.blocksizes = [];
        for (var j2 = 0; j2 < m2.blocksizes.length; ++j2) {
          if (typeof m2.blocksizes[j2] === "number")
            d2.blocksizes[j2] = o2.longs === String ? String(m2.blocksizes[j2]) : m2.blocksizes[j2];
          else
            d2.blocksizes[j2] = o2.longs === String ? $util.Long.prototype.toString.call(m2.blocksizes[j2]) : o2.longs === Number ? new $util.LongBits(m2.blocksizes[j2].low >>> 0, m2.blocksizes[j2].high >>> 0).toNumber(true) : m2.blocksizes[j2];
        }
      }
      if (m2.hashType != null && m2.hasOwnProperty("hashType")) {
        if (typeof m2.hashType === "number")
          d2.hashType = o2.longs === String ? String(m2.hashType) : m2.hashType;
        else
          d2.hashType = o2.longs === String ? $util.Long.prototype.toString.call(m2.hashType) : o2.longs === Number ? new $util.LongBits(m2.hashType.low >>> 0, m2.hashType.high >>> 0).toNumber(true) : m2.hashType;
      }
      if (m2.fanout != null && m2.hasOwnProperty("fanout")) {
        if (typeof m2.fanout === "number")
          d2.fanout = o2.longs === String ? String(m2.fanout) : m2.fanout;
        else
          d2.fanout = o2.longs === String ? $util.Long.prototype.toString.call(m2.fanout) : o2.longs === Number ? new $util.LongBits(m2.fanout.low >>> 0, m2.fanout.high >>> 0).toNumber(true) : m2.fanout;
      }
      if (m2.mode != null && m2.hasOwnProperty("mode")) {
        d2.mode = m2.mode;
      }
      if (m2.mtime != null && m2.hasOwnProperty("mtime")) {
        d2.mtime = $root.UnixTime.toObject(m2.mtime, o2);
      }
      return d2;
    };
    Data2.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
    };
    Data2.DataType = function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "Raw"] = 0;
      values[valuesById[1] = "Directory"] = 1;
      values[valuesById[2] = "File"] = 2;
      values[valuesById[3] = "Metadata"] = 3;
      values[valuesById[4] = "Symlink"] = 4;
      values[valuesById[5] = "HAMTShard"] = 5;
      return values;
    }();
    return Data2;
  })();
  var UnixTime = $root.UnixTime = (() => {
    function UnixTime2(p2) {
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    UnixTime2.prototype.FractionalNanoseconds = 0;
    UnixTime2.encode = function encode21(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      w2.uint32(8).int64(m2.Seconds);
      if (m2.FractionalNanoseconds != null && Object.hasOwnProperty.call(m2, "FractionalNanoseconds"))
        w2.uint32(21).fixed32(m2.FractionalNanoseconds);
      return w2;
    };
    UnixTime2.decode = function decode32(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.UnixTime();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 1:
            m2.Seconds = r2.int64();
            break;
          case 2:
            m2.FractionalNanoseconds = r2.fixed32();
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      if (!m2.hasOwnProperty("Seconds"))
        throw $util.ProtocolError("missing required 'Seconds'", { instance: m2 });
      return m2;
    };
    UnixTime2.fromObject = function fromObject2(d2) {
      if (d2 instanceof $root.UnixTime)
        return d2;
      var m2 = new $root.UnixTime();
      if (d2.Seconds != null) {
        if ($util.Long)
          (m2.Seconds = $util.Long.fromValue(d2.Seconds)).unsigned = false;
        else if (typeof d2.Seconds === "string")
          m2.Seconds = parseInt(d2.Seconds, 10);
        else if (typeof d2.Seconds === "number")
          m2.Seconds = d2.Seconds;
        else if (typeof d2.Seconds === "object")
          m2.Seconds = new $util.LongBits(d2.Seconds.low >>> 0, d2.Seconds.high >>> 0).toNumber();
      }
      if (d2.FractionalNanoseconds != null) {
        m2.FractionalNanoseconds = d2.FractionalNanoseconds >>> 0;
      }
      return m2;
    };
    UnixTime2.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.defaults) {
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, false);
          d2.Seconds = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.Seconds = o2.longs === String ? "0" : 0;
        d2.FractionalNanoseconds = 0;
      }
      if (m2.Seconds != null && m2.hasOwnProperty("Seconds")) {
        if (typeof m2.Seconds === "number")
          d2.Seconds = o2.longs === String ? String(m2.Seconds) : m2.Seconds;
        else
          d2.Seconds = o2.longs === String ? $util.Long.prototype.toString.call(m2.Seconds) : o2.longs === Number ? new $util.LongBits(m2.Seconds.low >>> 0, m2.Seconds.high >>> 0).toNumber() : m2.Seconds;
      }
      if (m2.FractionalNanoseconds != null && m2.hasOwnProperty("FractionalNanoseconds")) {
        d2.FractionalNanoseconds = m2.FractionalNanoseconds;
      }
      return d2;
    };
    UnixTime2.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
    };
    return UnixTime2;
  })();
  var Metadata = $root.Metadata = (() => {
    function Metadata2(p2) {
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    Metadata2.prototype.MimeType = "";
    Metadata2.encode = function encode21(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      if (m2.MimeType != null && Object.hasOwnProperty.call(m2, "MimeType"))
        w2.uint32(10).string(m2.MimeType);
      return w2;
    };
    Metadata2.decode = function decode32(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Metadata();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 1:
            m2.MimeType = r2.string();
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      return m2;
    };
    Metadata2.fromObject = function fromObject2(d2) {
      if (d2 instanceof $root.Metadata)
        return d2;
      var m2 = new $root.Metadata();
      if (d2.MimeType != null) {
        m2.MimeType = String(d2.MimeType);
      }
      return m2;
    };
    Metadata2.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.defaults) {
        d2.MimeType = "";
      }
      if (m2.MimeType != null && m2.hasOwnProperty("MimeType")) {
        d2.MimeType = m2.MimeType;
      }
      return d2;
    };
    Metadata2.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
    };
    return Metadata2;
  })();

  // node_modules/ipfs-unixfs/esm/src/index.js
  var PBData = Data;
  var types = [
    "raw",
    "directory",
    "file",
    "metadata",
    "symlink",
    "hamt-sharded-directory"
  ];
  var dirTypes = [
    "directory",
    "hamt-sharded-directory"
  ];
  var DEFAULT_FILE_MODE = parseInt("0644", 8);
  var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
  function parseMode(mode) {
    if (mode == null) {
      return void 0;
    }
    if (typeof mode === "number") {
      return mode & 4095;
    }
    mode = mode.toString();
    if (mode.substring(0, 1) === "0") {
      return parseInt(mode, 8) & 4095;
    }
    return parseInt(mode, 10) & 4095;
  }
  function parseMtime(input) {
    if (input == null) {
      return void 0;
    }
    let mtime;
    if (input.secs != null) {
      mtime = {
        secs: input.secs,
        nsecs: input.nsecs
      };
    }
    if (input.Seconds != null) {
      mtime = {
        secs: input.Seconds,
        nsecs: input.FractionalNanoseconds
      };
    }
    if (Array.isArray(input)) {
      mtime = {
        secs: input[0],
        nsecs: input[1]
      };
    }
    if (input instanceof Date) {
      const ms = input.getTime();
      const secs = Math.floor(ms / 1e3);
      mtime = {
        secs,
        nsecs: (ms - secs * 1e3) * 1e3
      };
    }
    if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
      return void 0;
    }
    if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
      throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
    }
    return mtime;
  }
  var UnixFS = class {
    static unmarshal(marshaled) {
      const message = PBData.decode(marshaled);
      const decoded = PBData.toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
      });
      const data = new UnixFS({
        type: types[decoded.Type],
        data: decoded.Data,
        blockSizes: decoded.blocksizes,
        mode: decoded.mode,
        mtime: decoded.mtime ? {
          secs: decoded.mtime.Seconds,
          nsecs: decoded.mtime.FractionalNanoseconds
        } : void 0
      });
      data._originalMode = decoded.mode || 0;
      return data;
    }
    constructor(options = { type: "file" }) {
      const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
      if (type && !types.includes(type)) {
        throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
      }
      this.type = type || "file";
      this.data = data;
      this.hashType = hashType;
      this.fanout = fanout;
      this.blockSizes = blockSizes || [];
      this._originalMode = 0;
      this.mode = parseMode(mode);
      if (mtime) {
        this.mtime = parseMtime(mtime);
        if (this.mtime && !this.mtime.nsecs) {
          this.mtime.nsecs = 0;
        }
      }
    }
    set mode(mode) {
      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
      const parsedMode = parseMode(mode);
      if (parsedMode !== void 0) {
        this._mode = parsedMode;
      }
    }
    get mode() {
      return this._mode;
    }
    isDirectory() {
      return Boolean(this.type && dirTypes.includes(this.type));
    }
    addBlockSize(size) {
      this.blockSizes.push(size);
    }
    removeBlockSize(index) {
      this.blockSizes.splice(index, 1);
    }
    fileSize() {
      if (this.isDirectory()) {
        return 0;
      }
      let sum = 0;
      this.blockSizes.forEach((size) => {
        sum += size;
      });
      if (this.data) {
        sum += this.data.length;
      }
      return sum;
    }
    marshal() {
      let type;
      switch (this.type) {
        case "raw":
          type = PBData.DataType.Raw;
          break;
        case "directory":
          type = PBData.DataType.Directory;
          break;
        case "file":
          type = PBData.DataType.File;
          break;
        case "metadata":
          type = PBData.DataType.Metadata;
          break;
        case "symlink":
          type = PBData.DataType.Symlink;
          break;
        case "hamt-sharded-directory":
          type = PBData.DataType.HAMTShard;
          break;
        default:
          throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
      }
      let data = this.data;
      if (!this.data || !this.data.length) {
        data = void 0;
      }
      let mode;
      if (this.mode != null) {
        mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
        if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
          mode = void 0;
        }
        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
          mode = void 0;
        }
      }
      let mtime;
      if (this.mtime != null) {
        const parsed = parseMtime(this.mtime);
        if (parsed) {
          mtime = {
            Seconds: parsed.secs,
            FractionalNanoseconds: parsed.nsecs
          };
          if (mtime.FractionalNanoseconds === 0) {
            delete mtime.FractionalNanoseconds;
          }
        }
      }
      const pbData = {
        Type: type,
        Data: data,
        filesize: this.isDirectory() ? void 0 : this.fileSize(),
        blocksizes: this.blockSizes,
        hashType: this.hashType,
        fanout: this.fanout,
        mode,
        mtime
      };
      return PBData.encode(pbData).finish();
    }
  };

  // node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js
  init_virtual_process_polyfill();
  var import_hamt_sharding = __toESM(require_src(), 1);

  // node_modules/@multiformats/murmur3/esm/index.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/hashes/hasher.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/hashes/digest.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bytes.js
  var bytes_exports4 = {};
  __export(bytes_exports4, {
    coerce: () => coerce5,
    empty: () => empty5,
    equals: () => equals10,
    fromHex: () => fromHex,
    fromString: () => fromString5,
    isBinary: () => isBinary,
    toHex: () => toHex2,
    toString: () => toString5
  });
  init_virtual_process_polyfill();
  var empty5 = new Uint8Array(0);
  var toHex2 = (d2) => d2.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
  var fromHex = (hex) => {
    const hexes = hex.match(/../g);
    return hexes ? new Uint8Array(hexes.map((b2) => parseInt(b2, 16))) : empty5;
  };
  var equals10 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce5 = (o2) => {
    if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
      return o2;
    if (o2 instanceof ArrayBuffer)
      return new Uint8Array(o2);
    if (ArrayBuffer.isView(o2)) {
      return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var isBinary = (o2) => o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
  var fromString5 = (str) => new TextEncoder().encode(str);
  var toString5 = (b2) => new TextDecoder().decode(b2);

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/varint.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/vendor/varint.js
  init_virtual_process_polyfill();
  var encode_15 = encode16;
  var MSB5 = 128;
  var REST5 = 127;
  var MSBALL5 = ~REST5;
  var INT5 = Math.pow(2, 31);
  function encode16(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT5) {
      out[offset++] = num & 255 | MSB5;
      num /= 128;
    }
    while (num & MSBALL5) {
      out[offset++] = num & 255 | MSB5;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode16.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode23 = read6;
  var MSB$15 = 128;
  var REST$15 = 127;
  function read6(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
    do {
      if (counter >= l2) {
        read6.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b2 = buf2[counter++];
      res += shift < 28 ? (b2 & REST$15) << shift : (b2 & REST$15) * Math.pow(2, shift);
      shift += 7;
    } while (b2 >= MSB$15);
    read6.bytes = counter - offset;
    return res;
  }
  var N15 = Math.pow(2, 7);
  var N25 = Math.pow(2, 14);
  var N35 = Math.pow(2, 21);
  var N45 = Math.pow(2, 28);
  var N55 = Math.pow(2, 35);
  var N65 = Math.pow(2, 42);
  var N75 = Math.pow(2, 49);
  var N85 = Math.pow(2, 56);
  var N95 = Math.pow(2, 63);
  var length5 = function(value) {
    return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
  };
  var varint5 = {
    encode: encode_15,
    decode: decode23,
    encodingLength: length5
  };
  var _brrp_varint5 = varint5;
  var varint_default5 = _brrp_varint5;

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/varint.js
  var decode24 = (data, offset = 0) => {
    const code8 = varint_default5.decode(data, offset);
    return [
      code8,
      varint_default5.decode.bytes
    ];
  };
  var encodeTo5 = (int, target, offset = 0) => {
    varint_default5.encode(int, target, offset);
    return target;
  };
  var encodingLength5 = (int) => {
    return varint_default5.encodingLength(int);
  };

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/hashes/digest.js
  var create5 = (code8, digest3) => {
    const size = digest3.byteLength;
    const sizeOffset = encodingLength5(code8);
    const digestOffset = sizeOffset + encodingLength5(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo5(code8, bytes, 0);
    encodeTo5(size, bytes, sizeOffset);
    bytes.set(digest3, digestOffset);
    return new Digest5(code8, size, digest3, bytes);
  };
  var decode25 = (multihash) => {
    const bytes = coerce5(multihash);
    const [code8, sizeOffset] = decode24(bytes);
    const [size, digestOffset] = decode24(bytes.subarray(sizeOffset));
    const digest3 = bytes.subarray(sizeOffset + digestOffset);
    if (digest3.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest5(code8, size, digest3, bytes);
  };
  var equals11 = (a2, b2) => {
    if (a2 === b2) {
      return true;
    } else {
      return a2.code === b2.code && a2.size === b2.size && equals10(a2.bytes, b2.bytes);
    }
  };
  var Digest5 = class {
    constructor(code8, size, digest3, bytes) {
      this.code = code8;
      this.size = size;
      this.digest = digest3;
      this.bytes = bytes;
    }
  };

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/hashes/hasher.js
  var from8 = ({ name: name6, code: code8, encode: encode21 }) => new Hasher3(name6, code8, encode21);
  var Hasher3 = class {
    constructor(name6, code8, encode21) {
      this.name = name6;
      this.code = code8;
      this.encode = encode21;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create5(this.code, result) : result.then((digest3) => create5(this.code, digest3));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/index.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/cid.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base58.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base.js
  init_virtual_process_polyfill();

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/vendor/base-x.js
  init_virtual_process_polyfill();
  function base5(ALPHABET, name6) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
      BASE_MAP[j2] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET.length; i2++) {
      var x2 = ALPHABET.charAt(i2);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode21(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length7 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length7) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        pbegin++;
      }
      var it2 = size - length7;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length7 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length7) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length7;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j3 = zeroes;
      while (it4 !== size) {
        vch[j3++] = b256[it4++];
      }
      return vch;
    }
    function decode32(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name6} character`);
    }
    return {
      encode: encode21,
      decodeUnsafe,
      decode: decode32
    };
  }
  var src5 = base5;
  var _brrp__multiformats_scope_baseX5 = src5;
  var base_x_default5 = _brrp__multiformats_scope_baseX5;

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base.js
  var Encoder6 = class {
    constructor(name6, prefix, baseEncode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder5 = class {
    constructor(name6, prefix, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or5(this, decoder);
    }
  };
  var ComposedDecoder5 = class {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or5(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or5 = (left, right) => new ComposedDecoder5({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  var Codec5 = class {
    constructor(name6, prefix, baseEncode, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder6(name6, prefix, baseEncode);
      this.decoder = new Decoder5(name6, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from9 = ({ name: name6, prefix, encode: encode21, decode: decode32 }) => new Codec5(name6, prefix, encode21, decode32);
  var baseX5 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
    const { encode: encode21, decode: decode32 } = base_x_default5(alphabet2, name6);
    return from9({
      prefix,
      name: name6,
      encode: encode21,
      decode: (text) => coerce5(decode32(text))
    });
  };
  var decode26 = (string2, alphabet2, bitsPerChar, name6) => {
    const codes = {};
    for (let i2 = 0; i2 < alphabet2.length; ++i2) {
      codes[alphabet2[i2]] = i2;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i2 = 0; i2 < end; ++i2) {
      const value = codes[string2[i2]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name6} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode17 = (data, alphabet2, bitsPerChar) => {
    const pad2 = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      buffer2 = buffer2 << 8 | data[i2];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer2 >> bits];
      }
    }
    if (bits) {
      out += alphabet2[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad2) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc46485 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from9({
      prefix,
      name: name6,
      encode(input) {
        return encode17(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode26(input, alphabet2, bitsPerChar, name6);
      }
    });
  };

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base58.js
  var base58btc5 = baseX5({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr5 = baseX5({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base32.js
  init_virtual_process_polyfill();
  var base325 = rfc46485({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper5 = rfc46485({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad5 = rfc46485({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper5 = rfc46485({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex5 = rfc46485({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper5 = rfc46485({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad5 = rfc46485({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper5 = rfc46485({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z5 = rfc46485({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/cid.js
  var CID5 = class {
    constructor(version8, code8, multihash, bytes) {
      this.code = code8;
      this.version = version8;
      this.multihash = multihash;
      this.bytes = bytes;
      this.byteOffset = bytes.byteOffset;
      this.byteLength = bytes.byteLength;
      this.asCID = this;
      this._baseCache = /* @__PURE__ */ new Map();
      Object.defineProperties(this, {
        byteOffset: hidden4,
        byteLength: hidden4,
        code: readonly5,
        version: readonly5,
        multihash: readonly5,
        bytes: readonly5,
        _baseCache: hidden4,
        asCID: hidden4
      });
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        default: {
          const { code: code8, multihash } = this;
          if (code8 !== DAG_PB_CODE5) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE5) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID5.createV0(multihash);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code8, digest: digest3 } = this.multihash;
          const multihash = create5(code8, digest3);
          return CID5.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return other && this.code === other.code && this.version === other.version && equals11(this.multihash, other.multihash);
    }
    toString(base7) {
      const { bytes, version: version8, _baseCache } = this;
      switch (version8) {
        case 0:
          return toStringV05(bytes, _baseCache, base7 || base58btc5.encoder);
        default:
          return toStringV15(bytes, _baseCache, base7 || base325.encoder);
      }
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
      deprecate5(/^0\.0/, IS_CID_DEPRECATION4);
      return !!(value && (value[cidSymbol5] || value.asCID === value));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
      if (value instanceof CID5) {
        return value;
      } else if (value != null && value.asCID === value) {
        const { version: version8, code: code8, multihash, bytes } = value;
        return new CID5(version8, code8, multihash, bytes || encodeCID5(version8, code8, multihash.bytes));
      } else if (value != null && value[cidSymbol5] === true) {
        const { version: version8, multihash, code: code8 } = value;
        const digest3 = decode25(multihash);
        return CID5.create(version8, code8, digest3);
      } else {
        return null;
      }
    }
    static create(version8, code8, digest3) {
      if (typeof code8 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      switch (version8) {
        case 0: {
          if (code8 !== DAG_PB_CODE5) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`);
          } else {
            return new CID5(version8, code8, digest3, digest3.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID5(version8, code8, digest3.bytes);
          return new CID5(version8, code8, digest3, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest3) {
      return CID5.create(0, DAG_PB_CODE5, digest3);
    }
    static createV1(code8, digest3) {
      return CID5.create(1, code8, digest3);
    }
    static decode(bytes) {
      const [cid, remainder] = CID5.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes) {
      const specs = CID5.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce5(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest3 = new Digest5(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? CID5.createV0(digest3) : CID5.createV1(specs.codec, digest3);
      return [
        cid,
        bytes.subarray(specs.size)
      ];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i2, length7] = decode24(initialBytes.subarray(offset));
        offset += length7;
        return i2;
      };
      let version8 = next();
      let codec = DAG_PB_CODE5;
      if (version8 === 18) {
        version8 = 0;
        offset = 0;
      } else if (version8 === 1) {
        codec = next();
      }
      if (version8 !== 0 && version8 !== 1) {
        throw new RangeError(`Invalid CID version ${version8}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return {
        version: version8,
        codec,
        multihashCode,
        digestSize,
        multihashSize,
        size
      };
    }
    static parse(source, base7) {
      const [prefix, bytes] = parseCIDtoBytes5(source, base7);
      const cid = CID5.decode(bytes);
      cid._baseCache.set(prefix, source);
      return cid;
    }
  };
  var parseCIDtoBytes5 = (source, base7) => {
    switch (source[0]) {
      case "Q": {
        const decoder = base7 || base58btc5;
        return [
          base58btc5.prefix,
          decoder.decode(`${base58btc5.prefix}${source}`)
        ];
      }
      case base58btc5.prefix: {
        const decoder = base7 || base58btc5;
        return [
          base58btc5.prefix,
          decoder.decode(source)
        ];
      }
      case base325.prefix: {
        const decoder = base7 || base325;
        return [
          base325.prefix,
          decoder.decode(source)
        ];
      }
      default: {
        if (base7 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [
          source[0],
          base7.decode(source)
        ];
      }
    }
  };
  var toStringV05 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    if (prefix !== base58btc5.prefix) {
      throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV15 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE5 = 112;
  var SHA_256_CODE5 = 18;
  var encodeCID5 = (version8, code8, multihash) => {
    const codeOffset = encodingLength5(version8);
    const hashOffset = codeOffset + encodingLength5(code8);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo5(version8, bytes, 0);
    encodeTo5(code8, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");
  var readonly5 = {
    writable: false,
    configurable: false,
    enumerable: true
  };
  var hidden4 = {
    writable: false,
    enumerable: false,
    configurable: false
  };
  var version6 = "0.0.0-dev";
  var deprecate5 = (range, message) => {
    if (range.test(version6)) {
      console.warn(message);
    } else {
      throw new Error(message);
    }
  };
  var IS_CID_DEPRECATION4 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

  // node_modules/@multiformats/murmur3/esm/index.js
  var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
  function fromNumberTo32BitBuf(number) {
    const bytes = new Array(4);
    for (let i2 = 0; i2 < 4; i2++) {
      bytes[i2] = number & 255;
      number = number >> 8;
    }
    return new Uint8Array(bytes);
  }
  var murmur332 = from8({
    name: "murmur3-32",
    code: 35,
    encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
  });
  var murmur3128 = from8({
    name: "murmur3-128",
    code: 34,
    encode: (input) => bytes_exports4.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
  });

  // node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js
  var hashFn = async function(buf2) {
    return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
  };
  var addLinksToHamtBucket = (links2, bucket, rootBucket) => {
    return Promise.all(links2.map((link) => {
      if (link.Name == null) {
        throw new Error("Unexpected Link without a Name");
      }
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16);
        return bucket._putObjectAt(pos, new import_hamt_sharding.Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos));
      }
      return rootBucket.put(link.Name.substring(2), true);
    }));
  };
  var toPrefix = (position) => {
    return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
  };
  var toBucketPath = (position) => {
    let bucket = position.bucket;
    const path = [];
    while (bucket._parent) {
      path.push(bucket);
      bucket = bucket._parent;
    }
    path.push(bucket);
    return path.reverse();
  };
  var findShardCid = async (node, name6, blockstore, context, options) => {
    if (!context) {
      const rootBucket = (0, import_hamt_sharding.createHAMT)({ hashFn });
      context = {
        rootBucket,
        hamtDepth: 1,
        lastBucket: rootBucket
      };
    }
    await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
    const position = await context.rootBucket._findNewBucketAndPos(name6);
    let prefix = toPrefix(position.pos);
    const bucketPath = toBucketPath(position);
    if (bucketPath.length > context.hamtDepth) {
      context.lastBucket = bucketPath[context.hamtDepth];
      prefix = toPrefix(context.lastBucket._posAtParent);
    }
    const link = node.Links.find((link2) => {
      if (link2.Name == null) {
        return false;
      }
      const entryPrefix = link2.Name.substring(0, 2);
      const entryName = link2.Name.substring(2);
      if (entryPrefix !== prefix) {
        return false;
      }
      if (entryName && entryName !== name6) {
        return false;
      }
      return true;
    });
    if (!link) {
      return null;
    }
    if (link.Name != null && link.Name.substring(2) === name6) {
      return link.Hash;
    }
    context.hamtDepth++;
    const block = await blockstore.get(link.Hash, options);
    node = decode16(block);
    return findShardCid(node, name6, blockstore, context, options);
  };
  var find_cid_in_shard_default = findShardCid;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js
  init_virtual_process_polyfill();
  function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
    const blockLength = block.length;
    const blockEnd = blockStart + blockLength;
    if (requestedStart >= blockEnd || requestedEnd < blockStart) {
      return new Uint8Array(0);
    }
    if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
      block = block.slice(0, requestedEnd - blockStart);
    }
    if (requestedStart >= blockStart && requestedStart < blockEnd) {
      block = block.slice(requestedStart - blockStart);
    }
    return block;
  }
  var extract_data_from_block_default = extractDataFromBlock;

  // node_modules/ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js
  init_virtual_process_polyfill();
  var import_err_code2 = __toESM(require_err_code(), 1);
  var validateOffsetAndLength = (size, offset, length7) => {
    if (!offset) {
      offset = 0;
    }
    if (offset < 0) {
      throw (0, import_err_code2.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
    }
    if (offset > size) {
      throw (0, import_err_code2.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
    }
    if (!length7 && length7 !== 0) {
      length7 = size - offset;
    }
    if (length7 < 0) {
      throw (0, import_err_code2.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
    }
    if (offset + length7 > size) {
      length7 = size - offset;
    }
    return {
      offset,
      length: length7
    };
  };
  var validate_offset_and_length_default = validateOffsetAndLength;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js
  var import_err_code3 = __toESM(require_err_code(), 1);
  async function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {
    if (node instanceof Uint8Array) {
      const buf2 = extract_data_from_block_default(node, streamPosition, start, end);
      if (buf2.length) {
        yield buf2;
      }
      streamPosition += buf2.length;
      return streamPosition;
    }
    if (node.Data == null) {
      throw (0, import_err_code3.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
    }
    let file;
    try {
      file = UnixFS.unmarshal(node.Data);
    } catch (err) {
      throw (0, import_err_code3.default)(err, "ERR_NOT_UNIXFS");
    }
    if (file.data && file.data.length) {
      const buf2 = extract_data_from_block_default(file.data, streamPosition, start, end);
      if (buf2.length) {
        yield buf2;
      }
      streamPosition += file.data.length;
    }
    let childStart = streamPosition;
    for (let i2 = 0; i2 < node.Links.length; i2++) {
      const childLink = node.Links[i2];
      const childEnd = streamPosition + file.blockSizes[i2];
      if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {
        const block = await blockstore.get(childLink.Hash, { signal: options.signal });
        let child;
        switch (childLink.Hash.code) {
          case code2:
            child = await decode16(block);
            break;
          case code4:
            child = block;
            break;
          case code3:
            child = await decode17(block);
            break;
          default:
            throw Error(`Unsupported codec: ${childLink.Hash.code}`);
        }
        for await (const buf2 of emitBytes(blockstore, child, start, end, streamPosition, options)) {
          streamPosition += buf2.length;
          yield buf2;
        }
      }
      streamPosition = childEnd;
      childStart = childEnd + 1;
    }
  }
  var fileContent = (cid, node, unixfs, path, resolve5, depth, blockstore) => {
    function yieldFileContent(options = {}) {
      const fileSize = unixfs.fileSize();
      if (fileSize === void 0) {
        throw new Error("File was a directory");
      }
      const { offset, length: length7 } = validate_offset_and_length_default(fileSize, options.offset, options.length);
      const start = offset;
      const end = offset + length7;
      return emitBytes(blockstore, node, start, end, 0, options);
    }
    return yieldFileContent;
  };
  var file_default = fileContent;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js
  init_virtual_process_polyfill();
  var directoryContent = (cid, node, unixfs, path, resolve5, depth, blockstore) => {
    async function* yieldDirectoryContent(options = {}) {
      const offset = options.offset || 0;
      const length7 = options.length || node.Links.length;
      const links2 = node.Links.slice(offset, length7);
      for (const link of links2) {
        const result = await resolve5(link.Hash, link.Name || "", `${path}/${link.Name || ""}`, [], depth + 1, blockstore, options);
        if (result.entry) {
          yield result.entry;
        }
      }
    }
    return yieldDirectoryContent;
  };
  var directory_default = directoryContent;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
  init_virtual_process_polyfill();
  var hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve5, depth, blockstore) => {
    function yieldHamtDirectoryContent(options = {}) {
      return listDirectory(node, path, resolve5, depth, blockstore, options);
    }
    return yieldHamtDirectoryContent;
  };
  async function* listDirectory(node, path, resolve5, depth, blockstore, options) {
    const links2 = node.Links;
    for (const link of links2) {
      const name6 = link.Name != null ? link.Name.substring(2) : null;
      if (name6) {
        const result = await resolve5(link.Hash, name6, `${path}/${name6}`, [], depth + 1, blockstore, options);
        yield result.entry;
      } else {
        const block = await blockstore.get(link.Hash);
        node = decode16(block);
        for await (const file of listDirectory(node, path, resolve5, depth, blockstore, options)) {
          yield file;
        }
      }
    }
  }
  var hamt_sharded_directory_default = hamtShardedDirectoryContent;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
  var findLinkCid = (node, name6) => {
    const link = node.Links.find((link2) => link2.Name === name6);
    return link && link.Hash;
  };
  var contentExporters = {
    raw: file_default,
    file: file_default,
    directory: directory_default,
    "hamt-sharded-directory": hamt_sharded_directory_default,
    metadata: (cid, node, unixfs, path, resolve5, depth, blockstore) => {
      return () => [];
    },
    symlink: (cid, node, unixfs, path, resolve5, depth, blockstore) => {
      return () => [];
    }
  };
  var unixFsResolver = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
    const block = await blockstore.get(cid, options);
    const node = decode16(block);
    let unixfs;
    let next;
    if (!name6) {
      name6 = cid.toString();
    }
    if (node.Data == null) {
      throw (0, import_err_code4.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
    }
    try {
      unixfs = UnixFS.unmarshal(node.Data);
    } catch (err) {
      throw (0, import_err_code4.default)(err, "ERR_NOT_UNIXFS");
    }
    if (!path) {
      path = name6;
    }
    if (toResolve.length) {
      let linkCid;
      if (unixfs && unixfs.type === "hamt-sharded-directory") {
        linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
      } else {
        linkCid = findLinkCid(node, toResolve[0]);
      }
      if (!linkCid) {
        throw (0, import_err_code4.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
      }
      const nextName = toResolve.shift();
      const nextPath = `${path}/${nextName}`;
      next = {
        cid: linkCid,
        toResolve,
        name: nextName || "",
        path: nextPath
      };
    }
    return {
      entry: {
        type: unixfs.isDirectory() ? "directory" : "file",
        name: name6,
        path,
        cid,
        content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve5, depth, blockstore),
        unixfs,
        depth,
        node,
        size: unixfs.fileSize()
      },
      next
    };
  };
  var unixfs_v1_default = unixFsResolver;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/raw.js
  init_virtual_process_polyfill();
  var import_err_code5 = __toESM(require_err_code(), 1);
  var rawContent = (node) => {
    async function* contentGenerator(options = {}) {
      const { offset, length: length7 } = validate_offset_and_length_default(node.length, options.offset, options.length);
      yield extract_data_from_block_default(node, 0, offset, offset + length7);
    }
    return contentGenerator;
  };
  var resolve = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
    if (toResolve.length) {
      throw (0, import_err_code5.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
    }
    const block = await blockstore.get(cid, options);
    return {
      entry: {
        type: "raw",
        name: name6,
        path,
        cid,
        content: rawContent(block),
        depth,
        size: block.length,
        node: block
      }
    };
  };
  var raw_default = resolve;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js
  init_virtual_process_polyfill();
  var import_err_code6 = __toESM(require_err_code(), 1);
  var resolve2 = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
    const block = await blockstore.get(cid);
    const object = decode17(block);
    let subObject = object;
    let subPath = path;
    while (toResolve.length) {
      const prop = toResolve[0];
      if (prop in subObject) {
        toResolve.shift();
        subPath = `${subPath}/${prop}`;
        const subObjectCid = CID2.asCID(subObject[prop]);
        if (subObjectCid) {
          return {
            entry: {
              type: "object",
              name: name6,
              path,
              cid,
              node: block,
              depth,
              size: block.length,
              content: async function* () {
                yield object;
              }
            },
            next: {
              cid: subObjectCid,
              name: prop,
              path: subPath,
              toResolve
            }
          };
        }
        subObject = subObject[prop];
      } else {
        throw (0, import_err_code6.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
      }
    }
    return {
      entry: {
        type: "object",
        name: name6,
        path,
        cid,
        node: block,
        depth,
        size: block.length,
        content: async function* () {
          yield object;
        }
      }
    };
  };
  var dag_cbor_default = resolve2;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js
  init_virtual_process_polyfill();
  var import_err_code7 = __toESM(require_err_code(), 1);
  var rawContent2 = (node) => {
    async function* contentGenerator(options = {}) {
      const { offset, length: length7 } = validate_offset_and_length_default(node.length, options.offset, options.length);
      yield extract_data_from_block_default(node, 0, offset, offset + length7);
    }
    return contentGenerator;
  };
  var resolve3 = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
    if (toResolve.length) {
      throw (0, import_err_code7.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
    }
    const buf2 = await decode10(cid.multihash.bytes);
    return {
      entry: {
        type: "identity",
        name: name6,
        path,
        cid,
        content: rawContent2(buf2.digest),
        depth,
        size: buf2.digest.length,
        node: buf2.digest
      }
    };
  };
  var identity_default = resolve3;

  // node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
  var resolvers = {
    [code2]: unixfs_v1_default,
    [code4]: raw_default,
    [code3]: dag_cbor_default,
    [identity.code]: identity_default
  };
  function resolve4(cid, name6, path, toResolve, depth, blockstore, options) {
    const resolver = resolvers[cid.code];
    if (!resolver) {
      throw (0, import_err_code8.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
    }
    return resolver(cid, name6, path, toResolve, resolve4, depth, blockstore, options);
  }
  var resolvers_default = resolve4;

  // node_modules/ipfs-unixfs-exporter/esm/src/index.js
  var import_it_last = __toESM(require_it_last(), 1);
  var toPathComponents = (path = "") => {
    return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
  };
  var cidAndRest = (path) => {
    if (path instanceof Uint8Array) {
      return {
        cid: CID2.decode(path),
        toResolve: []
      };
    }
    const cid = CID2.asCID(path);
    if (cid) {
      return {
        cid,
        toResolve: []
      };
    }
    if (typeof path === "string") {
      if (path.indexOf("/ipfs/") === 0) {
        path = path.substring(6);
      }
      const output = toPathComponents(path);
      return {
        cid: CID2.parse(output[0]),
        toResolve: output.slice(1)
      };
    }
    throw (0, import_err_code9.default)(new Error(`Unknown path type ${path}`), "ERR_BAD_PATH");
  };
  async function* walkPath(path, blockstore, options = {}) {
    let { cid, toResolve } = cidAndRest(path);
    let name6 = cid.toString();
    let entryPath = name6;
    const startingDepth = toResolve.length;
    while (true) {
      const result = await resolvers_default(cid, name6, entryPath, toResolve, startingDepth, blockstore, options);
      if (!result.entry && !result.next) {
        throw (0, import_err_code9.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
      }
      if (result.entry) {
        yield result.entry;
      }
      if (!result.next) {
        return;
      }
      toResolve = result.next.toResolve;
      cid = result.next.cid;
      name6 = result.next.name;
      entryPath = result.next.path;
    }
  }
  async function exporter(path, blockstore, options = {}) {
    const result = await (0, import_it_last.default)(walkPath(path, blockstore, options));
    if (!result) {
      throw (0, import_err_code9.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
    }
    return result;
  }

  // node_modules/ipfs-unixfs-importer/esm/src/index.js
  init_virtual_process_polyfill();
  var import_it_parallel_batch2 = __toESM(require_it_parallel_batch(), 1);

  // node_modules/ipfs-unixfs-importer/esm/src/options.js
  init_virtual_process_polyfill();

  // node_modules/merge-options/index.mjs
  init_virtual_process_polyfill();
  var import_index3 = __toESM(require_merge_options(), 1);
  var merge_options_default = import_index3.default;

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/hashes/sha2-browser.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/hashes/hasher.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/hashes/digest.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/bytes.js
  init_virtual_process_polyfill();
  var empty6 = new Uint8Array(0);
  var equals12 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce6 = (o2) => {
    if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
      return o2;
    if (o2 instanceof ArrayBuffer)
      return new Uint8Array(o2);
    if (ArrayBuffer.isView(o2)) {
      return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/varint.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/vendor/varint.js
  init_virtual_process_polyfill();
  var encode_16 = encode18;
  var MSB6 = 128;
  var REST6 = 127;
  var MSBALL6 = ~REST6;
  var INT6 = Math.pow(2, 31);
  function encode18(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT6) {
      out[offset++] = num & 255 | MSB6;
      num /= 128;
    }
    while (num & MSBALL6) {
      out[offset++] = num & 255 | MSB6;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode18.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode27 = read7;
  var MSB$16 = 128;
  var REST$16 = 127;
  function read7(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
    do {
      if (counter >= l2) {
        read7.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b2 = buf2[counter++];
      res += shift < 28 ? (b2 & REST$16) << shift : (b2 & REST$16) * Math.pow(2, shift);
      shift += 7;
    } while (b2 >= MSB$16);
    read7.bytes = counter - offset;
    return res;
  }
  var N16 = Math.pow(2, 7);
  var N26 = Math.pow(2, 14);
  var N36 = Math.pow(2, 21);
  var N46 = Math.pow(2, 28);
  var N56 = Math.pow(2, 35);
  var N66 = Math.pow(2, 42);
  var N76 = Math.pow(2, 49);
  var N86 = Math.pow(2, 56);
  var N96 = Math.pow(2, 63);
  var length6 = function(value) {
    return value < N16 ? 1 : value < N26 ? 2 : value < N36 ? 3 : value < N46 ? 4 : value < N56 ? 5 : value < N66 ? 6 : value < N76 ? 7 : value < N86 ? 8 : value < N96 ? 9 : 10;
  };
  var varint6 = {
    encode: encode_16,
    decode: decode27,
    encodingLength: length6
  };
  var _brrp_varint6 = varint6;
  var varint_default6 = _brrp_varint6;

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/varint.js
  var decode28 = (data, offset = 0) => {
    const code8 = varint_default6.decode(data, offset);
    return [
      code8,
      varint_default6.decode.bytes
    ];
  };
  var encodeTo6 = (int, target, offset = 0) => {
    varint_default6.encode(int, target, offset);
    return target;
  };
  var encodingLength6 = (int) => {
    return varint_default6.encodingLength(int);
  };

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/hashes/digest.js
  var create6 = (code8, digest3) => {
    const size = digest3.byteLength;
    const sizeOffset = encodingLength6(code8);
    const digestOffset = sizeOffset + encodingLength6(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo6(code8, bytes, 0);
    encodeTo6(size, bytes, sizeOffset);
    bytes.set(digest3, digestOffset);
    return new Digest6(code8, size, digest3, bytes);
  };
  var decode29 = (multihash) => {
    const bytes = coerce6(multihash);
    const [code8, sizeOffset] = decode28(bytes);
    const [size, digestOffset] = decode28(bytes.subarray(sizeOffset));
    const digest3 = bytes.subarray(sizeOffset + digestOffset);
    if (digest3.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest6(code8, size, digest3, bytes);
  };
  var equals13 = (a2, b2) => {
    if (a2 === b2) {
      return true;
    } else {
      return a2.code === b2.code && a2.size === b2.size && equals12(a2.bytes, b2.bytes);
    }
  };
  var Digest6 = class {
    constructor(code8, size, digest3, bytes) {
      this.code = code8;
      this.size = size;
      this.digest = digest3;
      this.bytes = bytes;
    }
  };

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/hashes/hasher.js
  var from10 = ({ name: name6, code: code8, encode: encode21 }) => new Hasher4(name6, code8, encode21);
  var Hasher4 = class {
    constructor(name6, code8, encode21) {
      this.name = name6;
      this.code = code8;
      this.encode = encode21;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create6(this.code, result) : result.then((digest3) => create6(this.code, digest3));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/hashes/sha2-browser.js
  var sha2 = (name6) => async (data) => new Uint8Array(await crypto.subtle.digest(name6, data));
  var sha2562 = from10({
    name: "sha2-256",
    code: 18,
    encode: sha2("SHA-256")
  });
  var sha5122 = from10({
    name: "sha2-512",
    code: 19,
    encode: sha2("SHA-512")
  });

  // node_modules/ipfs-unixfs-importer/esm/src/options.js
  async function hamtHashFn(buf2) {
    return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
  }
  var defaultOptions = {
    chunker: "fixed",
    strategy: "balanced",
    rawLeaves: false,
    onlyHash: false,
    reduceSingleLeafToSelf: true,
    hasher: sha2562,
    leafType: "file",
    cidVersion: 0,
    progress: () => () => {
    },
    shardSplitThreshold: 1e3,
    fileImportConcurrency: 50,
    blockWriteConcurrency: 10,
    minChunkSize: 262144,
    maxChunkSize: 262144,
    avgChunkSize: 262144,
    window: 16,
    polynomial: 17437180132763652,
    maxChildrenPerNode: 174,
    layerRepeat: 4,
    wrapWithDirectory: false,
    recursive: false,
    hidden: false,
    timeout: void 0,
    hamtHashFn,
    hamtHashCode: 34,
    hamtBucketBits: 8
  };
  var options_default = (options = {}) => {
    const defaults = merge_options_default.bind({ ignoreUndefined: true });
    return defaults(defaultOptions, options);
  };

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/cid.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/bases/base58.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/bases/base.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/vendor/base-x.js
  init_virtual_process_polyfill();
  function base6(ALPHABET, name6) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
      BASE_MAP[j2] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET.length; i2++) {
      var x2 = ALPHABET.charAt(i2);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode21(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length7 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length7) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        pbegin++;
      }
      var it2 = size - length7;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length7 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length7) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length7 = i3;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length7;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j3 = zeroes;
      while (it4 !== size) {
        vch[j3++] = b256[it4++];
      }
      return vch;
    }
    function decode32(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name6} character`);
    }
    return {
      encode: encode21,
      decodeUnsafe,
      decode: decode32
    };
  }
  var src6 = base6;
  var _brrp__multiformats_scope_baseX6 = src6;
  var base_x_default6 = _brrp__multiformats_scope_baseX6;

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/bases/base.js
  var Encoder7 = class {
    constructor(name6, prefix, baseEncode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder6 = class {
    constructor(name6, prefix, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or6(this, decoder);
    }
  };
  var ComposedDecoder6 = class {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or6(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or6 = (left, right) => new ComposedDecoder6({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  var Codec6 = class {
    constructor(name6, prefix, baseEncode, baseDecode) {
      this.name = name6;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder7(name6, prefix, baseEncode);
      this.decoder = new Decoder6(name6, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from11 = ({ name: name6, prefix, encode: encode21, decode: decode32 }) => new Codec6(name6, prefix, encode21, decode32);
  var baseX6 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
    const { encode: encode21, decode: decode32 } = base_x_default6(alphabet2, name6);
    return from11({
      prefix,
      name: name6,
      encode: encode21,
      decode: (text) => coerce6(decode32(text))
    });
  };
  var decode30 = (string2, alphabet2, bitsPerChar, name6) => {
    const codes = {};
    for (let i2 = 0; i2 < alphabet2.length; ++i2) {
      codes[alphabet2[i2]] = i2;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i2 = 0; i2 < end; ++i2) {
      const value = codes[string2[i2]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name6} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode19 = (data, alphabet2, bitsPerChar) => {
    const pad2 = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      buffer2 = buffer2 << 8 | data[i2];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer2 >> bits];
      }
    }
    if (bits) {
      out += alphabet2[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad2) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc46486 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from11({
      prefix,
      name: name6,
      encode(input) {
        return encode19(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode30(input, alphabet2, bitsPerChar, name6);
      }
    });
  };

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/bases/base58.js
  var base58btc6 = baseX6({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr6 = baseX6({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/bases/base32.js
  init_virtual_process_polyfill();
  var base326 = rfc46486({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper6 = rfc46486({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad6 = rfc46486({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper6 = rfc46486({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex6 = rfc46486({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper6 = rfc46486({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad6 = rfc46486({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper6 = rfc46486({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z6 = rfc46486({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/cid.js
  var CID6 = class {
    constructor(version8, code8, multihash, bytes) {
      this.code = code8;
      this.version = version8;
      this.multihash = multihash;
      this.bytes = bytes;
      this.byteOffset = bytes.byteOffset;
      this.byteLength = bytes.byteLength;
      this.asCID = this;
      this._baseCache = /* @__PURE__ */ new Map();
      Object.defineProperties(this, {
        byteOffset: hidden5,
        byteLength: hidden5,
        code: readonly6,
        version: readonly6,
        multihash: readonly6,
        bytes: readonly6,
        _baseCache: hidden5,
        asCID: hidden5
      });
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        default: {
          const { code: code8, multihash } = this;
          if (code8 !== DAG_PB_CODE6) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE6) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID6.createV0(multihash);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code8, digest: digest3 } = this.multihash;
          const multihash = create6(code8, digest3);
          return CID6.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return other && this.code === other.code && this.version === other.version && equals13(this.multihash, other.multihash);
    }
    toString(base7) {
      const { bytes, version: version8, _baseCache } = this;
      switch (version8) {
        case 0:
          return toStringV06(bytes, _baseCache, base7 || base58btc6.encoder);
        default:
          return toStringV16(bytes, _baseCache, base7 || base326.encoder);
      }
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
      deprecate6(/^0\.0/, IS_CID_DEPRECATION5);
      return !!(value && (value[cidSymbol6] || value.asCID === value));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
      if (value instanceof CID6) {
        return value;
      } else if (value != null && value.asCID === value) {
        const { version: version8, code: code8, multihash, bytes } = value;
        return new CID6(version8, code8, multihash, bytes || encodeCID6(version8, code8, multihash.bytes));
      } else if (value != null && value[cidSymbol6] === true) {
        const { version: version8, multihash, code: code8 } = value;
        const digest3 = decode29(multihash);
        return CID6.create(version8, code8, digest3);
      } else {
        return null;
      }
    }
    static create(version8, code8, digest3) {
      if (typeof code8 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      switch (version8) {
        case 0: {
          if (code8 !== DAG_PB_CODE6) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`);
          } else {
            return new CID6(version8, code8, digest3, digest3.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID6(version8, code8, digest3.bytes);
          return new CID6(version8, code8, digest3, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest3) {
      return CID6.create(0, DAG_PB_CODE6, digest3);
    }
    static createV1(code8, digest3) {
      return CID6.create(1, code8, digest3);
    }
    static decode(bytes) {
      const [cid, remainder] = CID6.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes) {
      const specs = CID6.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce6(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest3 = new Digest6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? CID6.createV0(digest3) : CID6.createV1(specs.codec, digest3);
      return [
        cid,
        bytes.subarray(specs.size)
      ];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i2, length7] = decode28(initialBytes.subarray(offset));
        offset += length7;
        return i2;
      };
      let version8 = next();
      let codec = DAG_PB_CODE6;
      if (version8 === 18) {
        version8 = 0;
        offset = 0;
      } else if (version8 === 1) {
        codec = next();
      }
      if (version8 !== 0 && version8 !== 1) {
        throw new RangeError(`Invalid CID version ${version8}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return {
        version: version8,
        codec,
        multihashCode,
        digestSize,
        multihashSize,
        size
      };
    }
    static parse(source, base7) {
      const [prefix, bytes] = parseCIDtoBytes6(source, base7);
      const cid = CID6.decode(bytes);
      cid._baseCache.set(prefix, source);
      return cid;
    }
  };
  var parseCIDtoBytes6 = (source, base7) => {
    switch (source[0]) {
      case "Q": {
        const decoder = base7 || base58btc6;
        return [
          base58btc6.prefix,
          decoder.decode(`${base58btc6.prefix}${source}`)
        ];
      }
      case base58btc6.prefix: {
        const decoder = base7 || base58btc6;
        return [
          base58btc6.prefix,
          decoder.decode(source)
        ];
      }
      case base326.prefix: {
        const decoder = base7 || base326;
        return [
          base326.prefix,
          decoder.decode(source)
        ];
      }
      default: {
        if (base7 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [
          source[0],
          base7.decode(source)
        ];
      }
    }
  };
  var toStringV06 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    if (prefix !== base58btc6.prefix) {
      throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV16 = (bytes, cache2, base7) => {
    const { prefix } = base7;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base7.encode(bytes);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE6 = 112;
  var SHA_256_CODE6 = 18;
  var encodeCID6 = (version8, code8, multihash) => {
    const codeOffset = encodingLength6(version8);
    const hashOffset = codeOffset + encodingLength6(code8);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo6(version8, bytes, 0);
    encodeTo6(code8, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");
  var readonly6 = {
    writable: false,
    configurable: false,
    enumerable: true
  };
  var hidden5 = {
    writable: false,
    enumerable: false,
    configurable: false
  };
  var version7 = "0.0.0-dev";
  var deprecate6 = (range, message) => {
    if (range.test(version7)) {
      console.warn(message);
    } else {
      throw new Error(message);
    }
  };
  var IS_CID_DEPRECATION5 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

  // node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js
  var persist = async (buffer2, blockstore, options) => {
    if (!options.codec) {
      options.codec = src_exports2;
    }
    if (!options.hasher) {
      options.hasher = sha2562;
    }
    if (options.cidVersion === void 0) {
      options.cidVersion = 1;
    }
    if (options.codec === src_exports2 && options.hasher !== sha2562) {
      options.cidVersion = 1;
    }
    const multihash = await options.hasher.digest(buffer2);
    const cid = CID6.create(options.cidVersion, options.codec.code, multihash);
    if (!options.onlyHash) {
      await blockstore.put(cid, buffer2, { signal: options.signal });
    }
    return cid;
  };
  var persist_default = persist;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js
  var dirBuilder = async (item, blockstore, options) => {
    const unixfs = new UnixFS({
      type: "directory",
      mtime: item.mtime,
      mode: item.mode
    });
    const buffer2 = encode10(prepare({ Data: unixfs.marshal() }));
    const cid = await persist_default(buffer2, blockstore, options);
    const path = item.path;
    return {
      cid,
      path,
      unixfs,
      size: buffer2.length
    };
  };
  var dir_default = dirBuilder;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
  init_virtual_process_polyfill();
  var import_err_code10 = __toESM(require_err_code(), 1);
  var import_it_parallel_batch = __toESM(require_it_parallel_batch(), 1);

  // node_modules/ipfs-unixfs-importer/node_modules/multiformats/esm/src/codecs/raw.js
  var raw_exports3 = {};
  __export(raw_exports3, {
    code: () => code7,
    decode: () => decode31,
    encode: () => encode20,
    name: () => name5
  });
  init_virtual_process_polyfill();
  var name5 = "raw";
  var code7 = 85;
  var encode20 = (node) => coerce6(node);
  var decode31 = (data) => coerce6(data);

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/flat.js
  init_virtual_process_polyfill();
  var import_it_all = __toESM(require_it_all(), 1);
  async function flat(source, reduce2) {
    return reduce2(await (0, import_it_all.default)(source));
  }
  var flat_default = flat;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/balanced.js
  init_virtual_process_polyfill();
  var import_it_batch = __toESM(require_it_batch(), 1);
  function balanced(source, reduce2, options) {
    return reduceToParents(source, reduce2, options);
  }
  async function reduceToParents(source, reduce2, options) {
    const roots = [];
    for await (const chunked of (0, import_it_batch.default)(source, options.maxChildrenPerNode)) {
      roots.push(await reduce2(chunked));
    }
    if (roots.length > 1) {
      return reduceToParents(roots, reduce2, options);
    }
    return roots[0];
  }
  var balanced_default = balanced;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js
  init_virtual_process_polyfill();
  var import_it_batch2 = __toESM(require_it_batch(), 1);
  async function trickleStream(source, reduce2, options) {
    const root = new Root(options.layerRepeat);
    let iteration = 0;
    let maxDepth = 1;
    let subTree = root;
    for await (const layer of (0, import_it_batch2.default)(source, options.maxChildrenPerNode)) {
      if (subTree.isFull()) {
        if (subTree !== root) {
          root.addChild(await subTree.reduce(reduce2));
        }
        if (iteration && iteration % options.layerRepeat === 0) {
          maxDepth++;
        }
        subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
        iteration++;
      }
      subTree.append(layer);
    }
    if (subTree && subTree !== root) {
      root.addChild(await subTree.reduce(reduce2));
    }
    return root.reduce(reduce2);
  }
  var trickle_default = trickleStream;
  var SubTree = class {
    constructor(maxDepth, layerRepeat, iteration = 0) {
      this.maxDepth = maxDepth;
      this.layerRepeat = layerRepeat;
      this.currentDepth = 1;
      this.iteration = iteration;
      this.root = this.node = this.parent = {
        children: [],
        depth: this.currentDepth,
        maxDepth,
        maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
      };
    }
    isFull() {
      if (!this.root.data) {
        return false;
      }
      if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
        this._addNextNodeToParent(this.node);
        return false;
      }
      const distantRelative = this._findParent(this.node, this.currentDepth);
      if (distantRelative) {
        this._addNextNodeToParent(distantRelative);
        return false;
      }
      return true;
    }
    _addNextNodeToParent(parent) {
      this.parent = parent;
      const nextNode = {
        children: [],
        depth: parent.depth + 1,
        parent,
        maxDepth: this.maxDepth,
        maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
      };
      parent.children.push(nextNode);
      this.currentDepth = nextNode.depth;
      this.node = nextNode;
    }
    append(layer) {
      this.node.data = layer;
    }
    reduce(reduce2) {
      return this._reduce(this.root, reduce2);
    }
    async _reduce(node, reduce2) {
      let children = [];
      if (node.children.length) {
        children = await Promise.all(node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2)));
      }
      return reduce2((node.data || []).concat(children));
    }
    _findParent(node, depth) {
      const parent = node.parent;
      if (!parent || parent.depth === 0) {
        return;
      }
      if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
        return this._findParent(parent, depth);
      }
      return parent;
    }
  };
  var Root = class extends SubTree {
    constructor(layerRepeat) {
      super(0, layerRepeat);
      this.root.depth = 0;
      this.currentDepth = 1;
    }
    addChild(child) {
      this.root.children.push(child);
    }
    reduce(reduce2) {
      return reduce2((this.root.data || []).concat(this.root.children));
    }
  };

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/buffer-importer.js
  init_virtual_process_polyfill();
  async function* bufferImporter(file, block, options) {
    for await (let buffer2 of file.content) {
      yield async () => {
        options.progress(buffer2.length, file.path);
        let unixfs;
        const opts = {
          codec: src_exports2,
          cidVersion: options.cidVersion,
          hasher: options.hasher,
          onlyHash: options.onlyHash
        };
        if (options.rawLeaves) {
          opts.codec = raw_exports3;
          opts.cidVersion = 1;
        } else {
          unixfs = new UnixFS({
            type: options.leafType,
            data: buffer2
          });
          buffer2 = encode10({
            Data: unixfs.marshal(),
            Links: []
          });
        }
        return {
          cid: await persist_default(buffer2, block, opts),
          unixfs,
          size: buffer2.length
        };
      };
    }
  }
  var buffer_importer_default = bufferImporter;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
  var dagBuilders = {
    flat: flat_default,
    balanced: balanced_default,
    trickle: trickle_default
  };
  async function* buildFileBatch(file, blockstore, options) {
    let count = -1;
    let previous;
    let bufferImporter2;
    if (typeof options.bufferImporter === "function") {
      bufferImporter2 = options.bufferImporter;
    } else {
      bufferImporter2 = buffer_importer_default;
    }
    for await (const entry of (0, import_it_parallel_batch.default)(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)) {
      count++;
      if (count === 0) {
        previous = entry;
        continue;
      } else if (count === 1 && previous) {
        yield previous;
        previous = null;
      }
      yield entry;
    }
    if (previous) {
      previous.single = true;
      yield previous;
    }
  }
  var reduce = (file, blockstore, options) => {
    async function reducer(leaves) {
      if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
        const leaf = leaves[0];
        if (file.mtime !== void 0 || file.mode !== void 0) {
          let buffer3 = await blockstore.get(leaf.cid);
          leaf.unixfs = new UnixFS({
            type: "file",
            mtime: file.mtime,
            mode: file.mode,
            data: buffer3
          });
          buffer3 = encode10(prepare({ Data: leaf.unixfs.marshal() }));
          leaf.cid = await persist_default(buffer3, blockstore, {
            ...options,
            codec: src_exports2,
            hasher: options.hasher,
            cidVersion: options.cidVersion
          });
          leaf.size = buffer3.length;
        }
        return {
          cid: leaf.cid,
          path: file.path,
          unixfs: leaf.unixfs,
          size: leaf.size
        };
      }
      const f2 = new UnixFS({
        type: "file",
        mtime: file.mtime,
        mode: file.mode
      });
      const links2 = leaves.filter((leaf) => {
        if (leaf.cid.code === code7 && leaf.size) {
          return true;
        }
        if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
          return true;
        }
        return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
      }).map((leaf) => {
        if (leaf.cid.code === code7) {
          f2.addBlockSize(leaf.size);
          return {
            Name: "",
            Tsize: leaf.size,
            Hash: leaf.cid
          };
        }
        if (!leaf.unixfs || !leaf.unixfs.data) {
          f2.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
        } else {
          f2.addBlockSize(leaf.unixfs.data.length);
        }
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      });
      const node = {
        Data: f2.marshal(),
        Links: links2
      };
      const buffer2 = encode10(prepare(node));
      const cid = await persist_default(buffer2, blockstore, options);
      return {
        cid,
        path: file.path,
        unixfs: f2,
        size: buffer2.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
      };
    }
    return reducer;
  };
  function fileBuilder(file, block, options) {
    const dagBuilder2 = dagBuilders[options.strategy];
    if (!dagBuilder2) {
      throw (0, import_err_code10.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
    }
    return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
  }
  var file_default2 = fileBuilder;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
  var import_err_code13 = __toESM(require_err_code(), 1);

  // node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js
  init_virtual_process_polyfill();
  var import_BufferList = __toESM(require_BufferList(), 1);
  var import_rabin_wasm = __toESM(require_src2(), 1);
  var import_err_code11 = __toESM(require_err_code(), 1);
  async function* rabinChunker(source, options) {
    let min, max, avg;
    if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
      avg = options.avgChunkSize;
      min = options.minChunkSize;
      max = options.maxChunkSize;
    } else if (!options.avgChunkSize) {
      throw (0, import_err_code11.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
    } else {
      avg = options.avgChunkSize;
      min = avg / 3;
      max = avg + avg / 2;
    }
    if (min < 16) {
      throw (0, import_err_code11.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
    }
    if (max < min) {
      max = min;
    }
    if (avg < min) {
      avg = min;
    }
    const sizepow = Math.floor(Math.log2(avg));
    for await (const chunk of rabin(source, {
      min,
      max,
      bits: sizepow,
      window: options.window,
      polynomial: options.polynomial
    })) {
      yield chunk;
    }
  }
  var rabin_default = rabinChunker;
  async function* rabin(source, options) {
    const r2 = await (0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window);
    const buffers = new import_BufferList.default();
    for await (const chunk of source) {
      buffers.append(chunk);
      const sizes = r2.fingerprint(chunk);
      for (let i2 = 0; i2 < sizes.length; i2++) {
        const size = sizes[i2];
        const buf2 = buffers.slice(0, size);
        buffers.consume(size);
        yield buf2;
      }
    }
    if (buffers.length) {
      yield buffers.slice(0);
    }
  }

  // node_modules/ipfs-unixfs-importer/esm/src/chunker/fixed-size.js
  init_virtual_process_polyfill();
  var import_BufferList2 = __toESM(require_BufferList(), 1);
  async function* fixedSizeChunker(source, options) {
    let bl = new import_BufferList2.default();
    let currentLength = 0;
    let emitted = false;
    const maxChunkSize = options.maxChunkSize;
    for await (const buffer2 of source) {
      bl.append(buffer2);
      currentLength += buffer2.length;
      while (currentLength >= maxChunkSize) {
        yield bl.slice(0, maxChunkSize);
        emitted = true;
        if (maxChunkSize === bl.length) {
          bl = new import_BufferList2.default();
          currentLength = 0;
        } else {
          const newBl = new import_BufferList2.default();
          newBl.append(bl.shallowSlice(maxChunkSize));
          bl = newBl;
          currentLength -= maxChunkSize;
        }
      }
    }
    if (!emitted || currentLength) {
      yield bl.slice(0, currentLength);
    }
  }
  var fixed_size_default = fixedSizeChunker;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js
  init_virtual_process_polyfill();
  var import_err_code12 = __toESM(require_err_code(), 1);
  init_from_string();
  async function* validateChunks(source) {
    for await (const content of source) {
      if (content.length === void 0) {
        throw (0, import_err_code12.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
      if (typeof content === "string" || content instanceof String) {
        yield fromString4(content.toString());
      } else if (Array.isArray(content)) {
        yield Uint8Array.from(content);
      } else if (content instanceof Uint8Array) {
        yield content;
      } else {
        throw (0, import_err_code12.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
    }
  }
  var validate_chunks_default = validateChunks;

  // node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
  function isIterable(thing) {
    return Symbol.iterator in thing;
  }
  function isAsyncIterable(thing) {
    return Symbol.asyncIterator in thing;
  }
  function contentAsAsyncIterable(content) {
    try {
      if (content instanceof Uint8Array) {
        return async function* () {
          yield content;
        }();
      } else if (isIterable(content)) {
        return async function* () {
          yield* content;
        }();
      } else if (isAsyncIterable(content)) {
        return content;
      }
    } catch {
      throw (0, import_err_code13.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    throw (0, import_err_code13.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  async function* dagBuilder(source, blockstore, options) {
    for await (const entry of source) {
      if (entry.path) {
        if (entry.path.substring(0, 2) === "./") {
          options.wrapWithDirectory = true;
        }
        entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
      }
      if (entry.content) {
        let chunker;
        if (typeof options.chunker === "function") {
          chunker = options.chunker;
        } else if (options.chunker === "rabin") {
          chunker = rabin_default;
        } else {
          chunker = fixed_size_default;
        }
        let chunkValidator;
        if (typeof options.chunkValidator === "function") {
          chunkValidator = options.chunkValidator;
        } else {
          chunkValidator = validate_chunks_default;
        }
        const file = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode,
          content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
        };
        yield () => file_default2(file, blockstore, options);
      } else if (entry.path) {
        const dir = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode
        };
        yield () => dir_default(dir, blockstore, options);
      } else {
        throw new Error("Import candidate must have content or path or both");
      }
    }
  }
  var dag_builder_default = dagBuilder;

  // node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/esm/src/dir.js
  init_virtual_process_polyfill();
  var Dir = class {
    constructor(props, options) {
      this.options = options || {};
      this.root = props.root;
      this.dir = props.dir;
      this.path = props.path;
      this.dirty = props.dirty;
      this.flat = props.flat;
      this.parent = props.parent;
      this.parentKey = props.parentKey;
      this.unixfs = props.unixfs;
      this.mode = props.mode;
      this.mtime = props.mtime;
      this.cid = void 0;
      this.size = void 0;
    }
    async put(name6, value) {
    }
    get(name6) {
      return Promise.resolve(this);
    }
    async *eachChildSeries() {
    }
    async *flush(blockstore) {
    }
  };
  var dir_default2 = Dir;

  // node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js
  var DirFlat = class extends dir_default2 {
    constructor(props, options) {
      super(props, options);
      this._children = {};
    }
    async put(name6, value) {
      this.cid = void 0;
      this.size = void 0;
      this._children[name6] = value;
    }
    get(name6) {
      return Promise.resolve(this._children[name6]);
    }
    childCount() {
      return Object.keys(this._children).length;
    }
    directChildrenCount() {
      return this.childCount();
    }
    onlyChild() {
      return this._children[Object.keys(this._children)[0]];
    }
    async *eachChildSeries() {
      const keys = Object.keys(this._children);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        yield {
          key,
          child: this._children[key]
        };
      }
    }
    async *flush(block) {
      const children = Object.keys(this._children);
      const links2 = [];
      for (let i2 = 0; i2 < children.length; i2++) {
        let child = this._children[children[i2]];
        if (child instanceof dir_default2) {
          for await (const entry of child.flush(block)) {
            child = entry;
            yield child;
          }
        }
        if (child.size != null && child.cid) {
          links2.push({
            Name: children[i2],
            Tsize: child.size,
            Hash: child.cid
          });
        }
      }
      const unixfs = new UnixFS({
        type: "directory",
        mtime: this.mtime,
        mode: this.mode
      });
      const node = {
        Data: unixfs.marshal(),
        Links: links2
      };
      const buffer2 = encode10(prepare(node));
      const cid = await persist_default(buffer2, block, this.options);
      const size = buffer2.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
      this.cid = cid;
      this.size = size;
      yield {
        cid,
        unixfs,
        path: this.path,
        size
      };
    }
  };
  var dir_flat_default = DirFlat;

  // node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js
  init_virtual_process_polyfill();

  // node_modules/ipfs-unixfs-importer/esm/src/dir-sharded.js
  init_virtual_process_polyfill();
  var import_hamt_sharding2 = __toESM(require_src(), 1);
  var DirSharded = class extends dir_default2 {
    constructor(props, options) {
      super(props, options);
      this._bucket = (0, import_hamt_sharding2.createHAMT)({
        hashFn: options.hamtHashFn,
        bits: options.hamtBucketBits
      });
    }
    async put(name6, value) {
      await this._bucket.put(name6, value);
    }
    get(name6) {
      return this._bucket.get(name6);
    }
    childCount() {
      return this._bucket.leafCount();
    }
    directChildrenCount() {
      return this._bucket.childrenCount();
    }
    onlyChild() {
      return this._bucket.onlyChild();
    }
    async *eachChildSeries() {
      for await (const { key, value } of this._bucket.eachLeafSeries()) {
        yield {
          key,
          child: value
        };
      }
    }
    async *flush(blockstore) {
      for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
        yield {
          ...entry,
          path: this.path
        };
      }
    }
  };
  var dir_sharded_default = DirSharded;
  async function* flush(bucket, blockstore, shardRoot, options) {
    const children = bucket._children;
    const links2 = [];
    let childrenSize = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children.get(i2);
      if (!child) {
        continue;
      }
      const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
      if (child instanceof import_hamt_sharding2.Bucket) {
        let shard;
        for await (const subShard of await flush(child, blockstore, null, options)) {
          shard = subShard;
        }
        if (!shard) {
          throw new Error("Could not flush sharded directory, no subshard found");
        }
        links2.push({
          Name: labelPrefix,
          Tsize: shard.size,
          Hash: shard.cid
        });
        childrenSize += shard.size;
      } else if (typeof child.value.flush === "function") {
        const dir2 = child.value;
        let flushedDir;
        for await (const entry of dir2.flush(blockstore)) {
          flushedDir = entry;
          yield flushedDir;
        }
        const label = labelPrefix + child.key;
        links2.push({
          Name: label,
          Tsize: flushedDir.size,
          Hash: flushedDir.cid
        });
        childrenSize += flushedDir.size;
      } else {
        const value = child.value;
        if (!value.cid) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size2 = value.size;
        links2.push({
          Name: label,
          Tsize: size2,
          Hash: value.cid
        });
        childrenSize += size2;
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: bucket.tableSize(),
      hashType: options.hamtHashCode,
      mtime: shardRoot && shardRoot.mtime,
      mode: shardRoot && shardRoot.mode
    });
    const node = {
      Data: dir.marshal(),
      Links: links2
    };
    const buffer2 = encode10(prepare(node));
    const cid = await persist_default(buffer2, blockstore, options);
    const size = buffer2.length + childrenSize;
    yield {
      cid,
      unixfs: dir,
      size
    };
  }

  // node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js
  async function flatToShard(child, dir, threshold, options) {
    let newDir = dir;
    if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
      newDir = await convertToShard(dir, options);
    }
    const parent = newDir.parent;
    if (parent) {
      if (newDir !== dir) {
        if (child) {
          child.parent = newDir;
        }
        if (!newDir.parentKey) {
          throw new Error("No parent key found");
        }
        await parent.put(newDir.parentKey, newDir);
      }
      return flatToShard(newDir, parent, threshold, options);
    }
    return newDir;
  }
  async function convertToShard(oldDir, options) {
    const newDir = new dir_sharded_default({
      root: oldDir.root,
      dir: true,
      parent: oldDir.parent,
      parentKey: oldDir.parentKey,
      path: oldDir.path,
      dirty: oldDir.dirty,
      flat: false,
      mtime: oldDir.mtime,
      mode: oldDir.mode
    }, options);
    for await (const { key, child } of oldDir.eachChildSeries()) {
      await newDir.put(key, child);
    }
    return newDir;
  }
  var flat_to_shard_default = flatToShard;

  // node_modules/ipfs-unixfs-importer/esm/src/utils/to-path-components.js
  init_virtual_process_polyfill();
  var toPathComponents2 = (path = "") => {
    return (path.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
  };
  var to_path_components_default = toPathComponents2;

  // node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js
  async function addToTree(elem, tree2, options) {
    const pathElems = to_path_components_default(elem.path || "");
    const lastIndex = pathElems.length - 1;
    let parent = tree2;
    let currentPath = "";
    for (let i2 = 0; i2 < pathElems.length; i2++) {
      const pathElem = pathElems[i2];
      currentPath += `${currentPath ? "/" : ""}${pathElem}`;
      const last2 = i2 === lastIndex;
      parent.dirty = true;
      parent.cid = void 0;
      parent.size = void 0;
      if (last2) {
        await parent.put(pathElem, elem);
        tree2 = await flat_to_shard_default(null, parent, options.shardSplitThreshold, options);
      } else {
        let dir = await parent.get(pathElem);
        if (!dir || !(dir instanceof dir_default2)) {
          dir = new dir_flat_default({
            root: false,
            dir: true,
            parent,
            parentKey: pathElem,
            path: currentPath,
            dirty: true,
            flat: true,
            mtime: dir && dir.unixfs && dir.unixfs.mtime,
            mode: dir && dir.unixfs && dir.unixfs.mode
          }, options);
        }
        await parent.put(pathElem, dir);
        parent = dir;
      }
    }
    return tree2;
  }
  async function* flushAndYield(tree2, blockstore) {
    if (!(tree2 instanceof dir_default2)) {
      if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
        yield tree2;
      }
      return;
    }
    yield* tree2.flush(blockstore);
  }
  async function* treeBuilder(source, block, options) {
    let tree2 = new dir_flat_default({
      root: true,
      dir: true,
      path: "",
      dirty: true,
      flat: true
    }, options);
    for await (const entry of source) {
      if (!entry) {
        continue;
      }
      tree2 = await addToTree(entry, tree2, options);
      if (!entry.unixfs || !entry.unixfs.isDirectory()) {
        yield entry;
      }
    }
    if (options.wrapWithDirectory) {
      yield* flushAndYield(tree2, block);
    } else {
      for await (const unwrapped of tree2.eachChildSeries()) {
        if (!unwrapped) {
          continue;
        }
        yield* flushAndYield(unwrapped.child, block);
      }
    }
  }
  var tree_builder_default = treeBuilder;

  // node_modules/ipfs-unixfs-importer/esm/src/index.js
  async function* importer(source, blockstore, options = {}) {
    const opts = options_default(options);
    let dagBuilder2;
    if (typeof options.dagBuilder === "function") {
      dagBuilder2 = options.dagBuilder;
    } else {
      dagBuilder2 = dag_builder_default;
    }
    let treeBuilder2;
    if (typeof options.treeBuilder === "function") {
      treeBuilder2 = options.treeBuilder;
    } else {
      treeBuilder2 = tree_builder_default;
    }
    let candidates;
    if (Symbol.asyncIterator in source || Symbol.iterator in source) {
      candidates = source;
    } else {
      candidates = [source];
    }
    for await (const entry of treeBuilder2((0, import_it_parallel_batch2.default)(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
      yield {
        cid: entry.cid,
        path: entry.path,
        unixfs: entry.unixfs,
        size: entry.size
      };
    }
  }

  // node_modules/multiformats/src/hashes/sha2-browser.js
  init_virtual_process_polyfill();
  var sha3 = (name6) => async (data) => new Uint8Array(await crypto.subtle.digest(name6, data));
  var sha2563 = from3({
    name: "sha2-256",
    code: 18,
    encode: sha3("SHA-256")
  });
  var sha5123 = from3({
    name: "sha2-512",
    code: 19,
    encode: sha3("SHA-512")
  });

  // src/message-store.js
  var import_level2 = __toESM(require_browser(), 1);
  var _config, _db2, _eventLog, _index, _buildIndexQueryTerms, buildIndexQueryTerms_fn, _hash, hash_fn;
  var _MessageStoreLevelv2 = class {
    constructor(config3) {
      __privateAdd(this, _config, void 0);
      __privateAdd(this, _db2, void 0);
      __privateAdd(this, _eventLog, void 0);
      __privateAdd(this, _index, void 0);
      __privateSet(this, _config, {
        blockstoreLocation: "BLOCKSTORE",
        indexLocation: "INDEX",
        ...config3
      });
      __privateSet(this, _db2, new Blockstore(__privateGet(this, _config).blockstoreLocation));
      __privateSet(this, _eventLog, new import_level2.Level("EVENTLOG"));
    }
    async open() {
      if (!__privateGet(this, _db2)) {
        __privateSet(this, _db2, new Blockstore(__privateGet(this, _config).blockstoreLocation));
      }
      await __privateGet(this, _db2).open();
      if (!__privateGet(this, _index)) {
        __privateSet(this, _index, await (0, import_search_index.default)({ name: __privateGet(this, _config).indexLocation }));
      }
    }
    async close() {
      await __privateGet(this, _db2).close();
      await __privateGet(this, _index).INDEX.STORE.close();
      await __privateGet(this, _eventLog).close();
    }
    async has(cid) {
      const bytes = await __privateGet(this, _db2).get(cid);
      return !!bytes;
    }
    async get(cid) {
      const bytes = await __privateGet(this, _db2).get(cid);
      if (!bytes) {
        return;
      }
      const decodedBlock = await decode5({ bytes, codec: src_exports, hasher: sha2563 });
      const messageJson = decodedBlock.value;
      if (!messageJson.descriptor["dataCid"]) {
        return messageJson;
      }
      const dataReferencingMessage = decodedBlock.value;
      const dataCid = CID.parse(dataReferencingMessage.descriptor.dataCid);
      const dataDagRoot = await exporter(dataCid, __privateGet(this, _db2));
      const dataBytes = new Uint8Array(dataDagRoot.size);
      let offset = 0;
      for await (const chunk of dataDagRoot.content()) {
        dataBytes.set(chunk, offset);
        offset += chunk.length;
      }
      dataReferencingMessage.encodedData = Encoder2.bytesToBase64Url(dataBytes);
      return messageJson;
    }
    async getEventLog(tenant, watermark) {
      var _a;
      const tenantPrefix = await __privateMethod(_a = _MessageStoreLevelv2, _hash, hash_fn).call(_a, tenant);
      const tenantEventLog = __privateGet(this, _eventLog).sublevel(tenantPrefix);
      if (!tenantEventLog) {
        return [];
      }
      let opts = {};
      if (watermark) {
        opts.gt = watermark;
      }
      const events = [];
      for await (let [key, value] of tenantEventLog.iterator(opts)) {
        const event = {
          watermark: key,
          messageCid: value
        };
        events.push(event);
      }
      return events;
    }
    async query(criteria) {
      var _a;
      const messages = [];
      const queryTerms = __privateMethod(_a = _MessageStoreLevelv2, _buildIndexQueryTerms, buildIndexQueryTerms_fn).call(_a, criteria);
      const { RESULT: indexResults } = await __privateGet(this, _index).QUERY({ AND: queryTerms });
      for (const result of indexResults) {
        const cid = CID.parse(result._id);
        const message = await this.get(cid);
        messages.push(message);
      }
      return messages;
    }
    async delete(cid) {
      await __privateGet(this, _db2).delete(cid);
      await __privateGet(this, _index).DELETE(cid.toString());
      return;
    }
    async put(messageJson, indexes) {
      var _a;
      let messageCopy = { ...messageJson };
      let encodedData = void 0;
      if (messageCopy["encodedData"] !== void 0) {
        const messageJsonWithEncodedData = messageCopy;
        encodedData = messageJsonWithEncodedData.encodedData;
        delete messageJsonWithEncodedData.encodedData;
      }
      const encodedBlock = await encode3({ value: messageCopy, codec: src_exports, hasher: sha2563 });
      await __privateGet(this, _db2).put(encodedBlock.cid, encodedBlock.bytes);
      if (encodedData) {
        const content = Encoder2.base64UrlToBytes(encodedData);
        const chunk = importer([{ content }], __privateGet(this, _db2), { cidVersion: 1 });
        for await (const _3 of chunk) {
          ;
        }
      }
      const indexDocument = {
        _id: encodedBlock.cid.toString(),
        ...indexes
      };
      await __privateGet(this, _index).PUT([indexDocument], { tokenSplitRegex: /.+/ });
      const tenantHash = await __privateMethod(_a = _MessageStoreLevelv2, _hash, hash_fn).call(_a, indexDocument.target);
      const eventId = _MessageStoreLevelv2.generateID();
      const tenantEventLog = __privateGet(this, _eventLog).sublevel(tenantHash);
      await tenantEventLog.put(eventId, encodedBlock.cid.toString());
    }
    async clear() {
      await __privateGet(this, _db2).clear();
      await __privateGet(this, _eventLog).clear();
      await __privateGet(this, _index).FLUSH();
    }
    static generateID() {
      return wt.Now.instant().epochNanoseconds.toString();
    }
  };
  var MessageStoreLevelv2 = _MessageStoreLevelv2;
  _config = new WeakMap();
  _db2 = new WeakMap();
  _eventLog = new WeakMap();
  _index = new WeakMap();
  _buildIndexQueryTerms = new WeakSet();
  buildIndexQueryTerms_fn = function(query, terms = [], prefix = "") {
    var _a;
    for (const property in query) {
      const val = query[property];
      if (import_lodash.default.isPlainObject(val)) {
        __privateMethod(_a = _MessageStoreLevelv2, _buildIndexQueryTerms, buildIndexQueryTerms_fn).call(_a, val, terms, `${prefix}${property}.`);
      } else {
        const term = {
          FIELD: [`${prefix}${property}`],
          VALUE: val
        };
        terms.push(term);
      }
    }
    return terms;
  };
  _hash = new WeakSet();
  hash_fn = async function(prefix) {
    const bytes = Encoder2.stringToBytes(prefix);
    const bytesHashed = await sha2563.encode(bytes);
    const hashBase58BtcEncoded = base58btc.baseEncode(bytesHashed);
    return hashBase58BtcEncoded;
  };
  __privateAdd(MessageStoreLevelv2, _buildIndexQueryTerms);
  __privateAdd(MessageStoreLevelv2, _hash);
})();
//# sourceMappingURL=browser.js.map
